function mxBpmnShape(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxBpmnShape, mxShape);
mxBpmnShape.prototype.customProperties = [{
    name: "fillColor",
    dispName: "Fill Color",
    type: "color"
}, {
    name: "rounded",
    dispName: "Rounded",
    type: "bool"
}, {
    name: "strokeWidth",
    dispName: "Stroke Width",
    type: "int"
}, {
    name: "floatVal",
    dispName: "Float Value",
    type: "float"
}, {
    name: "fontFamily",
    dispName: "Font Family",
    type: "string"
}, {
    name: "verticalAlign",
    dispName: "Vertical Align",
    type: "enum",
    enumList: [{
        val: "middle",
        dispName: "Middle"
    }, {
        val: "bottom",
        dispName: "Bottom"
    }, {
        val: "top",
        dispName: "Top"
    }]
}];
mxBpmnShape.prototype.eventTypeEnum = {
    START_STANDARD: "standard",
    EVENT_SP_INT: "eventInt",
    EVENT_SP_NONINT: "eventNonint",
    CATCHING: "catching",
    BOUND_INT: "boundInt",
    BOUND_NONINT: "boundNonint",
    THROWING: "throwing",
    END: "end",
    NONE: "none",
    GATEWAY: "gateway"
};
mxBpmnShape.prototype.eventEnum = {
    GENERAL: "general",
    MESSAGE: "message",
    TIMER: "timer",
    ESCALATION: "escalation",
    CONDITIONAL: "conditional",
    LINK: "link",
    ERROR: "error",
    CANCEL: "cancel",
    COMPENSATION: "compensation",
    SIGNAL: "signal",
    MULTIPLE: "multiple",
    PAR_MULTI: "parallelMultiple",
    TERMINATE: "terminate",
    GW_EXCLUSIVE: "exclusiveGw",
    GW_PARALLEL: "parallelGw",
    GW_COMPLEX: "complexGw"
};
mxBpmnShape.prototype.miscEnum = {
    OUTLINE: "outline",
    BACKGROUND: "background",
    SYMBOL: "symbol",
    GATEWAY: "gateway"
};
mxBpmnShape.prototype.paintVertexShape = function(c, x, y, w, h) {
    this.redrawPath(c, x, y, w, h, mxBpmnShape.prototype.miscEnum.BACKGROUND);
    var bg = mxUtils.getValue(this.style, mxBpmnShape.prototype.miscEnum.BACKGROUND, mxBpmnShape.prototype.eventTypeEnum.NONE);
    if (bg === mxBpmnShape.prototype.eventTypeEnum.GATEWAY)
        c.setShadow(false);
    this.redrawPath(c, x, y, w, h, mxBpmnShape.prototype.miscEnum.OUTLINE);
    this.redrawPath(c, x, y, w, h, mxBpmnShape.prototype.miscEnum.SYMBOL)
}
;
mxBpmnShape.prototype.redrawPath = function(c, x, y, w, h, layer) {
    var bg = mxUtils.getValue(this.style, mxBpmnShape.prototype.miscEnum.BACKGROUND, mxBpmnShape.prototype.eventTypeEnum.NONE);
    if (layer == mxBpmnShape.prototype.miscEnum.BACKGROUND) {
        if (bg != null) {
            var f = this.backgrounds[bg];
            if (f != null) {
                c.translate(x, y);
                f.call(this, c, x, y, w, h, layer)
            }
        }
    } else if (layer == mxBpmnShape.prototype.miscEnum.OUTLINE) {
        if (bg === mxBpmnShape.prototype.eventTypeEnum.GATEWAY) {
            c.translate(w / 4, h / 4);
            h /= 2;
            w /= 2;
            this.constraints = [new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(.25,.25),false), new mxConnectionConstraint(new mxPoint(.25,.75),false), new mxConnectionConstraint(new mxPoint(.75,.25),false), new mxConnectionConstraint(new mxPoint(.75,.75),false)]
        } else
            this.constraints = [new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(.145,.145),false), new mxConnectionConstraint(new mxPoint(.145,.855),false), new mxConnectionConstraint(new mxPoint(.855,.145),false), new mxConnectionConstraint(new mxPoint(.855,.855),false)];
        var o = mxUtils.getValue(this.style, mxBpmnShape.prototype.miscEnum.OUTLINE, mxBpmnShape.prototype.eventTypeEnum.NONE);
        if (o != null) {
            var f = this.outlines[o];
            if (f != null)
                f.call(this, c, x, y, w, h, bg === mxBpmnShape.prototype.eventTypeEnum.GATEWAY)
        }
    } else if (layer == mxBpmnShape.prototype.miscEnum.SYMBOL) {
        if (bg === mxBpmnShape.prototype.eventTypeEnum.GATEWAY) {
            h /= 2;
            w /= 2
        }
        var s = mxUtils.getValue(this.style, mxBpmnShape.prototype.miscEnum.SYMBOL, null);
        if (s != null) {
            var f = this.symbols[s];
            if (f != null) {
                var strokeColor = c.state.strokeColor;
                var fillColor = c.state.fillColor;
                var o = mxUtils.getValue(this.style, mxBpmnShape.prototype.miscEnum.OUTLINE, mxBpmnShape.prototype.eventTypeEnum.NONE);
                if (s === mxBpmnShape.prototype.eventEnum.MESSAGE) {
                    c.translate(w * .15, h * .3);
                    w = w * .7;
                    h = h * .4
                } else if (s === mxBpmnShape.prototype.eventEnum.TIMER) {
                    c.translate(w * .11, h * .11);
                    w = w * .78;
                    h = h * .78
                } else if (s === mxBpmnShape.prototype.eventEnum.ESCALATION) {
                    c.translate(w * .19, h * .15);
                    w = w * .62;
                    h = h * .57
                } else if (s === mxBpmnShape.prototype.eventEnum.CONDITIONAL) {
                    c.translate(w * .3, h * .16);
                    w = w * .4;
                    h = h * .68
                } else if (s === mxBpmnShape.prototype.eventEnum.LINK) {
                    c.translate(w * .27, h * .33);
                    w = w * .46;
                    h = h * .34
                } else if (s === mxBpmnShape.prototype.eventEnum.ERROR) {
                    c.translate(w * .212, h * .243);
                    w = w * .58;
                    h = h * .507
                } else if (s === mxBpmnShape.prototype.eventEnum.CANCEL) {
                    c.translate(w * .22, h * .22);
                    w = w * .56;
                    h = h * .56
                } else if (s === mxBpmnShape.prototype.eventEnum.COMPENSATION) {
                    c.translate(w * .28, h * .35);
                    w = w * .44;
                    h = h * .3
                } else if (s === mxBpmnShape.prototype.eventEnum.SIGNAL) {
                    c.translate(w * .19, h * .15);
                    w = w * .62;
                    h = h * .57
                } else if (s === mxBpmnShape.prototype.eventEnum.MULTIPLE) {
                    c.translate(w * .2, h * .19);
                    w = w * .6;
                    h = h * .565
                } else if (s === mxBpmnShape.prototype.eventEnum.PAR_MULTI) {
                    c.translate(w * .2, h * .2);
                    w = w * .6;
                    h = h * .6
                } else if (s === mxBpmnShape.prototype.eventEnum.TERMINATE) {
                    c.translate(w * .05, h * .05);
                    w = w * .9;
                    h = h * .9
                } else if (s === mxBpmnShape.prototype.eventEnum.GW_EXCLUSIVE) {
                    c.translate(w * .12, 0);
                    w = w * .76
                } else if (s === mxBpmnShape.prototype.eventEnum.GW_PARALLEL)
                    ;
                else if (s === mxBpmnShape.prototype.eventEnum.GW_COMPLEX)
                    ;isInverse = false;
                if (s === "star")
                    c.setFillColor(strokeColor);
                else if (o === mxBpmnShape.prototype.eventTypeEnum.THROWING || o === mxBpmnShape.prototype.eventTypeEnum.END) {
                    c.setStrokeColor(fillColor);
                    c.setFillColor(strokeColor);
                    isInverse = true
                }
                f.call(this, c, x, y, w, h, layer, isInverse);
                if (s === "star")
                    c.setFillColor(fillColor);
                else if (o === mxBpmnShape.prototype.eventTypeEnum.THROWING || o === mxBpmnShape.prototype.eventTypeEnum.END) {
                    c.setStrokeColor(strokeColor);
                    c.setFillColor(fillColor)
                }
            }
        }
    }
}
;
mxBpmnShape.prototype.backgrounds = {
    "none": function(c, x, y, w, h) {},
    "gateway": function(c, x, y, w, h) {
        c.begin();
        c.moveTo(w / 2, 0);
        c.lineTo(w, h / 2);
        c.lineTo(w / 2, h);
        c.lineTo(0, h / 2);
        c.close();
        c.fillAndStroke()
    }
};
mxBpmnShape.prototype.outlines = {
    "none": function(c, x, y, w, h, isGateway) {
        if (!isGateway)
            c.setShadow(false)
    },
    "standard": function(c, x, y, w, h, isGateway) {
        c.ellipse(0, 0, w, h);
        c.fillAndStroke();
        if (!isGateway)
            c.setShadow(false)
    },
    "eventInt": function(c, x, y, w, h, isGateway) {
        c.ellipse(0, 0, w, h);
        c.fillAndStroke();
        if (!isGateway)
            c.setShadow(false)
    },
    "eventNonint": function(c, x, y, w, h, isGateway) {
        var dashed = c.state.dashed;
        c.setDashed(true);
        c.ellipse(0, 0, w, h);
        c.fillAndStroke();
        c.setDashed(dashed);
        if (!isGateway)
            c.setShadow(false)
    },
    "catching": function(c, x, y, w, h, isGateway) {
        c.ellipse(0, 0, w, h);
        c.fillAndStroke();
        if (!isGateway)
            c.setShadow(false);
        var inset = 2;
        c.ellipse(inset, inset, w - 2 * inset, h - 2 * inset);
        c.stroke()
    },
    "boundInt": function(c, x, y, w, h, isGateway) {
        c.ellipse(0, 0, w, h);
        c.fillAndStroke();
        if (!isGateway)
            c.setShadow(false);
        var inset = 2;
        c.ellipse(inset, inset, w - 2 * inset, h - 2 * inset);
        c.stroke()
    },
    "boundNonint": function(c, x, y, w, h, isGateway) {
        var dashed = c.state.dashed;
        c.setDashed(true);
        c.ellipse(0, 0, w, h);
        c.fillAndStroke();
        if (!isGateway)
            c.setShadow(false);
        var inset = 2;
        c.ellipse(inset, inset, w - 2 * inset, h - 2 * inset);
        c.stroke();
        c.setDashed(dashed)
    },
    "throwing": function(c, x, y, w, h, isGateway) {
        c.ellipse(0, 0, w, h);
        c.fillAndStroke();
        if (!isGateway)
            c.setShadow(false);
        var inset = 2;
        c.ellipse(w * .02 + inset, h * .02 + inset, w * .96 - 2 * inset, h * .96 - 2 * inset);
        c.stroke()
    },
    "end": function(c, x, y, w, h, isGateway) {
        var sw = c.state.strokeWidth;
        c.setStrokeWidth(sw * 3);
        c.ellipse(0, 0, w, h);
        c.fillAndStroke();
        c.setStrokeWidth(sw);
        if (!isGateway)
            c.setShadow(false)
    }
};
mxBpmnShape.prototype.symbols = {
    "general": function(c, x, y, w, h) {},
    "message": function(c, x, y, w, h, layer, isInverse) {
        c.rect(0, 0, w, h);
        c.fillAndStroke();
        var fc = mxUtils.getValue(this.style, "fillColor", "none");
        if (fc === "none")
            if (isInverse)
                c.setStrokeColor("#ffffff");
        c.begin();
        c.moveTo(0, 0);
        c.lineTo(w * .5, h * .5);
        c.lineTo(w, 0);
        c.stroke()
    },
    "timer": function(c, x, y, w, h) {
        c.ellipse(0, 0, w, h);
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .5, 0);
        c.lineTo(w * .5, h * .0642);
        c.moveTo(w * .7484, h * .0654);
        c.lineTo(w * .7126, h * .1281);
        c.moveTo(w * .93, h * .2471);
        c.lineTo(w * .8673, h * .2854);
        c.moveTo(w, h * .5);
        c.lineTo(w * .9338, h * .5);
        c.moveTo(w * .93, h * .7509);
        c.lineTo(w * .8673, h * .7126);
        c.moveTo(w * .7484, h * .9326);
        c.lineTo(w * .7126, h * .8699);
        c.moveTo(w * .5, h * .9338);
        c.lineTo(w * .5, h);
        c.moveTo(w * .2496, h * .9325);
        c.lineTo(w * .2854, h * .8699);
        c.moveTo(w * .068, h * .7509);
        c.lineTo(w * .1307, h * .7126);
        c.moveTo(0, h * .5);
        c.lineTo(w * .0642, h * .5);
        c.moveTo(w * .068, h * .2471);
        c.lineTo(w * .1307, h * .2854);
        c.moveTo(w * .2496, h * .0654);
        c.lineTo(w * .2854, h * .1281);
        c.moveTo(w * .5246, h * .0706);
        c.lineTo(w * .5, h * .5);
        c.lineTo(w * .7804, h * .5118);
        c.stroke()
    },
    "escalation": function(c, x, y, w, h) {
        c.begin();
        c.moveTo(0, h);
        c.lineTo(w * .5, 0);
        c.lineTo(w, h);
        c.lineTo(w * .5, h * .5);
        c.close();
        c.fillAndStroke()
    },
    "conditional": function(c, x, y, w, h) {
        c.rect(0, 0, w, h);
        c.fillAndStroke();
        c.begin();
        c.moveTo(0, h * .1027);
        c.lineTo(w * .798, h * .1027);
        c.moveTo(0, h * .3669);
        c.lineTo(w * .798, h * .3669);
        c.moveTo(0, h * .6311);
        c.lineTo(w * .798, h * .6311);
        c.moveTo(0, h * .8953);
        c.lineTo(w * .798, h * .8953);
        c.stroke()
    },
    "link": function(c, x, y, w, h) {
        c.begin();
        c.moveTo(0, h * .76);
        c.lineTo(0, h * .24);
        c.lineTo(w * .63, h * .24);
        c.lineTo(w * .63, 0);
        c.lineTo(w, h * .5);
        c.lineTo(w * .63, h);
        c.lineTo(w * .63, h * .76);
        c.close();
        c.fillAndStroke()
    },
    "error": function(c, x, y, w, h) {
        c.begin();
        c.moveTo(0, h);
        c.lineTo(w * .3287, h * .123);
        c.lineTo(w * .6194, h * .6342);
        c.lineTo(w, 0);
        c.lineTo(w * .6625, h * .939);
        c.lineTo(w * .3717, h * .5064);
        c.close();
        c.fillAndStroke()
    },
    "cancel": function(c, x, y, w, h) {
        c.begin();
        c.moveTo(w * .1051, 0);
        c.lineTo(w * .5, h * .3738);
        c.lineTo(w * .8909, 0);
        c.lineTo(w, h * .1054);
        c.lineTo(w * .623, h * .5);
        c.lineTo(w, h * .8926);
        c.lineTo(w * .8909, h);
        c.lineTo(w * .5, h * .6242);
        c.lineTo(w * .1051, h);
        c.lineTo(0, h * .8926);
        c.lineTo(w * .373, h * .5);
        c.lineTo(0, h * .1054);
        c.close();
        c.fillAndStroke()
    },
    "compensation": function(c, x, y, w, h) {
        c.begin();
        c.moveTo(0, h * .5);
        c.lineTo(w * .5, 0);
        c.lineTo(w * .5, h);
        c.close();
        c.moveTo(w * .5, h * .5);
        c.lineTo(w, 0);
        c.lineTo(w, h);
        c.close();
        c.fillAndStroke()
    },
    "signal": function(c, x, y, w, h) {
        c.begin();
        c.moveTo(0, h);
        c.lineTo(w * .5, 0);
        c.lineTo(w, h);
        c.close();
        c.fillAndStroke()
    },
    "multiple": function(c, x, y, w, h) {
        c.begin();
        c.moveTo(0, h * .39);
        c.lineTo(w * .5, 0);
        c.lineTo(w, h * .39);
        c.lineTo(w * .815, h);
        c.lineTo(w * .185, h);
        c.close();
        c.fillAndStroke()
    },
    "parallelMultiple": function(c, x, y, w, h) {
        c.begin();
        c.moveTo(w * .38, 0);
        c.lineTo(w * .62, 0);
        c.lineTo(w * .62, h * .38);
        c.lineTo(w, h * .38);
        c.lineTo(w, h * .62);
        c.lineTo(w * .62, h * .62);
        c.lineTo(w * .62, h);
        c.lineTo(w * .38, h);
        c.lineTo(w * .38, h * .62);
        c.lineTo(0, h * .62);
        c.lineTo(0, h * .38);
        c.lineTo(w * .38, h * .38);
        c.close();
        c.fillAndStroke()
    },
    "terminate": function(c, x, y, w, h) {
        c.ellipse(0, 0, w, h);
        c.fillAndStroke()
    },
    "exclusiveGw": function(c, x, y, w, h) {
        var strokeColor = c.state.strokeColor;
        var fillColor = c.state.fillColor;
        c.setStrokeColor(fillColor);
        c.setFillColor(strokeColor);
        c.begin();
        c.moveTo(w * .105, 0);
        c.lineTo(w * .5, h * .38);
        c.lineTo(w * .895, h * 0);
        c.lineTo(w, h * .11);
        c.lineTo(w * .6172, h * .5);
        c.lineTo(w, h * .89);
        c.lineTo(w * .895, h);
        c.lineTo(w * .5, h * .62);
        c.lineTo(w * .105, h);
        c.lineTo(0, h * .89);
        c.lineTo(w * .3808, h * .5);
        c.lineTo(0, h * .11);
        c.close();
        c.fillAndStroke();
        c.setStrokeColor(strokeColor);
        c.setFillColor(fillColor)
    },
    "parallelGw": function(c, x, y, w, h) {
        var strokeColor = c.state.strokeColor;
        var fillColor = c.state.fillColor;
        c.setStrokeColor(fillColor);
        c.setFillColor(strokeColor);
        c.begin();
        c.moveTo(w * .38, 0);
        c.lineTo(w * .62, 0);
        c.lineTo(w * .62, h * .38);
        c.lineTo(w, h * .38);
        c.lineTo(w, h * .62);
        c.lineTo(w * .62, h * .62);
        c.lineTo(w * .62, h);
        c.lineTo(w * .38, h);
        c.lineTo(w * .38, h * .62);
        c.lineTo(0, h * .62);
        c.lineTo(0, h * .38);
        c.lineTo(w * .38, h * .38);
        c.close();
        c.fillAndStroke();
        c.setStrokeColor(strokeColor);
        c.setFillColor(fillColor)
    },
    "complexGw": function(c, x, y, w, h) {
        var strokeColor = c.state.strokeColor;
        var fillColor = c.state.fillColor;
        c.setStrokeColor(fillColor);
        c.setFillColor(strokeColor);
        c.begin();
        c.moveTo(0, h * .44);
        c.lineTo(w * .36, h * .44);
        c.lineTo(w * .1, h * .18);
        c.lineTo(w * .18, h * .1);
        c.lineTo(w * .44, h * .36);
        c.lineTo(w * .44, 0);
        c.lineTo(w * .56, 0);
        c.lineTo(w * .56, h * .36);
        c.lineTo(w * .82, h * .1);
        c.lineTo(w * .9, h * .18);
        c.lineTo(w * .64, h * .44);
        c.lineTo(w, h * .44);
        c.lineTo(w, h * .56);
        c.lineTo(w * .64, h * .56);
        c.lineTo(w * .9, h * .82);
        c.lineTo(w * .82, h * .9);
        c.lineTo(w * .56, h * .64);
        c.lineTo(w * .56, h);
        c.lineTo(w * .44, h);
        c.lineTo(w * .44, h * .64);
        c.lineTo(w * .18, h * .9);
        c.lineTo(w * .1, h * .82);
        c.lineTo(w * .36, h * .56);
        c.lineTo(0, h * .56);
        c.close();
        c.fillAndStroke();
        c.setStrokeColor(strokeColor);
        c.setFillColor(fillColor)
    },
    "star": function(c, x, y, w, h) {
        c.translate(w / 5, h / 6);
        h *= 2 / 3;
        w *= 3 / 5;
        c.begin();
        c.moveTo(0, h / 4);
        c.lineTo(w / 3, h / 4);
        c.lineTo(w / 2, 0);
        c.lineTo(2 * w / 3, h / 4);
        c.lineTo(w, h / 4);
        c.lineTo(5 * w / 6, h / 2);
        c.lineTo(w, 3 * h / 4);
        c.lineTo(2 * w / 3, 3 * h / 4);
        c.lineTo(w / 2, h);
        c.lineTo(w / 3, 3 * h / 4);
        c.lineTo(0, 3 * h / 4);
        c.lineTo(w / 6, h / 2);
        c.close();
        c.fillAndStroke()
    }
};
mxCellRenderer.registerShape("mxgraph.bpmn.shape", mxBpmnShape);
function mxShapeEREntity(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeEREntity, mxShape);
mxShapeEREntity.prototype.paintVertexShape = function(c, x, y, w, h) {
    var mainText = mxUtils.getValue(this.style, "buttonText", "Entity");
    var fontColor = mxUtils.getValue(this.style, "textColor", "#666666");
    var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "17");
    c.translate(x, y);
    var rSize = 10;
    w = Math.max(w, 2 * rSize);
    h = Math.max(h, 2 * rSize);
    this.background(c, x, y, w, h, rSize, fontColor);
    c.setShadow(false);
    this.mainText(c, x, y, w, h, mainText, fontSize, fontColor)
}
;
mxShapeEREntity.prototype.background = function(c, x, y, w, h, rSize, fontColor) {
    var buttonStyle = mxUtils.getValue(this.style, "buttonStyle", "round").toString();
    if (buttonStyle === "round") {
        c.begin();
        c.moveTo(0, rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
        c.lineTo(w - rSize, 0);
        c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
        c.lineTo(w, h - rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
        c.lineTo(rSize, h);
        c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
        c.close();
        c.fillAndStroke()
    } else if (buttonStyle === "rect") {
        c.begin();
        c.moveTo(0, 0);
        c.lineTo(w, 0);
        c.lineTo(w, h);
        c.lineTo(0, h);
        c.close();
        c.fillAndStroke()
    } else if (buttonStyle === "dblFrame") {
        var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
        c.setFillColor(fillColor);
        c.begin();
        c.moveTo(0, 0);
        c.lineTo(w, 0);
        c.lineTo(w, h);
        c.lineTo(0, h);
        c.close();
        c.fillAndStroke();
        rSize = Math.min(w, h);
        c.begin();
        c.moveTo(rSize * .1, rSize * .1);
        c.lineTo(w - rSize * .1, rSize * .1);
        c.lineTo(w - rSize * .1, h - rSize * .1);
        c.lineTo(rSize * .1, h - rSize * .1);
        c.close();
        c.stroke()
    }
}
;
mxShapeEREntity.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor) {
    c.begin();
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    c.text(w * .5, h * .5, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape("mxgraph.er.entity", mxShapeEREntity);
mxShapeEREntity.prototype.constraints = [new mxConnectionConstraint(new mxPoint(.25,0),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.75,0),true), new mxConnectionConstraint(new mxPoint(0,.25),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(0,.75),true), new mxConnectionConstraint(new mxPoint(1,.25),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(1,.75),true), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true)];
function mxShapeEREntityExt(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeEREntityExt, mxShape);
mxShapeEREntityExt.prototype.paintVertexShape = function(c, x, y, w, h) {
    var mainText = mxUtils.getValue(this.style, "buttonText", "Entity");
    var attributes = mxUtils.getValue(this.style, "subText", "+ attribute 1,+ attribute 2,+ attribute 3").toString().split(",");
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#666666");
    var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "17");
    var mainColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#008cff");
    var attrColor = mxUtils.getValue(this.style, "fillColor2", "#ffffff");
    var maxTextWidth = 0;
    c.translate(x, y);
    var rSize = 10;
    var barY = fontSize * 1.25;
    for (var i = 0; i < attributes.length; i++) {
        var currWidth = mxUtils.getSizeForString(attributes[i], fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
        if (currWidth > maxTextWidth)
            maxTextWidth = currWidth
    }
    w = Math.max(w, 2 * rSize, maxTextWidth + rSize);
    h = Math.max(h, 2 * rSize, (attributes.length + 1) * barY);
    this.background(c, x, y, w, h, rSize);
    c.setShadow(false);
    this.shapes(c, x, y, w, h, fontSize, mainColor, attrColor, rSize, barY);
    this.mainText(c, x, y, w, h, mainText, fontSize, attrColor);
    this.attrText(c, x, y, w, h, attributes, fontSize, strokeColor, barY, rSize)
}
;
mxShapeEREntityExt.prototype.background = function(c, x, y, w, h, rSize) {
    var buttonStyle = mxUtils.getValue(this.style, "buttonStyle", "round").toString();
    c.begin();
    if (buttonStyle === "round") {
        c.moveTo(0, rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
        c.lineTo(w - rSize, 0);
        c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
        c.lineTo(w, h - rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
        c.lineTo(rSize, h);
        c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize)
    } else if (buttonStyle === "rect") {
        c.moveTo(0, 0);
        c.lineTo(w, 0);
        c.lineTo(w, h);
        c.lineTo(0, h)
    }
    c.close();
    c.fillAndStroke()
}
;
mxShapeEREntityExt.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor) {
    c.begin();
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    c.text(w * .5, fontSize * .5, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxShapeEREntityExt.prototype.shapes = function(c, x, y, w, h, fontSize, mainColor, attrColor, rSize, barY) {
    var buttonStyle = mxUtils.getValue(this.style, "buttonStyle", "round").toString();
    if (buttonStyle === "round") {
        c.begin();
        c.moveTo(0, rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
        c.lineTo(w - rSize, 0);
        c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
        c.lineTo(w, barY);
        c.lineTo(0, barY);
        c.close();
        c.fill();
        c.setFillColor(attrColor);
        c.begin();
        c.moveTo(w, barY);
        c.lineTo(w, h - rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
        c.lineTo(rSize, h);
        c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
        c.lineTo(0, barY);
        c.close();
        c.fill()
    } else if (buttonStyle === "rect") {
        c.begin();
        c.moveTo(0, 0);
        c.lineTo(w, 0);
        c.lineTo(w, barY);
        c.lineTo(0, barY);
        c.close();
        c.fill();
        c.setFillColor(attrColor);
        c.begin();
        c.moveTo(0, barY);
        c.lineTo(w, barY);
        c.lineTo(w, h);
        c.lineTo(0, h);
        c.close();
        c.fill()
    }
    c.begin();
    if (buttonStyle === "round") {
        c.moveTo(0, rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
        c.lineTo(w - rSize, 0);
        c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
        c.lineTo(w, h - rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
        c.lineTo(rSize, h);
        c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize)
    } else if (buttonStyle === "rect") {
        c.moveTo(0, 0);
        c.lineTo(w, 0);
        c.lineTo(w, h);
        c.lineTo(0, h)
    }
    c.close();
    c.stroke()
}
;
mxShapeEREntityExt.prototype.attrText = function(c, x, y, w, h, attributes, fontSize, fontColor, barY, rSize) {
    for (var i = 0; i < attributes.length; i++) {
        c.begin();
        c.setFontSize(fontSize);
        c.setFontColor(fontColor);
        c.text(rSize * .5, (i + 1.5) * barY, 0, 0, attributes[i], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
    }
}
;
mxCellRenderer.registerShape("mxgraph.er.entityExt", mxShapeEREntityExt);
mxShapeEREntityExt.prototype.constraints = [new mxConnectionConstraint(new mxPoint(.25,0),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.75,0),true), new mxConnectionConstraint(new mxPoint(0,.25),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(0,.75),true), new mxConnectionConstraint(new mxPoint(1,.25),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(1,.75),true), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true)];
function mxShapeERAttribute(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeERAttribute, mxShape);
mxShapeERAttribute.prototype.paintVertexShape = function(c, x, y, w, h) {
    var mainText = mxUtils.getValue(this.style, "buttonText", "Entity");
    var fontColor = mxUtils.getValue(this.style, "textColor", "#666666");
    var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "17");
    c.translate(x, y);
    var rSize = 10;
    w = Math.max(w, 2 * rSize);
    h = Math.max(h, 2 * rSize);
    this.background(c, x, y, w, h, rSize, fontColor);
    c.setShadow(false);
    this.mainText(c, x, y, w, h, mainText, fontSize, fontColor)
}
;
mxShapeERAttribute.prototype.background = function(c, x, y, w, h, rSize, fontColor) {
    var buttonStyle = mxUtils.getValue(this.style, "buttonStyle", "simple").toString();
    if (buttonStyle === "simple") {
        c.begin();
        c.ellipse(0, 0, w, h);
        c.fillAndStroke()
    } else if (buttonStyle === "dblFrame") {
        var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#666666");
        c.setFillColor(fillColor);
        c.begin();
        c.ellipse(0, 0, w, h);
        c.fillAndStroke();
        rSize = Math.min(w, h);
        c.begin();
        c.ellipse(rSize * .1, rSize * .1, w - rSize * .2, h - rSize * .2);
        c.stroke()
    }
}
;
mxShapeERAttribute.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor) {
    c.begin();
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    c.text(w * .5, h * .5, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape("mxgraph.er.attribute", mxShapeERAttribute);
mxShapeERAttribute.prototype.constraints = [new mxConnectionConstraint(new mxPoint(.144,.144),false), new mxConnectionConstraint(new mxPoint(.856,.144),false), new mxConnectionConstraint(new mxPoint(.856,.856),false), new mxConnectionConstraint(new mxPoint(.144,.856),false), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.5,1),true)];
function mxShapeERHas(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeERHas, mxShape);
mxShapeERHas.prototype.paintVertexShape = function(c, x, y, w, h) {
    var mainText = mxUtils.getValue(this.style, "buttonText", "Entity");
    var fontColor = mxUtils.getValue(this.style, "textColor", "#666666");
    var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "17");
    c.translate(x, y);
    var rSize = 10;
    w = Math.max(w, 2 * rSize);
    h = Math.max(h, 2 * rSize);
    this.background(c, x, y, w, h, rSize, fontColor);
    c.setShadow(false);
    this.mainText(c, x, y, w, h, mainText, fontSize, fontColor)
}
;
mxShapeERHas.prototype.background = function(c, x, y, w, h, rSize, fontColor) {
    var buttonStyle = mxUtils.getValue(this.style, "buttonStyle", "rhombus").toString();
    if (buttonStyle === "rhombus") {
        c.begin();
        c.moveTo(0, h * .5);
        c.lineTo(w * .5, 0);
        c.lineTo(w, h * .5);
        c.lineTo(w * .5, h);
        c.close();
        c.fillAndStroke()
    } else if (buttonStyle === "dblFrame") {
        var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#666666");
        c.setFillColor(fillColor);
        c.begin();
        c.moveTo(0, h * .5);
        c.lineTo(w * .5, 0);
        c.lineTo(w, h * .5);
        c.lineTo(w * .5, h);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .1, h * .5);
        c.lineTo(w * .5, h * .1);
        c.lineTo(w * .9, h * .5);
        c.lineTo(w * .5, h * .9);
        c.close();
        c.stroke()
    }
}
;
mxShapeERHas.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor) {
    c.begin();
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    c.text(w * .5, h * .5, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape("mxgraph.er.has", mxShapeERHas);
mxShapeERHas.prototype.constraints = [new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(.25,.25),false), new mxConnectionConstraint(new mxPoint(.25,.75),false), new mxConnectionConstraint(new mxPoint(.75,.25),false), new mxConnectionConstraint(new mxPoint(.75,.75),false)];
function mxShapeERCloud(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeERCloud, mxShape);
mxShapeERCloud.prototype.paintVertexShape = function(c, x, y, w, h) {
    var mainText = mxUtils.getValue(this.style, "buttonText", "Entity");
    var fontColor = mxUtils.getValue(this.style, "textColor", "#666666");
    var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "17");
    c.translate(x, y);
    var rSize = 10;
    w = Math.max(w, 2 * rSize);
    h = Math.max(h, 2 * rSize);
    this.background(c, x, y, w, h, rSize, fontColor);
    c.setShadow(false);
    this.mainText(c, x, y, w, h, mainText, fontSize, fontColor)
}
;
mxShapeERCloud.prototype.background = function(c, x, y, w, h, rSize, fontColor) {
    c.begin();
    c.moveTo(.25 * w, .25 * h);
    c.curveTo(.05 * w, .25 * h, 0, .5 * h, .16 * w, .55 * h);
    c.curveTo(0, .66 * h, .18 * w, .9 * h, .31 * w, .8 * h);
    c.curveTo(.4 * w, h, .7 * w, h, .8 * w, .8 * h);
    c.curveTo(w, .8 * h, w, .6 * h, .875 * w, .5 * h);
    c.curveTo(w, .3 * h, .8 * w, .1 * h, .625 * w, .2 * h);
    c.curveTo(.5 * w, .05 * h, .3 * w, .05 * h, .25 * w, .25 * h);
    c.fillAndStroke()
}
;
mxShapeERCloud.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor) {
    c.begin();
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    c.text(w * .5, h * .5, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape("mxgraph.er.cloud", mxShapeERCloud);
mxShapeERCloud.prototype.constraints = [new mxConnectionConstraint(new mxPoint(.08,.5),false), new mxConnectionConstraint(new mxPoint(.9,.5),false), new mxConnectionConstraint(new mxPoint(.5,.1),false), new mxConnectionConstraint(new mxPoint(.5,.92),false), new mxConnectionConstraint(new mxPoint(.24,.24),false), new mxConnectionConstraint(new mxPoint(.22,.8),false), new mxConnectionConstraint(new mxPoint(.81,.2),false), new mxConnectionConstraint(new mxPoint(.78,.78),false)];
function mxShapeERHierarchy(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeERHierarchy, mxShape);
mxShapeERHierarchy.prototype.paintVertexShape = function(c, x, y, w, h) {
    var mainText = mxUtils.getValue(this.style, "buttonText", "main").toString().split(",");
    var subText = mxUtils.getValue(this.style, "subText", "sub").toString().split(",");
    var fontColor = mxUtils.getValue(this.style, "textColor", "#666666");
    var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "17");
    c.translate(x, y);
    var rSize = 10;
    w = Math.max(w, 2 * rSize);
    h = Math.max(h, 2 * rSize);
    this.background(c, x, y, w, h, rSize, fontColor);
    c.setShadow(false);
    this.shapeText(c, x, y, w, h, mainText, subText, fontSize, fontColor)
}
;
mxShapeERHierarchy.prototype.background = function(c, x, y, w, h, rSize, fontColor) {
    var buttonStyle = mxUtils.getValue(this.style, "buttonStyle", "round").toString();
    if (buttonStyle === "round") {
        c.begin();
        c.moveTo(0, rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
        c.lineTo(w - rSize, 0);
        c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
        c.lineTo(w, h - rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
        c.lineTo(rSize, h);
        c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
        c.close();
        c.fillAndStroke()
    } else if (buttonStyle === "rect") {
        c.begin();
        c.moveTo(0, 0);
        c.lineTo(w, 0);
        c.lineTo(w, h);
        c.lineTo(0, h);
        c.close();
        c.fillAndStroke()
    } else if (buttonStyle === "dblFrame") {
        var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#666666");
        c.setFillColor(fillColor);
        c.begin();
        c.moveTo(0, 0);
        c.lineTo(w, 0);
        c.lineTo(w, h);
        c.lineTo(0, h);
        c.close();
        c.fillAndStroke();
        rSize = Math.min(w, h);
        c.begin();
        c.moveTo(rSize * .1, rSize * .1);
        c.lineTo(w - rSize * .1, rSize * .1);
        c.lineTo(w - rSize * .1, h - rSize * .1);
        c.lineTo(rSize * .1, h - rSize * .1);
        c.close();
        c.stroke()
    }
    var trX = 0;
    var trY = 0;
    if (buttonStyle === "round") {
        trX = w * .5;
        trY = rSize;
        c.translate(trX, trY);
        w = w * .5 - rSize;
        h = h - 2 * rSize;
        c.begin();
        c.moveTo(0, rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
        c.lineTo(w - rSize, 0);
        c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
        c.lineTo(w, h - rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
        c.lineTo(rSize, h);
        c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
        c.close();
        c.fillAndStroke()
    } else if (buttonStyle === "rect") {
        trX = w * .5;
        trY = rSize;
        c.translate(trX, trY);
        w = w * .5 - rSize;
        h = h - 2 * rSize;
        c.begin();
        c.moveTo(0, 0);
        c.lineTo(w, 0);
        c.lineTo(w, h);
        c.lineTo(0, h);
        c.close();
        c.fillAndStroke()
    } else if (buttonStyle === "dblFrame") {
        trX = w * .5;
        trY = rSize * .15;
        c.translate(trX, trY);
        w = w * .5 - rSize * .15;
        h = h - rSize * .3;
        var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#666666");
        c.setFillColor(fillColor);
        c.begin();
        c.moveTo(0, 0);
        c.lineTo(w, 0);
        c.lineTo(w, h);
        c.lineTo(0, h);
        c.close();
        c.fillAndStroke();
        rSize = Math.min(w, h);
        c.begin();
        c.moveTo(rSize * .1, rSize * .1);
        c.lineTo(w - rSize * .1, rSize * .1);
        c.lineTo(w - rSize * .1, h - rSize * .1);
        c.lineTo(rSize * .1, h - rSize * .1);
        c.close();
        c.stroke()
    }
    c.translate(-trX, -trY)
}
;
mxShapeERHierarchy.prototype.shapeText = function(c, x, y, w, h, text, subText, fontSize, fontColor, rSize) {
    c.begin();
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    c.text(w * .25, (h - fontSize) * .5, 0, 0, text[0], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .25, (h + fontSize) * .5, 0, 0, text[1], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .7, (h - fontSize) * .5, 0, 0, subText[0], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .7, (h + fontSize) * .5, 0, 0, subText[1], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape("mxgraph.er.hierarchy", mxShapeERHierarchy);
mxShapeERHierarchy.prototype.constraints = [new mxConnectionConstraint(new mxPoint(.25,0),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.75,0),true), new mxConnectionConstraint(new mxPoint(0,.25),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(0,.75),true), new mxConnectionConstraint(new mxPoint(1,.25),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(1,.75),true), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true)];
function mxShapeERNote(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeERNote, mxShape);
mxShapeERNote.prototype.paintVertexShape = function(c, x, y, w, h) {
    var mainText = mxUtils.getValue(this.style, "buttonText", "Entity");
    var fontColor = mxUtils.getValue(this.style, "textColor", "#666666");
    var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "17");
    var backColor = mxUtils.getValue(this.style, "fillColor2", "#ffffff");
    c.translate(x, y);
    var flipSize = 20;
    w = Math.max(w, flipSize * 2);
    h = Math.max(h, flipSize * 2);
    this.background(c, x, y, w, h, flipSize);
    c.setShadow(false);
    this.flipShape(c, x, y, w, h, flipSize, backColor);
    this.mainText(c, x, y, w, h, mainText, fontSize, fontColor)
}
;
mxShapeERNote.prototype.background = function(c, x, y, w, h, flipSize) {
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w - flipSize, 0);
    c.lineTo(w, flipSize);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeERNote.prototype.flipShape = function(c, x, y, w, h, flipSize, backColor) {
    c.setLineJoin("round");
    c.setFillColor(backColor);
    c.begin();
    c.moveTo(w - flipSize, 0);
    c.lineTo(w, flipSize);
    c.lineTo(w - flipSize, flipSize);
    c.close();
    c.fillAndStroke()
}
;
mxShapeERNote.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor) {
    c.begin();
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    c.text(w * .5, h * .5, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape("mxgraph.er.note", mxShapeERNote);
mxShapeERNote.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0,0),true), new mxConnectionConstraint(new mxPoint(0,1),true), new mxConnectionConstraint(new mxPoint(1,1),true), new mxConnectionConstraint(new mxPoint(.25,0),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.75,0),true), new mxConnectionConstraint(new mxPoint(0,.25),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(0,.75),true), new mxConnectionConstraint(new mxPoint(1,.25),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(1,.75),true), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true)];
function mxShapeERChen(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeERChen, mxShape);
mxShapeERChen.prototype.paintVertexShape = function(c, x, y, w, h) {
    var fontColor = mxUtils.getValue(this.style, "textColor", "#666666");
    var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "17");
    c.translate(x, y);
    var flipSize = 20;
    w = Math.max(w, flipSize * 2);
    h = Math.max(h, flipSize * 2);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h, fontSize, fontColor)
}
;
mxShapeERChen.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeERChen.prototype.foreground = function(c, x, y, w, h, fontSize, fontColor) {
    c.begin();
    c.moveTo(0, h * .25);
    c.lineTo(w, h * .25);
    c.moveTo(0, h * .5);
    c.lineTo(w, h * .5);
    c.moveTo(0, h * .75);
    c.lineTo(w, h * .75);
    c.moveTo(w * .25, h * .5);
    c.lineTo(w * .25, h);
    c.moveTo(w * .5, h * .25);
    c.lineTo(w * .5, h);
    c.moveTo(w * .75, h * .5);
    c.lineTo(w * .75, h);
    c.stroke();
    c.begin();
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    c.text(w * .5, h * .125, 0, 0, "ERD Peter Chen's Notation", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setFontSize(fontSize * .85);
    c.text(w * .25, h * .375, 0, 0, "Cardinality", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .75, h * .375, 0, 0, "Optionality", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setFontSize(fontSize * .7);
    c.text(w * .125, h * .625, 0, 0, "1", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .375, h * .625, 0, 0, "One", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .625, h * .625, 0, 0, "0", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .875, h * .625, 0, 0, "Optional", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .125, h * .875, 0, 0, "N", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .375, h * .875, 0, 0, "Many", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .625, h * .875, 0, 0, "1", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .875, h * .875, 0, 0, "Mandatory", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape("mxgraph.er.chens", mxShapeERChen);
mxShapeERChen.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0,0),true), new mxConnectionConstraint(new mxPoint(1,0),true), new mxConnectionConstraint(new mxPoint(0,1),true), new mxConnectionConstraint(new mxPoint(1,1),true), new mxConnectionConstraint(new mxPoint(.25,0),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.75,0),true), new mxConnectionConstraint(new mxPoint(0,.25),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(0,.75),true), new mxConnectionConstraint(new mxPoint(1,.25),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(1,.75),true), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true)];
function mxShapeERBachman(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeERBachman, mxShape);
mxShapeERBachman.prototype.paintVertexShape = function(c, x, y, w, h) {
    var fontColor = mxUtils.getValue(this.style, "textColor", "#666666");
    var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "17");
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h, fontSize, fontColor)
}
;
mxShapeERBachman.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeERBachman.prototype.foreground = function(c, x, y, w, h, fontSize, fontColor) {
    c.begin();
    c.moveTo(0, h * .125);
    c.lineTo(w, h * .125);
    c.moveTo(0, h * .25);
    c.lineTo(w, h * .25);
    c.moveTo(0, h * .375);
    c.lineTo(w, h * .375);
    c.moveTo(0, h * .5);
    c.lineTo(w, h * .5);
    c.moveTo(0, h * .625);
    c.lineTo(w, h * .625);
    c.moveTo(0, h * .75);
    c.lineTo(w, h * .75);
    c.moveTo(0, h * .875);
    c.lineTo(w, h * .875);
    c.moveTo(w * .5, h * .125);
    c.lineTo(w * .5, h);
    c.stroke();
    c.begin();
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    c.text(w * .5, h * .0625, 0, 0, "ERD Bachman's Notation", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setFontSize(fontSize * .85);
    c.text(w * .52, h * .1875, 0, 0, "Relationship", mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .52, h * .3125, 0, 0, "Cardinality (One)", mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .52, h * .4375, 0, 0, "Cardinality (Many)", mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .52, h * .5625, 0, 0, "Mandatory, One", mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .52, h * .6875, 0, 0, "Mandatory, Many", mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .52, h * .8125, 0, 0, "Optional, One", mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .52, h * .9375, 0, 0, "Optional, Many", mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    var textWidth = mxUtils.getSizeForString("has/forms", fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
    c.begin();
    c.moveTo(w * .04, h * .1875);
    c.lineTo(w * .25 - textWidth * .5, h * .1875);
    c.moveTo(w * .25 + textWidth * .5, h * .1875);
    c.lineTo(w * .46, h * .1875);
    c.text(w * .25, h * .1875, 0, 0, "has/forms", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, true, 0, 0);
    c.moveTo(w * .04, h * .3125);
    c.lineTo(w * .46, h * .3125);
    c.moveTo(w * .04, h * .4375);
    c.lineTo(w * .46, h * .4375);
    c.moveTo(w * .46, h * .405);
    c.lineTo(w * .4, h * .4375);
    c.lineTo(w * .46, h * .47);
    c.moveTo(w * .04, h * .5625);
    c.lineTo(w * .46, h * .5625);
    c.moveTo(w * .38, h * .53);
    c.lineTo(w * .38, h * .595);
    c.moveTo(w * .04, h * .6875);
    c.lineTo(w * .46, h * .6875);
    c.moveTo(w * .46, h * .655);
    c.lineTo(w * .4, h * .6875);
    c.lineTo(w * .46, h * .72);
    c.moveTo(w * .38, h * .655);
    c.lineTo(w * .38, h * .72);
    c.moveTo(w * .04, h * .8125);
    c.lineTo(w * .46, h * .8125);
    c.moveTo(w * .04, h * .9375);
    c.lineTo(w * .46, h * .9375);
    c.moveTo(w * .46, h * .905);
    c.lineTo(w * .4, h * .9375);
    c.lineTo(w * .46, h * .97);
    c.stroke();
    var ellSize = h / 15;
    c.begin();
    c.ellipse(w * .46 - ellSize, h * .8125 - ellSize * .5, ellSize, ellSize);
    c.fillAndStroke();
    c.begin();
    c.ellipse(w * .4 - ellSize, h * .9375 - ellSize * .5, ellSize, ellSize);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape("mxgraph.er.bachmans", mxShapeERBachman);
mxShapeERBachman.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0,0),true), new mxConnectionConstraint(new mxPoint(1,0),true), new mxConnectionConstraint(new mxPoint(0,1),true), new mxConnectionConstraint(new mxPoint(1,1),true), new mxConnectionConstraint(new mxPoint(.25,0),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.75,0),true), new mxConnectionConstraint(new mxPoint(0,.25),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(0,.75),true), new mxConnectionConstraint(new mxPoint(1,.25),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(1,.75),true), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true)];
function mxShapeERInfEng(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeERInfEng, mxShape);
mxShapeERInfEng.prototype.paintVertexShape = function(c, x, y, w, h) {
    var fontColor = mxUtils.getValue(this.style, "textColor", "#666666");
    var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "17");
    c.translate(x, y);
    w = Math.max(w, h / 1.5);
    h = Math.max(h, fontSize * 5);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h, fontSize, fontColor)
}
;
mxShapeERInfEng.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeERInfEng.prototype.foreground = function(c, x, y, w, h, fontSize, fontColor) {
    c.begin();
    c.moveTo(0, h * .2);
    c.lineTo(w, h * .2);
    c.moveTo(0, h * .4);
    c.lineTo(w, h * .4);
    c.moveTo(0, h * .6);
    c.lineTo(w, h * .6);
    c.moveTo(0, h * .8);
    c.lineTo(w, h * .8);
    c.moveTo(w * .5, h * .2);
    c.lineTo(w * .5, h);
    c.stroke();
    c.begin();
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    c.text(w * .5, h * .1, 0, 0, "ERD Information Engineering Notation", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setFontSize(fontSize * .85);
    c.text(w * .52, h * .3, 0, 0, "Zero or one", mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .52, h * .5, 0, 0, "One only", mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .52, h * .7, 0, 0, "Zero or more", mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .52, h * .9, 0, 0, "One or more", mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    var ellSize = h / 12;
    c.begin();
    c.moveTo(w * .04, h * .3);
    c.lineTo(w * .46, h * .3);
    c.moveTo(w * .46 - ellSize, h * .25);
    c.lineTo(w * .46 - ellSize, h * .35);
    c.moveTo(w * .04, h * .5);
    c.lineTo(w * .46, h * .5);
    c.moveTo(w * .46 - ellSize * 2, h * .45);
    c.lineTo(w * .46 - ellSize * 2, h * .55);
    c.moveTo(w * .46 - ellSize * 2.5, h * .45);
    c.lineTo(w * .46 - ellSize * 2.5, h * .55);
    c.moveTo(w * .04, h * .7);
    c.lineTo(w * .46, h * .7);
    c.moveTo(w * .46, h * .65);
    c.lineTo(w * .46 - ellSize * 2, h * .7);
    c.lineTo(w * .46, h * .75);
    c.stroke();
    c.moveTo(w * .04, h * .9);
    c.lineTo(w * .46, h * .9);
    c.moveTo(w * .46, h * .85);
    c.lineTo(w * .46 - ellSize * 2, h * .9);
    c.lineTo(w * .46, h * .95);
    c.moveTo(w * .46 - ellSize * 2.5, h * .85);
    c.lineTo(w * .46 - ellSize * 2.5, h * .95);
    c.stroke();
    c.begin();
    c.ellipse(w * .46 - ellSize * 3, h * .3 - ellSize * .5, ellSize, ellSize);
    c.fillAndStroke();
    c.begin();
    c.ellipse(w * .46 - ellSize * 3, h * .7 - ellSize * .5, ellSize, ellSize);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape("mxgraph.er.ie", mxShapeERInfEng);
mxShapeERInfEng.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0,0),true), new mxConnectionConstraint(new mxPoint(1,0),true), new mxConnectionConstraint(new mxPoint(0,1),true), new mxConnectionConstraint(new mxPoint(1,1),true), new mxConnectionConstraint(new mxPoint(.25,0),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.75,0),true), new mxConnectionConstraint(new mxPoint(0,.25),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(0,.75),true), new mxConnectionConstraint(new mxPoint(1,.25),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(1,.75),true), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true)];
mxMarker.addMarker("ERone", function(c, shape, type, pe, unitX, unitY, size, source, sw, filled) {
    var nx = unitX * (size + sw + 1);
    var ny = unitY * (size + sw + 1);
    return function() {
        c.begin();
        c.moveTo(pe.x - nx / 2 - ny / 2, pe.y - ny / 2 + nx / 2);
        c.lineTo(pe.x - nx / 2 + ny / 2, pe.y - ny / 2 - nx / 2);
        c.stroke()
    }
});
mxMarker.addMarker("ERmandOne", function(c, shape, type, pe, unitX, unitY, size, source, sw, filled) {
    var nx = unitX * (size + sw + 1);
    var ny = unitY * (size + sw + 1);
    return function() {
        c.begin();
        c.moveTo(pe.x - nx / 2 - ny / 2, pe.y - ny / 2 + nx / 2);
        c.lineTo(pe.x - nx / 2 + ny / 2, pe.y - ny / 2 - nx / 2);
        c.moveTo(pe.x - nx - ny / 2, pe.y - ny + nx / 2);
        c.lineTo(pe.x - nx + ny / 2, pe.y - ny - nx / 2);
        c.stroke()
    }
});
mxMarker.addMarker("ERmany", function(c, shape, type, pe, unitX, unitY, size, source, sw, filled) {
    var nx = unitX * (size + sw + 1);
    var ny = unitY * (size + sw + 1);
    return function() {
        c.begin();
        c.moveTo(pe.x + ny / 2, pe.y - nx / 2);
        c.lineTo(pe.x - nx, pe.y - ny);
        c.lineTo(pe.x - ny / 2, pe.y + nx / 2);
        c.stroke()
    }
});
mxMarker.addMarker("ERoneToMany", function(c, shape, type, pe, unitX, unitY, size, source, sw, filled) {
    var nx = unitX * (size + sw + 1);
    var ny = unitY * (size + sw + 1);
    return function() {
        c.begin();
        c.moveTo(pe.x - nx - ny / 2, pe.y - ny + nx / 2);
        c.lineTo(pe.x - nx + ny / 2, pe.y - ny - nx / 2);
        c.moveTo(pe.x + ny / 2, pe.y - nx / 2);
        c.lineTo(pe.x - nx, pe.y - ny);
        c.lineTo(pe.x - ny / 2, pe.y + nx / 2);
        c.stroke()
    }
});
mxMarker.addMarker("ERzeroToMany", function(c, shape, type, pe, unitX, unitY, size, source, sw, filled) {
    var nx = unitX * (size + sw + 1);
    var ny = unitY * (size + sw + 1);
    var a = size / 2;
    return function() {
        c.begin();
        c.ellipse(pe.x - 1.5 * nx - a, pe.y - 1.5 * ny - a, 2 * a, 2 * a);
        if (filled) {
            var oldColor = mxUtils.getValue(shape.style, mxConstants.STYLE_STROKECOLOR, "#666666");
            c.setFillColor("#ffffff");
            c.fillAndStroke();
            c.setFillColor(oldColor)
        } else
            c.stroke();
        c.begin();
        c.moveTo(pe.x + ny / 2, pe.y - nx / 2);
        c.lineTo(pe.x - nx, pe.y - ny);
        c.lineTo(pe.x - ny / 2, pe.y + nx / 2);
        c.stroke()
    }
});
mxMarker.addMarker("ERzeroToOne", function(c, shape, type, pe, unitX, unitY, size, source, sw, filled) {
    var nx = unitX * (size + sw + 1);
    var ny = unitY * (size + sw + 1);
    var a = size / 2;
    return function() {
        c.begin();
        c.ellipse(pe.x - 1.5 * nx - a, pe.y - 1.5 * ny - a, 2 * a, 2 * a);
        if (filled) {
            var oldColor = mxUtils.getValue(shape.style, mxConstants.STYLE_STROKECOLOR, "#666666");
            c.setFillColor("#ffffff");
            c.fillAndStroke();
            c.setFillColor(oldColor)
        } else
            c.stroke();
        c.begin();
        c.moveTo(pe.x - nx / 2 - ny / 2, pe.y - ny / 2 + nx / 2);
        c.lineTo(pe.x - nx / 2 + ny / 2, pe.y - ny / 2 - nx / 2);
        c.stroke()
    }
});
function mxShapeERRRect(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeERRRect, mxShape);
mxShapeERRRect.prototype.cst = {
    RRECT: "mxgraph.er.rrect",
    R_SIZE: "rSize"
};
mxShapeERRRect.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeERRRect.prototype.cst.R_SIZE, "10"));
    c.roundrect(0, 0, w, h, rSize);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeERRRect.prototype.cst.RRECT, mxShapeERRRect);
mxShapeERRRect.prototype.constraints = [new mxConnectionConstraint(new mxPoint(.25,0),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.75,0),true), new mxConnectionConstraint(new mxPoint(0,.25),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(0,.75),true), new mxConnectionConstraint(new mxPoint(1,.25),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(1,.75),true), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true)];
function mxShapeERAnchor(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds
}
mxUtils.extend(mxShapeERAnchor, mxShape);
mxShapeERAnchor.prototype.cst = {
    ANCHOR: "mxgraph.er.anchor"
};
mxShapeERAnchor.prototype.paintVertexShape = function(c, x, y, w, h) {}
;
mxCellRenderer.registerShape(mxShapeERAnchor.prototype.cst.ANCHOR, mxShapeERAnchor);
var mxIOS7C = {
    MAIN_TEXT: "mainText",
    SUB_TEXT: "subText",
    TEXT_COLOR: "textColor",
    TEXT_SIZE: "textSize",
    BAR_POS: "barPos",
    BUTTON_TEXT: "buttonText",
    BUTTON_STATE: "buttonState",
    SELECTED: "+",
    STATE_ON: "on",
    STATE_OFF: "off",
    GRID_SIZE: "gridSize",
    SHAPE_IOS7_APP_BAR: "mxgraph.ios7ui.appBar",
    SHAPE_IOS7_ON_OFF_BUTTON: "mxgraph.ios7ui.onOffButton",
    SHAPE_IOS7_SLIDER: "mxgraph.ios7ui.slider",
    SHAPE_IOS7_DOWNLOAD_BAR: "mxgraph.ios7ui.downloadBar",
    SHAPE_IOS7_ICON: "mxgraph.ios7ui.icon",
    SHAPE_IOS7_HOR_BUTTON_BAR: "mxgraph.ios7ui.horButtonBar",
    SHAPE_IOS7_PAGE_CONTROL: "mxgraph.ios7ui.pageControl",
    SHAPE_IOS7_EXPAND: "mxgraph.ios7ui.expand",
    SHAPE_IOS7_ICON_GRID: "mxgraph.ios7ui.iconGrid",
    SHAPE_IOS7_PHONE: "mxgraph.ios7ui.phone",
    SHAPE_IOS7_SEARCH_BOX: "mxgraph.ios7ui.searchBox",
    SHAPE_IOS7_URL: "mxgraph.ios7ui.url",
    SHAPE_IOS7_ACTION_DIALOG: "mxgraph.ios7ui.actionDialog",
    STYLE_FILLCOLOR2: "fillColor2",
    STYLE_FILLCOLOR3: "fillColor3",
    STYLE_TEXTCOLOR: "textColor",
    STYLE_TEXTCOLOR2: "textColor2",
    STYLE_STROKECOLOR2: "strokeColor2",
    STYLE_STROKECOLOR3: "strokeColor3",
    STYLE_TEXTSIZE: "textSize"
};
function mxShapeIOS7AppBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeIOS7AppBar, mxShape);
mxShapeIOS7AppBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeIOS7AppBar.prototype.background = function(c, x, y, w, h) {
    c.rect(0, 0, w, h);
    c.fill()
}
;
mxShapeIOS7AppBar.prototype.foreground = function(c, x, y, w, h) {
    c.setFillColor(mxUtils.getValue(this.style, mxIOS7C.STYLE_FILLCOLOR2, "#222222"));
    c.ellipse(5, h * .5 - 1.5, 3, 3);
    c.fill();
    c.ellipse(9, h * .5 - 1.5, 3, 3);
    c.fill();
    c.ellipse(13, h * .5 - 1.5, 3, 3);
    c.fill();
    c.ellipse(17, h * .5 - 1.5, 3, 3);
    c.fill();
    c.ellipse(21, h * .5 - 1.5, 3, 3);
    c.fill();
    c.ellipse(54, h * .5 + 2, 2, 2);
    c.fillAndStroke();
    c.setStrokeWidth(2);
    c.begin();
    c.moveTo(52, h * .5 + 1);
    c.arcTo(3.5, 3.5, 0, 0, 1, 58, h * .5 + 1);
    c.stroke();
    c.begin();
    c.moveTo(50, h * .5 - 1);
    c.arcTo(6, 6, 0, 0, 1, 60, h * .5 - 1);
    c.stroke();
    c.begin();
    c.moveTo(w - 19, h * .5 - 2);
    c.lineTo(w - 6, h * .5 - 2);
    c.lineTo(w - 6, h * .5 + 2);
    c.lineTo(w - 19, h * .5 + 2);
    c.close();
    c.fill();
    c.setStrokeWidth(1);
    c.begin();
    c.moveTo(w - 44, h * .5 - 2.5);
    c.lineTo(w - 36, h * .5 + 2.5);
    c.lineTo(w - 40, h * .5 + 5);
    c.lineTo(w - 40, h * .5 - 5);
    c.lineTo(w - 36, h * .5 - 2.5);
    c.lineTo(w - 44, h * .5 + 2.5);
    c.stroke();
    c.begin();
    c.moveTo(w - 20, h * .5 - 3);
    c.lineTo(w - 5, h * .5 - 3);
    c.lineTo(w - 5, h * .5 - 1);
    c.lineTo(w - 3.5, h * .5 - 1);
    c.lineTo(w - 3.5, h * .5 + 1);
    c.lineTo(w - 5, h * .5 + 1);
    c.lineTo(w - 5, h * .5 + 3);
    c.lineTo(w - 20, h * .5 + 3);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxIOS7C.SHAPE_IOS7_APP_BAR, mxShapeIOS7AppBar);
function mxShapeIOS7OnOffButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeIOS7OnOffButton, mxShape);
mxShapeIOS7OnOffButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    w = Math.max(w, 2 * h);
    var state = mxUtils.getValue(this.style, mxIOS7C.BUTTON_STATE, mxIOS7C.STATE_ON);
    this.background(c, x, y, w, h, state);
    c.setShadow(false);
    this.foreground(c, x, y, w, h, state)
}
;
mxShapeIOS7OnOffButton.prototype.background = function(c, x, y, w, h, state) {
    if (state === mxIOS7C.STATE_ON) {
        c.roundrect(0, 0, w, h, h * .5, h * .5);
        c.fillAndStroke()
    } else if (state === mxIOS7C.STATE_OFF) {
        c.setStrokeColor(mxUtils.getValue(this.style, mxIOS7C.STYLE_STROKECOLOR2, "#aaaaaa"));
        c.setFillColor(mxUtils.getValue(this.style, mxIOS7C.STYLE_FILLCOLOR2, "#ffffff"));
        c.roundrect(0, 0, w, h, h * .5, h * .5);
        c.fillAndStroke()
    }
}
;
mxShapeIOS7OnOffButton.prototype.foreground = function(c, x, y, w, h, state) {
    c.setFillColor("#ffffff");
    if (state === mxIOS7C.STATE_ON) {
        c.ellipse(w - h + 1, 1, h - 2, h - 2);
        c.fill()
    } else {
        c.ellipse(0, 0, h, h);
        c.stroke()
    }
}
;
mxCellRenderer.registerShape(mxIOS7C.SHAPE_IOS7_ON_OFF_BUTTON, mxShapeIOS7OnOffButton);
function mxShapeIOS7Slider(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.barPos = 80
}
mxUtils.extend(mxShapeIOS7Slider, mxShape);
mxShapeIOS7Slider.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxShapeIOS7Slider.prototype.foreground = function(c, w, h) {
    c.setStrokeWidth(2);
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(w, h * .5);
    c.stroke();
    var barPos = mxUtils.getValue(this.style, mxIOS7C.BAR_POS, "80");
    barPos = Math.min(barPos, 100);
    barPos = Math.max(barPos, 0);
    var deadzone = 0;
    var virRange = w - 2 * deadzone;
    var truePos = deadzone + virRange * barPos / 100;
    c.setStrokeColor(mxUtils.getValue(this.style, mxIOS7C.STYLE_STROKECOLOR2, "#a0a0a0"));
    c.ellipse(truePos - 5, h * .5 - 5, 10, 10);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxIOS7C.SHAPE_IOS7_SLIDER, mxShapeIOS7Slider);
Graph.handleFactory[mxIOS7C.SHAPE_IOS7_SLIDER] = function(state) {
    var handles = [Graph.createHandle(state, ["barPos"], function(bounds) {
        var barPos = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, "barPos", this.barPos))));
        return new mxPoint(bounds.x + barPos / 100 * bounds.width,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["barPos"] = Math.round(1E3 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 1E3
    })];
    return handles
}
;
function mxShapeIOS7DownloadBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.barPos = 80
}
mxUtils.extend(mxShapeIOS7DownloadBar, mxShape);
mxShapeIOS7DownloadBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.foreground(c, w, h)
}
;
mxShapeIOS7DownloadBar.prototype.foreground = function(c, w, h) {
    var fieldText = mxUtils.getValue(this.style, mxIOS7C.BUTTON_TEXT, "");
    c.setFontStyle(mxConstants.FONT_BOLD);
    c.text(w * .5, h * .2, 0, 0, fieldText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    var barPos = mxUtils.getValue(this.style, mxIOS7C.BAR_POS, "80");
    barPos = Math.min(barPos, 100);
    barPos = Math.max(barPos, 0);
    var truePos = w * barPos / 100;
    c.setStrokeWidth(2);
    c.setStrokeColor(mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, ""));
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(w, h * .5);
    c.stroke();
    c.setStrokeColor(mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, ""));
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(truePos, h * .5);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxIOS7C.SHAPE_IOS7_DOWNLOAD_BAR, mxShapeIOS7DownloadBar);
Graph.handleFactory[mxIOS7C.SHAPE_IOS7_DOWNLOAD_BAR] = function(state) {
    var handles = [Graph.createHandle(state, ["barPos"], function(bounds) {
        var barPos = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, "barPos", this.barPos))));
        return new mxPoint(bounds.x + barPos / 100 * bounds.width,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["barPos"] = Math.round(1E3 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 1E3
    })];
    return handles
}
;
function mxShapeIOS7Icon(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeIOS7Icon, mxShape);
mxShapeIOS7Icon.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.foreground(c, w, h)
}
;
mxShapeIOS7Icon.prototype.foreground = function(c, w, h) {
    c.setGradient("#00D0F0", "#0080F0", w * .325, 0, w * .675, h * .5, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.roundrect(0, 0, w, h, w * .1, h * .1);
    c.fill();
    var fieldText = mxUtils.getValue(this.style, mxIOS7C.BUTTON_TEXT, "");
    c.setFontColor("#ffffff");
    c.setFontStyle(mxConstants.FONT_BOLD);
    c.setFontSize(8);
    c.text(w * .5, h * .5, 0, 0, fieldText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxIOS7C.SHAPE_IOS7_ICON, mxShapeIOS7Icon);
function mxShapeIOS7horButtonBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeIOS7horButtonBar, mxShape);
mxShapeIOS7horButtonBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    var textStrings = mxUtils.getValue(this.style, mxIOS7C.BUTTON_TEXT, "+Button 1, Button 2, Button 3").toString().split(",");
    var fontColor = mxUtils.getValue(this.style, mxIOS7C.STYLE_TEXTCOLOR, "#666666");
    var selectedFontColor = mxUtils.getValue(this.style, mxIOS7C.STYLE_TEXTCOLOR2, "#ffffff");
    var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "8.5").toString();
    var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#666666");
    var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var selectedFillColor = mxUtils.getValue(this.style, mxIOS7C.STYLE_FILLCOLOR2, "#008cff");
    var buttonNum = textStrings.length;
    var buttonWidths = new Array(buttonNum);
    var buttonTotalWidth = 0;
    var selectedButton = -1;
    var rSize = 2.5;
    var labelOffset = 2.5;
    for (var i = 0; i < buttonNum; i++) {
        var buttonText = textStrings[i];
        if (buttonText.charAt(0) === mxIOS7C.SELECTED) {
            buttonText = textStrings[i].substring(1);
            selectedButton = i
        }
        buttonWidths[i] = mxUtils.getSizeForString(buttonText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
        buttonTotalWidth += buttonWidths[i]
    }
    var trueH = Math.max(h, fontSize * 1.5, 10);
    var minW = 2 * labelOffset * buttonNum + buttonTotalWidth;
    var trueW = Math.max(w, minW);
    c.translate(x, y);
    this.background(c, trueW, trueH, rSize, buttonNum, buttonWidths, labelOffset, minW, frameColor, bgColor, selectedFillColor, selectedButton);
    c.setShadow(false);
    var currWidth = 0;
    for (var i = 0; i < buttonNum; i++) {
        if (i === selectedButton)
            c.setFontColor(selectedFontColor);
        else
            c.setFontColor(fontColor);
        currWidth = currWidth + labelOffset;
        this.buttonText(c, currWidth, trueH, textStrings[i], buttonWidths[i], fontSize, minW, trueW);
        currWidth = currWidth + buttonWidths[i] + labelOffset
    }
}
;
mxShapeIOS7horButtonBar.prototype.background = function(c, w, h, rSize, buttonNum, buttonWidths, labelOffset, minW, frameColor, bgColor, selectedFillColor, selectedButton) {
    c.begin();
    c.setStrokeColor(frameColor);
    c.setFillColor(bgColor);
    c.moveTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, h - rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
    c.lineTo(rSize, h);
    c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
    c.close();
    c.fillAndStroke();
    c.setStrokeColor(frameColor);
    c.begin();
    for (var i = 1; i < buttonNum; i++)
        if (i !== selectedButton && i !== selectedButton + 1) {
            var currWidth = 0;
            for (var j = 0; j < i; j++)
                currWidth += buttonWidths[j] + 2 * labelOffset;
            currWidth = currWidth * w / minW;
            c.moveTo(currWidth, 0);
            c.lineTo(currWidth, h)
        }
    c.stroke();
    var buttonLeft = 0;
    c.setStrokeColor(mxConstants.NONE);
    for (var i = 0; i < selectedButton; i++)
        buttonLeft += buttonWidths[i] + 2 * labelOffset;
    buttonLeft = buttonLeft * w / minW;
    var buttonRight = (buttonWidths[selectedButton] + 2 * labelOffset) * w / minW;
    buttonRight += buttonLeft;
    c.setFillColor("#0080F0");
    if (selectedButton === 0) {
        c.begin();
        c.moveTo(0, rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
        c.lineTo(buttonRight, 0);
        c.lineTo(buttonRight, h);
        c.lineTo(rSize, h);
        c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
        c.close();
        c.fill()
    } else if (selectedButton === buttonNum - 1) {
        c.begin();
        c.moveTo(buttonLeft, 0);
        c.lineTo(buttonRight - rSize, 0);
        c.arcTo(rSize, rSize, 0, 0, 1, buttonRight, rSize);
        c.lineTo(buttonRight, h - rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, buttonRight - rSize, h);
        c.lineTo(buttonLeft, h);
        c.close();
        c.fill()
    } else if (selectedButton !== -1) {
        c.begin();
        c.moveTo(buttonLeft, 0);
        c.lineTo(buttonRight, 0);
        c.lineTo(buttonRight, h);
        c.lineTo(buttonLeft, h);
        c.close();
        c.fill()
    }
    c.setStrokeColor(frameColor);
    c.setFillColor(bgColor);
    c.begin();
    c.moveTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, h - rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
    c.lineTo(rSize, h);
    c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
    c.close();
    c.stroke()
}
;
mxShapeIOS7horButtonBar.prototype.buttonText = function(c, w, h, textString, buttonWidth, fontSize, minW, trueW) {
    if (textString.charAt(0) === mxIOS7C.SELECTED)
        textString = textString.substring(1);
    c.begin();
    c.setFontSize(fontSize);
    c.text((w + buttonWidth * .5) * trueW / minW, h * .5, 0, 0, textString, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxIOS7C.SHAPE_IOS7_HOR_BUTTON_BAR, mxShapeIOS7horButtonBar);
function mxShapeIOS7pageControl(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeIOS7pageControl, mxShape);
mxShapeIOS7pageControl.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#000000");
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    var rSize = Math.min(h * .5, w * .05);
    c.setFillColor(strokeColor);
    c.ellipse(0, h * .5 - rSize, 2 * rSize, 2 * rSize);
    c.fill();
    c.ellipse(w * .25 - rSize * .5, h * .5 - rSize, 2 * rSize, 2 * rSize);
    c.fill();
    c.ellipse(w * .5 - rSize, h * .5 - rSize, 2 * rSize, 2 * rSize);
    c.fill();
    c.ellipse(w * .75 - rSize * 1.5, h * .5 - rSize, 2 * rSize, 2 * rSize);
    c.fill();
    c.setFillColor(fillColor);
    c.ellipse(w - 2 * rSize, h * .5 - rSize, 2 * rSize, 2 * rSize);
    c.fill()
}
;
mxCellRenderer.registerShape(mxIOS7C.SHAPE_IOS7_PAGE_CONTROL, mxShapeIOS7pageControl);
function mxShapeIOS7iconGrid(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeIOS7iconGrid, mxShape);
mxShapeIOS7iconGrid.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var gridSize = mxUtils.getValue(this.style, mxIOS7C.GRID_SIZE, "4,7").toString().split(",");
    var boxSizeX = w / (parseInt(gridSize[0], 10) + (gridSize[0] - 1) * .1);
    var boxSizeY = h / (parseInt(gridSize[1], 10) + (gridSize[1] - 1) * .1);
    for (var i = 0; i < gridSize[0]; i++)
        for (var j = 0; j < gridSize[1]; j++) {
            c.rect(boxSizeX * 1.1 * i, boxSizeY * 1.1 * j, boxSizeX, boxSizeY);
            c.fill()
        }
}
;
mxCellRenderer.registerShape(mxIOS7C.SHAPE_IOS7_ICON_GRID, mxShapeIOS7iconGrid);
function mxShapeIOS7phone(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeIOS7phone, mxShape);
mxShapeIOS7phone.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = 25;
    c.roundrect(0, 0, w, h, rSize, rSize);
    c.fillAndStroke();
    c.setShadow(false);
    this.foreground(c, x, y, w, h, rSize)
}
;
mxShapeIOS7phone.prototype.foreground = function(c, x, y, w, h, rSize) {
    c.rect(w * .0625, h * .15, w * .875, h * .7);
    c.stroke();
    c.ellipse(w * .4875, h * .04125, w * .025, h * .0125);
    c.stroke();
    c.roundrect(w * .375, h * .075, w * .25, h * .01875, w * .02, h * .01);
    c.stroke();
    c.ellipse(w * .4, h * .875, w * .2, h * .1);
    c.stroke();
    c.roundrect(w * .4575, h * .905, w * .085, h * .04375, h * .00625, h * .00625);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxIOS7C.SHAPE_IOS7_PHONE, mxShapeIOS7phone);
function mxShapeIOS7searchBox(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeIOS7searchBox, mxShape);
mxShapeIOS7searchBox.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxShapeIOS7searchBox.prototype.background = function(c, w, h) {
    c.rect(0, 0, w, h);
    c.fill()
}
;
mxShapeIOS7searchBox.prototype.foreground = function(c, w, h) {
    var mainText = mxUtils.getValue(this.style, mxIOS7C.BUTTON_TEXT, "Search");
    var fontColor = mxUtils.getValue(this.style, mxIOS7C.STYLE_TEXTCOLOR, "#666666");
    var strokeColor2 = mxUtils.getValue(this.style, mxIOS7C.STYLE_STROKECOLOR2, "#008cff");
    var fontSize = mxUtils.getValue(this.style, mxIOS7C.STYLE_TEXTSIZE, "17");
    var rSize = Math.min(w, h) * .1;
    c.setFillColor("#ffffff");
    c.roundrect(w * .05, h * .15, w * .5, h * .7, rSize, rSize);
    c.fillAndStroke();
    c.setFontColor(fontColor);
    c.setFontSize(Math.min(h * .7, w * .1));
    c.text(5, h * .5, 0, 0, mainText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setStrokeColor(strokeColor2);
    c.ellipse(w * .05 + 3, h * .5 - 3, 4, 4);
    c.stroke();
    c.begin();
    c.moveTo(w * .05 + 8, h * .5 + 3.5);
    c.lineTo(w * .05 + 6, h * .5 + .5);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxIOS7C.SHAPE_IOS7_SEARCH_BOX, mxShapeIOS7searchBox);
function mxShapeIOS7URL(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeIOS7URL, mxShape);
mxShapeIOS7URL.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxShapeIOS7URL.prototype.background = function(c, w, h) {
    c.rect(0, 0, w, h);
    c.fill()
}
;
mxShapeIOS7URL.prototype.foreground = function(c, w, h) {
    var mainText = mxUtils.getValue(this.style, mxIOS7C.BUTTON_TEXT, "draw.io");
    var fontColor = mxUtils.getValue(this.style, mxIOS7C.STYLE_TEXTCOLOR, "#666666");
    var strokeColor2 = mxUtils.getValue(this.style, mxIOS7C.STYLE_STROKECOLOR2, "#008cff");
    var fontSize = mxUtils.getValue(this.style, mxIOS7C.STYLE_TEXTSIZE, "17");
    var rSize = Math.min(w, h) * .1;
    c.setFillColor("#d8d8d8");
    c.roundrect(w * .05, h * .15, w * .9, h * .7, rSize, rSize);
    c.fill();
    c.setFontColor(fontColor);
    c.setFontSize(Math.min(h * .7, w * .1));
    c.text(w * .5, h * .5, 0, 0, mainText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setStrokeColor(strokeColor2);
    c.begin();
    c.moveTo(w * .95 - 5, h * .5);
    c.arcTo(3, 3, 0, 1, 1, w * .95 - 8, h * .5 - 3);
    c.stroke();
    c.setFillColor(strokeColor2);
    c.begin();
    c.moveTo(w * .95 - 8, h * .5 - 4);
    c.lineTo(w * .95 - 6, h * .5 - 3);
    c.lineTo(w * .95 - 8, h * .5 - 2);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxIOS7C.SHAPE_IOS7_URL, mxShapeIOS7URL);
function mxShapeIOS7Actiondialog(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeIOS7Actiondialog, mxShape);
mxShapeIOS7Actiondialog.prototype.paintVertexShape = function(c, x, y, w, h) {
    var mainText = mxUtils.getValue(this.style, mxIOS7C.MAIN_TEXT, "Main Text");
    var subText = mxUtils.getValue(this.style, mxIOS7C.SUB_TEXT, "Sub Text");
    var fontColor = mxUtils.getValue(this.style, mxIOS7C.STYLE_TEXTCOLOR, "#666666");
    var fontSize = mxUtils.getValue(this.style, mxIOS7C.STYLE_TEXTSIZE, "17");
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    c.setFillColor("#e0e0e0");
    c.roundrect(w * .05, h * .1, w * .9, h * .35, w * .025, h * .05);
    c.fill();
    c.roundrect(w * .05, h * .55, w * .9, h * .35, w * .025, h * .05);
    c.fill();
    c.setFontStyle(mxConstants.FONT_BOLD);
    this.mainText(c, x, y, w, h, mainText, fontSize, fontColor);
    this.subText(c, x, y, w, h, subText, fontSize / 1.4, fontColor)
}
;
mxShapeIOS7Actiondialog.prototype.background = function(c, x, y, w, h) {
    c.rect(0, 0, w, h);
    c.fill()
}
;
mxShapeIOS7Actiondialog.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor) {
    c.begin();
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    c.text(w * .5, h * .4, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxShapeIOS7Actiondialog.prototype.subText = function(c, x, y, w, h, text, fontSize, fontColor) {
    c.begin();
    c.setFontSize(fontSize);
    c.text(w * .5, h * .7, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxIOS7C.SHAPE_IOS7_ACTION_DIALOG, mxShapeIOS7Actiondialog);
function mxShapeIOS7Anchor(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds
}
mxUtils.extend(mxShapeIOS7Anchor, mxShape);
mxShapeIOS7Anchor.prototype.cst = {
    ANCHOR: "mxgraph.ios7ui.anchor"
};
mxShapeIOS7Anchor.prototype.paintVertexShape = function(c, x, y, w, h) {}
;
mxCellRenderer.registerShape(mxShapeIOS7Anchor.prototype.cst.ANCHOR, mxShapeIOS7Anchor);
function mxShapeIOS7RRect(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeIOS7RRect, mxShape);
mxShapeIOS7RRect.prototype.cst = {
    RRECT: "mxgraph.ios7ui.rrect",
    R_SIZE: "rSize"
};
mxShapeIOS7RRect.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeIOS7RRect.prototype.cst.R_SIZE, "10"));
    c.roundrect(0, 0, w, h, rSize);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeIOS7RRect.prototype.cst.RRECT, mxShapeIOS7RRect);
function mxShapeIOS7LeftButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeIOS7LeftButton, mxShape);
mxShapeIOS7LeftButton.prototype.cst = {
    LEFT_BUTTON: "mxgraph.ios7ui.leftButton",
    R_SIZE: "rSize"
};
mxShapeIOS7LeftButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeIOS7LeftButton.prototype.cst.R_SIZE, "10"));
    c.begin();
    c.moveTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(rSize, h);
    c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
    c.lineTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeIOS7LeftButton.prototype.cst.LEFT_BUTTON, mxShapeIOS7LeftButton);
function mxShapeIOS7RightButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeIOS7RightButton, mxShape);
mxShapeIOS7RightButton.prototype.cst = {
    RIGHT_BUTTON: "mxgraph.ios7ui.rightButton",
    R_SIZE: "rSize"
};
mxShapeIOS7RightButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeIOS7RightButton.prototype.cst.R_SIZE, "10"));
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, h - rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeIOS7RightButton.prototype.cst.RIGHT_BUTTON, mxShapeIOS7RightButton);
function mxShapeIOS7TopButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeIOS7TopButton, mxShape);
mxShapeIOS7TopButton.prototype.cst = {
    TOP_BUTTON: "mxgraph.ios7ui.topButton",
    R_SIZE: "rSize"
};
mxShapeIOS7TopButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeIOS7TopButton.prototype.cst.R_SIZE, "10"));
    c.begin();
    c.moveTo(w, h);
    c.lineTo(0, h);
    c.lineTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeIOS7TopButton.prototype.cst.TOP_BUTTON, mxShapeIOS7TopButton);
function mxShapeIOS7BottomButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeIOS7BottomButton, mxShape);
mxShapeIOS7BottomButton.prototype.cst = {
    BOTTOM_BUTTON: "mxgraph.ios7ui.bottomButton",
    R_SIZE: "rSize"
};
mxShapeIOS7BottomButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeIOS7BottomButton.prototype.cst.R_SIZE, "10"));
    c.begin();
    c.moveTo(w, 0);
    c.lineTo(0, 0);
    c.lineTo(0, h - rSize);
    c.arcTo(rSize, rSize, 0, 0, 0, rSize, h);
    c.lineTo(w - rSize, h);
    c.arcTo(rSize, rSize, 0, 0, 0, w, h - rSize);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeIOS7BottomButton.prototype.cst.BOTTOM_BUTTON, mxShapeIOS7BottomButton);
function mxShapeIOS7HorLines(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeIOS7HorLines, mxShape);
mxShapeIOS7HorLines.prototype.cst = {
    HOR_LINES: "mxgraph.ios7ui.horLines"
};
mxShapeIOS7HorLines.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.rect(0, 0, w, h);
    c.fill();
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.moveTo(0, h);
    c.lineTo(w, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeIOS7HorLines.prototype.cst.HOR_LINES, mxShapeIOS7HorLines);
function mxShapeIOS7MarginRect(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeIOS7MarginRect, mxShape);
mxShapeIOS7MarginRect.prototype.cst = {
    SHAPE_MARGIN_RECT: "mxgraph.ios7ui.marginRect",
    MARGIN: "rectMargin",
    RX: "rx",
    RY: "ry",
    MARGIN_TOP: "rectMarginTop",
    MARGIN_LEFT: "rectMarginLeft",
    MARGIN_BOTTOM: "rectMarginBottom",
    MARGIN_RIGHT: "rectMarginRight"
};
mxShapeIOS7MarginRect.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h)
}
;
mxShapeIOS7MarginRect.prototype.background = function(c, x, y, w, h, state) {
    var margin = parseFloat(mxUtils.getValue(this.style, mxShapeIOS7MarginRect.prototype.cst.MARGIN, "0"));
    var marginTop = parseFloat(mxUtils.getValue(this.style, mxShapeIOS7MarginRect.prototype.cst.MARGIN_TOP, "0"));
    var marginLeft = parseFloat(mxUtils.getValue(this.style, mxShapeIOS7MarginRect.prototype.cst.MARGIN_LEFT, "0"));
    var marginBottom = parseFloat(mxUtils.getValue(this.style, mxShapeIOS7MarginRect.prototype.cst.MARGIN_BOTTOM, "0"));
    var marginRight = parseFloat(mxUtils.getValue(this.style, mxShapeIOS7MarginRect.prototype.cst.MARGIN_RIGHT, "0"));
    var rx = parseFloat(mxUtils.getValue(this.style, mxShapeIOS7MarginRect.prototype.cst.RX, "0"));
    var ry = parseFloat(mxUtils.getValue(this.style, mxShapeIOS7MarginRect.prototype.cst.RY, "0"));
    var x1 = margin + marginLeft;
    var y1 = margin + marginTop;
    var w1 = w - marginRight - x1 - margin;
    var h1 = h - marginBottom - y1 - margin;
    if (w1 > 0 && h1 > 0) {
        c.begin();
        c.roundrect(x1, y1, w1, h1, rx, ry);
        c.fillAndStroke()
    }
}
;
mxCellRenderer.registerShape(mxShapeIOS7MarginRect.prototype.cst.SHAPE_MARGIN_RECT, mxShapeIOS7MarginRect);
function mxShapeIOS7Callout(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeIOS7Callout, mxShape);
mxShapeIOS7Callout.prototype.cst = {
    SHAPE_CALLOUT: "mxgraph.ios7ui.callout"
};
mxShapeIOS7Callout.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h)
}
;
mxShapeIOS7Callout.prototype.background = function(c, x, y, w, h, state) {
    var r = 10;
    if (w >= 30 && h >= 20) {
        c.begin();
        c.moveTo(15, h - r * .3);
        c.arcTo(r * 2, r, 0, 0, 1, 0, h);
        c.arcTo(r * 1.5, r * 1.5, 0, 0, 0, 10, h - r * 1);
        c.lineTo(r, r);
        c.arcTo(r, r, 0, 0, 1, r * 2, 0);
        c.lineTo(w - r, 0);
        c.arcTo(r, r, 0, 0, 1, w, r);
        c.lineTo(w, h - r);
        c.arcTo(r, r, 0, 0, 1, w - r, h);
        c.lineTo(r * 2, h);
        c.arcTo(r, r, 0, 0, 1, r * 1.5, h - r * .3);
        c.close();
        c.fillAndStroke()
    }
}
;
mxCellRenderer.registerShape(mxShapeIOS7Callout.prototype.cst.SHAPE_CALLOUT, mxShapeIOS7Callout);
function mxShapeIOS7SelectBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy = .5;
    this.dx = .5;
    this.dx2 = 70;
    this.size = 10
}
mxUtils.extend(mxShapeIOS7SelectBar, mxActor);
mxShapeIOS7SelectBar.prototype.cst = {
    SELECT_BAR: "mxgraph.ios7ui.selectBar"
};
mxShapeIOS7SelectBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    var dx2 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx2", this.dx2))));
    var r = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "size", this.size))));
    var dy = Math.max(0, Math.min(h, (w - Math.max(20, r) - r) / 2, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    r = Math.min(h / 2, w / 2, r);
    dx = Math.max(r + dy, dx);
    dx = Math.min(w - r - dy, w - 20 - dy, dx);
    c.begin();
    c.moveTo(dx - dy, h);
    c.lineTo(r, h);
    c.arcTo(r, r, 0, 0, 1, 0, h - r);
    c.lineTo(0, r);
    c.arcTo(r, r, 0, 0, 1, r, 0);
    c.lineTo(w - r, 0);
    c.arcTo(r, r, 0, 0, 1, w, r);
    c.lineTo(w, h - r);
    c.arcTo(r, r, 0, 0, 1, w - r, h);
    c.lineTo(dx + dy, h);
    c.lineTo(dx, h + dy);
    c.close();
    c.fillAndStroke();
    c.setShadow(false);
    c.begin();
    c.moveTo(w - Math.max(20, r), 0);
    c.lineTo(w - Math.max(20, r), h);
    c.stroke();
    var currDx = dx2;
    c.begin();
    while (currDx < w - Math.max(20, r)) {
        c.moveTo(currDx, 0);
        c.lineTo(currDx, h);
        currDx = currDx + dx2
    }
    c.stroke();
    var w1 = Math.min(Math.max(20, r), h);
    var x1 = w - w1 * .5;
    var y1 = h * .5;
    c.setFillColor(mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, ""));
    c.begin();
    c.moveTo(x1 - w1 * .15, y1 - w1 * .225);
    c.lineTo(x1 + w1 * .25, y1);
    c.lineTo(x1 - w1 * .15, y1 + w1 * .225);
    c.close();
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeIOS7SelectBar.prototype.cst.SELECT_BAR, mxShapeIOS7SelectBar);
mxShapeIOS7SelectBar.prototype.constraints = null;
Graph.handleFactory[mxShapeIOS7SelectBar.prototype.cst.SELECT_BAR] = function(state) {
    var handles = [Graph.createHandle(state, ["dx"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        return new mxPoint(bounds.x + dx,bounds.y + bounds.height)
    }, function(bounds, pt) {
        var y = parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy)) * .6;
        this.state.style["dx"] = Math.round(100 * Math.max(y, Math.min(bounds.width - y, pt.x - bounds.x))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["dy"], function(bounds) {
        var dy = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx)),bounds.y + bounds.height + dy)
    }, function(bounds, pt) {
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(bounds.height, pt.y - bounds.y - bounds.height))) / 100
    });
    handles.push(handle2);
    var handle3 = Graph.createHandle(state, ["size"], function(bounds) {
        var size = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "size", this.size))));
        return new mxPoint(bounds.x + bounds.width - size,bounds.y + 10)
    }, function(bounds, pt) {
        this.state.style["size"] = Math.round(100 * Math.max(0, Math.min(bounds.width / 2, bounds.height / 2, bounds.x + bounds.width - pt.x))) / 100
    });
    handles.push(handle3);
    var handle4 = Graph.createHandle(state, ["dx2"], function(bounds) {
        var dx2 = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx2", this.dx2))));
        return new mxPoint(bounds.x + dx2,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["dx2"] = Math.round(100 * Math.max(0, Math.min(bounds.width, pt.x - bounds.x))) / 100
    });
    handles.push(handle4);
    return handles
}
;
mxShapeIOS7SelectBar;
function mxShapeIOS7Slider2(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeIOS7Slider2, mxShape);
mxShapeIOS7Slider2.prototype.cst = {
    SHAPE_SLIDER: "mxgraph.ios7ui.slider",
    BAR_POS: "barPos",
    HANDLE_SIZE: "handleSize"
};
mxShapeIOS7Slider2.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(true)
}
;
mxShapeIOS7Slider2.prototype.background = function(c, x, y, w, h) {
    var hSize = parseFloat(mxUtils.getValue(this.style, mxShapeIOS7Slider2.prototype.cst.HANDLE_SIZE, "10"));
    var barPos = parseFloat(mxUtils.getValue(this.style, mxShapeIOS7Slider2.prototype.cst.BAR_POS, "40")) / 100;
    barPos = Math.max(0, Math.min(1, barPos));
    c.save();
    c.setStrokeColor("#bbbbbb");
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(w, h * .5);
    c.fillAndStroke();
    c.restore();
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(barPos * w, h * .5);
    c.fillAndStroke();
    c.setStrokeColor("#bbbbbb");
    c.begin();
    c.ellipse(barPos * w - hSize * .5, h * .5 - hSize * .5, hSize, hSize);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeIOS7Slider2.prototype.cst.SHAPE_SLIDER, mxShapeIOS7Slider2);
mxShapeIOS7Slider2.prototype.constraints = null;
Graph.handleFactory[mxShapeIOS7Slider2.prototype.cst.SHAPE_SLIDER] = function(state) {
    var handles = [Graph.createHandle(state, ["barPos"], function(bounds) {
        var barPos = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "barPos", .4))));
        return new mxPoint(bounds.x + barPos * bounds.width / 100,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["barPos"] = Math.round(100 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 100
    })];
    return handles
}
;
function mxShapeMockupMultiButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupMultiButton, mxShape);
mxShapeMockupMultiButton.prototype.cst = {
    MAIN_TEXT: "mainText",
    SHAPE_MULTILINE_BUTTON: "mxgraph.mockup.buttons.multiButton",
    SUB_TEXT: "subText",
    TEXT_COLOR: "textColor",
    TEXT_SIZE: "textSize",
    BUTTON_STYLE: "buttonStyle",
    ROUND: "round",
    CHEVRON: "chevron"
};
mxShapeMockupMultiButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    var mainText = mxUtils.getValue(this.style, mxShapeMockupMultiButton.prototype.cst.MAIN_TEXT, "Main Text");
    var subText = mxUtils.getValue(this.style, mxShapeMockupMultiButton.prototype.cst.SUB_TEXT, "Sub Text");
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupMultiButton.prototype.cst.TEXT_COLOR, "#666666");
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupMultiButton.prototype.cst.TEXT_SIZE, "17");
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    c.setFontStyle(mxConstants.FONT_BOLD);
    this.mainText(c, x, y, w, h, mainText, fontSize, fontColor);
    this.subText(c, x, y, w, h, subText, fontSize / 1.4, fontColor)
}
;
mxShapeMockupMultiButton.prototype.background = function(c, x, y, w, h) {
    var buttonStyle = mxUtils.getValue(this.style, mxShapeMockupMultiButton.prototype.cst.BUTTON_STYLE, mxShapeMockupMultiButton.prototype.cst.ROUND).toString();
    var rSize = 10;
    c.begin();
    if (buttonStyle === mxShapeMockupMultiButton.prototype.cst.ROUND) {
        c.moveTo(0, rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
        c.lineTo(w - rSize, 0);
        c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
        c.lineTo(w, h - rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
        c.lineTo(rSize, h);
        c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize)
    } else if (buttonStyle === mxShapeMockupMultiButton.prototype.cst.CHEVRON) {
        c.moveTo(0, h * .1);
        c.arcTo(w * .0372, h * .1111, 0, 0, 1, w * .0334, 0);
        c.lineTo(w * .768, 0);
        c.arcTo(w * .0722, h * .216, 0, 0, 1, w * .8014, h * .0399);
        c.lineTo(w * .99, h * .4585);
        c.arcTo(w * .09, h * .1, 0, 0, 1, w * .99, h * .5415);
        c.lineTo(w * .8014, h * .9568);
        c.arcTo(w * .0722, h * .216, 0, 0, 1, w * .768, h);
        c.lineTo(w * .0334, h);
        c.arcTo(w * .0372, h * .1111, 0, 0, 1, 0, h * .9)
    }
    c.close();
    c.fillAndStroke()
}
;
mxShapeMockupMultiButton.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor) {
    c.begin();
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    c.text(w * .5, h * .4, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxShapeMockupMultiButton.prototype.subText = function(c, x, y, w, h, text, fontSize, fontColor) {
    c.begin();
    c.setFontSize(fontSize);
    c.text(w * .5, h * .7, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxShapeMockupMultiButton.prototype.cst.SHAPE_MULTILINE_BUTTON, mxShapeMockupMultiButton);
function mxShapeMockupButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupButton, mxShape);
mxShapeMockupButton.prototype.cst = {
    MAIN_TEXT: "mainText",
    SHAPE_BUTTON: "mxgraph.mockup.buttons.button",
    TEXT_COLOR: "textColor",
    TEXT_SIZE: "textSize",
    BUTTON_STYLE: "buttonStyle",
    ROUND: "round",
    CHEVRON: "chevron"
};
mxShapeMockupButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    var mainText = mxUtils.getValue(this.style, mxShapeMockupButton.prototype.cst.MAIN_TEXT, "Main Text");
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupButton.prototype.cst.TEXT_COLOR, "#666666").toString();
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupButton.prototype.cst.TEXT_SIZE, "17").toString();
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.mainText(c, x, y, w, h, mainText, fontSize, fontColor)
}
;
mxShapeMockupButton.prototype.background = function(c, x, y, w, h) {
    var buttonStyle = mxUtils.getValue(this.style, mxShapeMockupButton.prototype.cst.BUTTON_STYLE, mxShapeMockupButton.prototype.cst.ROUND).toString();
    var rSize = 10;
    c.begin();
    if (buttonStyle === mxShapeMockupButton.prototype.cst.ROUND) {
        c.moveTo(0, rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
        c.lineTo(w - rSize, 0);
        c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
        c.lineTo(w, h - rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
        c.lineTo(rSize, h);
        c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize)
    } else if (buttonStyle === mxShapeMockupButton.prototype.cst.CHEVRON) {
        c.moveTo(0, h * .1);
        c.arcTo(w * .0372, h * .1111, 0, 0, 1, w * .0334, 0);
        c.lineTo(w * .768, 0);
        c.arcTo(w * .0722, h * .216, 0, 0, 1, w * .8014, h * .0399);
        c.lineTo(w * .99, h * .4585);
        c.arcTo(w * .09, h * .1, 0, 0, 1, w * .99, h * .5415);
        c.lineTo(w * .8014, h * .9568);
        c.arcTo(w * .0722, h * .216, 0, 0, 1, w * .768, h);
        c.lineTo(w * .0334, h);
        c.arcTo(w * .0372, h * .1111, 0, 0, 1, 0, h * .9)
    }
    c.close();
    c.fillAndStroke()
}
;
mxShapeMockupButton.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor) {
    c.begin();
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    c.setFontStyle(mxConstants.FONT_BOLD);
    c.text(w / 2, h / 2, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxShapeMockupButton.prototype.cst.SHAPE_BUTTON, mxShapeMockupButton);
function mxShapeMockupHorButtonBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupHorButtonBar, mxShape);
mxShapeMockupHorButtonBar.prototype.cst = {
    MAIN_TEXT: "mainText",
    SHAPE_HOR_BUTTON_BAR: "mxgraph.mockup.buttons.horButtonBar",
    TEXT_COLOR: "textColor",
    TEXT_COLOR2: "textColor2",
    STROKE_COLOR2: "strokeColor2",
    FILL_COLOR2: "fillColor2",
    SELECTED: "+",
    TEXT_SIZE: "textSize"
};
mxShapeMockupHorButtonBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    var textStrings = mxUtils.getValue(this.style, mxShapeMockupHorButtonBar.prototype.cst.MAIN_TEXT, "+Button 1, Button 2, Button 3").toString().split(",");
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupHorButtonBar.prototype.cst.TEXT_COLOR, "#666666");
    var selectedFontColor = mxUtils.getValue(this.style, mxShapeMockupHorButtonBar.prototype.cst.TEXT_COLOR2, "#ffffff");
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupHorButtonBar.prototype.cst.TEXT_SIZE, "17").toString();
    var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#666666");
    var separatorColor = mxUtils.getValue(this.style, mxShapeMockupHorButtonBar.prototype.cst.STROKE_COLOR2, "#c4c4c4");
    var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var selectedFillColor = mxUtils.getValue(this.style, mxShapeMockupHorButtonBar.prototype.cst.FILL_COLOR2, "#008cff");
    var buttonNum = textStrings.length;
    var buttonWidths = new Array(buttonNum);
    var buttonTotalWidth = 0;
    var selectedButton = -1;
    var rSize = 10;
    var labelOffset = 5;
    for (var i = 0; i < buttonNum; i++) {
        var buttonText = textStrings[i];
        if (buttonText.charAt(0) === mxShapeMockupHorButtonBar.prototype.cst.SELECTED) {
            buttonText = textStrings[i].substring(1);
            selectedButton = i
        }
        buttonWidths[i] = mxUtils.getSizeForString(buttonText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
        buttonTotalWidth += buttonWidths[i]
    }
    var trueH = Math.max(h, fontSize * 1.5, 20);
    var minW = 2 * labelOffset * buttonNum + buttonTotalWidth;
    var trueW = Math.max(w, minW);
    c.translate(x, y);
    this.background(c, trueW, trueH, rSize, buttonNum, buttonWidths, labelOffset, minW, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton);
    c.setShadow(false);
    c.setFontStyle(mxConstants.FONT_BOLD);
    var currWidth = 0;
    for (var i = 0; i < buttonNum; i++) {
        if (i === selectedButton)
            c.setFontColor(selectedFontColor);
        else
            c.setFontColor(fontColor);
        currWidth = currWidth + labelOffset;
        this.buttonText(c, currWidth, trueH, textStrings[i], buttonWidths[i], fontSize, minW, trueW);
        currWidth = currWidth + buttonWidths[i] + labelOffset
    }
}
;
mxShapeMockupHorButtonBar.prototype.background = function(c, w, h, rSize, buttonNum, buttonWidths, labelOffset, minW, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton) {
    c.begin();
    c.setStrokeColor(frameColor);
    c.setFillColor(bgColor);
    c.moveTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, h - rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
    c.lineTo(rSize, h);
    c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
    c.close();
    c.fillAndStroke();
    c.setStrokeColor(separatorColor);
    c.begin();
    for (var i = 1; i < buttonNum; i++)
        if (i !== selectedButton && i !== selectedButton + 1) {
            var currWidth = 0;
            for (var j = 0; j < i; j++)
                currWidth += buttonWidths[j] + 2 * labelOffset;
            currWidth = currWidth * w / minW;
            c.moveTo(currWidth, 0);
            c.lineTo(currWidth, h)
        }
    c.stroke();
    var buttonLeft = 0;
    c.setFillColor(selectedFillColor);
    for (var i = 0; i < selectedButton; i++)
        buttonLeft += buttonWidths[i] + 2 * labelOffset;
    buttonLeft = buttonLeft * w / minW;
    var buttonRight = (buttonWidths[selectedButton] + 2 * labelOffset) * w / minW;
    buttonRight += buttonLeft;
    if (selectedButton === 0) {
        c.begin();
        c.moveTo(0, rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
        c.lineTo(buttonRight, 0);
        c.lineTo(buttonRight, h);
        c.lineTo(rSize, h);
        c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
        c.close();
        c.fill()
    } else if (selectedButton === buttonNum - 1) {
        c.begin();
        c.moveTo(buttonLeft, 0);
        c.lineTo(buttonRight - rSize, 0);
        c.arcTo(rSize, rSize, 0, 0, 1, buttonRight, rSize);
        c.lineTo(buttonRight, h - rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, buttonRight - rSize, h);
        c.lineTo(buttonLeft, h);
        c.close();
        c.fill()
    } else if (selectedButton !== -1) {
        c.begin();
        c.moveTo(buttonLeft, 0);
        c.lineTo(buttonRight, 0);
        c.lineTo(buttonRight, h);
        c.lineTo(buttonLeft, h);
        c.close();
        c.fill()
    }
    c.setStrokeColor(frameColor);
    c.setFillColor(bgColor);
    c.begin();
    c.moveTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, h - rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
    c.lineTo(rSize, h);
    c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
    c.close();
    c.stroke()
}
;
mxShapeMockupHorButtonBar.prototype.buttonText = function(c, w, h, textString, buttonWidth, fontSize, minW, trueW) {
    if (textString.charAt(0) === mxShapeMockupHorButtonBar.prototype.cst.SELECTED)
        textString = textString.substring(1);
    c.begin();
    c.setFontSize(fontSize);
    c.text((w + buttonWidth * .5) * trueW / minW, h * .5, 0, 0, textString, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxShapeMockupHorButtonBar.prototype.cst.SHAPE_HOR_BUTTON_BAR, mxShapeMockupHorButtonBar);
function mxShapeMockupVerButtonBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupVerButtonBar, mxShape);
mxShapeMockupVerButtonBar.prototype.cst = {
    MAIN_TEXT: "mainText",
    SHAPE_VER_BUTTON_BAR: "mxgraph.mockup.buttons.verButtonBar",
    TEXT_COLOR: "textColor",
    TEXT_COLOR2: "textColor2",
    STROKE_COLOR2: "strokeColor2",
    FILL_COLOR2: "fillColor2",
    SELECTED: "+",
    TEXT_SIZE: "textSize"
};
mxShapeMockupVerButtonBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    var textStrings = mxUtils.getValue(this.style, mxShapeMockupVerButtonBar.prototype.cst.MAIN_TEXT, "+Button 1, Button 2, Button 3").toString().split(",");
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupVerButtonBar.prototype.cst.TEXT_COLOR, "#666666");
    var selectedFontColor = mxUtils.getValue(this.style, mxShapeMockupVerButtonBar.prototype.cst.TEXT_COLOR2, "#ffffff");
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupVerButtonBar.prototype.cst.TEXT_SIZE, "17").toString();
    var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#666666");
    var separatorColor = mxUtils.getValue(this.style, mxShapeMockupVerButtonBar.prototype.cst.STROKE_COLOR2, "#c4c4c4");
    var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var selectedFillColor = mxUtils.getValue(this.style, mxShapeMockupVerButtonBar.prototype.cst.FILL_COLOR2, "#008cff");
    var buttonNum = textStrings.length;
    var maxButtonWidth = 0;
    var selectedButton = -1;
    var rSize = 10;
    var labelOffset = 5;
    for (var i = 0; i < buttonNum; i++) {
        var buttonText = textStrings[i];
        if (buttonText.charAt(0) === mxShapeMockupVerButtonBar.prototype.cst.SELECTED) {
            buttonText = textStrings[i].substring(1);
            selectedButton = i
        }
        var currWidth = mxUtils.getSizeForString(buttonText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
        if (currWidth > maxButtonWidth)
            maxButtonWidth = currWidth
    }
    var minButtonHeight = fontSize * 1.5;
    var minH = buttonNum * minButtonHeight;
    var trueH = Math.max(h, minH);
    var minW = 2 * labelOffset + maxButtonWidth;
    var trueW = Math.max(w, minW);
    c.translate(x, y);
    this.background(c, trueW, trueH, rSize, buttonNum, labelOffset, buttonNum * minButtonHeight, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton, minButtonHeight);
    c.setShadow(false);
    var currWidth = 0;
    c.setFontStyle(mxConstants.FONT_BOLD);
    for (var i = 0; i < buttonNum; i++) {
        if (i === selectedButton)
            c.setFontColor(selectedFontColor);
        else
            c.setFontColor(fontColor);
        currWidth = currWidth + labelOffset;
        var currHeight = (i * minButtonHeight + minButtonHeight * .5) * trueH / minH;
        this.buttonText(c, trueW, currHeight, textStrings[i], fontSize)
    }
}
;
mxShapeMockupVerButtonBar.prototype.background = function(c, w, h, rSize, buttonNum, labelOffset, minH, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton, minButtonHeight) {
    c.begin();
    c.setStrokeColor(frameColor);
    c.setFillColor(bgColor);
    c.moveTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, h - rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
    c.lineTo(rSize, h);
    c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
    c.close();
    c.fillAndStroke();
    c.setStrokeColor(separatorColor);
    c.begin();
    for (var i = 1; i < buttonNum; i++)
        if (i !== selectedButton && i !== selectedButton + 1) {
            var currHeight = i * minButtonHeight * h / minH;
            c.moveTo(0, currHeight);
            c.lineTo(w, currHeight)
        }
    c.stroke();
    c.setFillColor(selectedFillColor);
    if (selectedButton === 0) {
        c.begin();
        var buttonBottom = minButtonHeight * h / minH;
        c.moveTo(0, rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
        c.lineTo(w - rSize, 0);
        c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
        c.lineTo(w, buttonBottom);
        c.lineTo(0, buttonBottom);
        c.close();
        c.fill()
    } else if (selectedButton === buttonNum - 1) {
        c.begin();
        var buttonTop = h - minButtonHeight * h / minH;
        c.moveTo(0, buttonTop);
        c.lineTo(w, buttonTop);
        c.lineTo(w, h - rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
        c.lineTo(rSize, h);
        c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
        c.close();
        c.fill()
    } else if (selectedButton !== -1) {
        c.begin();
        var buttonTop = minButtonHeight * selectedButton * h / minH;
        var buttonBottom = minButtonHeight * (selectedButton + 1) * h / minH;
        c.moveTo(0, buttonTop);
        c.lineTo(w, buttonTop);
        c.lineTo(w, buttonBottom);
        c.lineTo(0, buttonBottom);
        c.close();
        c.fill()
    }
    c.begin();
    c.setStrokeColor(frameColor);
    c.setFillColor(bgColor);
    c.moveTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, h - rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
    c.lineTo(rSize, h);
    c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
    c.close();
    c.stroke()
}
;
mxShapeMockupVerButtonBar.prototype.buttonText = function(c, w, h, textString, fontSize) {
    if (textString.charAt(0) === mxShapeMockupVerButtonBar.prototype.cst.SELECTED)
        textString = textString.substring(1);
    c.begin();
    c.setFontSize(fontSize);
    c.text(w * .5, h, 0, 0, textString, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxShapeMockupVerButtonBar.prototype.cst.SHAPE_VER_BUTTON_BAR, mxShapeMockupVerButtonBar);
function mxShapeMockupOnOffButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupOnOffButton, mxShape);
mxShapeMockupOnOffButton.prototype.cst = {
    SHAPE_ON_OFF_BUTTON: "mxgraph.mockup.buttons.onOffButton",
    BUTTON_STATE: "buttonState",
    STATE_ON: "on",
    STATE_OFF: "off",
    FILL_COLOR2: "fillColor2",
    MAIN_TEXT: "mainText",
    TEXT_COLOR: "textColor",
    TEXT_SIZE: "textSize"
};
mxShapeMockupOnOffButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    w = Math.max(w, 10);
    h = Math.max(h, 10);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeMockupOnOffButton.prototype.background = function(c, x, y, w, h) {
    c.roundrect(0, 0, w, h, 10, 10);
    c.fillAndStroke()
}
;
mxShapeMockupOnOffButton.prototype.foreground = function(c, x, y, w, h) {
    var state = mxUtils.getValue(this.style, mxShapeMockupOnOffButton.prototype.cst.BUTTON_STATE, mxShapeMockupOnOffButton.prototype.cst.STATE_ON);
    var fillColor2 = mxUtils.getValue(this.style, mxShapeMockupOnOffButton.prototype.cst.FILL_COLOR2, "#008cff");
    var textColor = mxUtils.getValue(this.style, mxShapeMockupOnOffButton.prototype.cst.TEXT_COLOR, "#ffffff,#999999").toString().split(",");
    var mainText = mxUtils.getValue(this.style, mxShapeMockupOnOffButton.prototype.cst.MAIN_TEXT, "ON,OFF").toString().split(",");
    var textSize = mxUtils.getValue(this.style, mxShapeMockupOnOffButton.prototype.cst.TEXT_SIZE, "17");
    if (state === mxShapeMockupOnOffButton.prototype.cst.STATE_ON) {
        c.setFillColor(fillColor2);
        c.setFontColor(textColor[0]);
        c.roundrect(0, 0, w * .75, h, 10, 10)
    } else {
        c.setFontColor(textColor[1]);
        c.roundrect(w * .25, 0, w * .75, h, 10, 10)
    }
    c.fillAndStroke();
    c.setFontSize(textSize);
    c.setFontStyle(mxConstants.FONT_BOLD);
    if (state === mxShapeMockupOnOffButton.prototype.cst.STATE_ON)
        c.text(w * .375, h * .5, 0, 0, mainText[0], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    else if (state === mxShapeMockupOnOffButton.prototype.cst.STATE_OFF)
        c.text(w * .625, h * .5, 0, 0, mainText[1], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxShapeMockupOnOffButton.prototype.cst.SHAPE_ON_OFF_BUTTON, mxShapeMockupOnOffButton);
function mxShapeMockupRRect(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupRRect, mxShape);
mxShapeMockupRRect.prototype.cst = {
    RRECT: "mxgraph.mockup.rrect",
    R_SIZE: "rSize"
};
mxShapeMockupRRect.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupRRect.prototype.cst.R_SIZE, "10"));
    c.roundrect(0, 0, w, h, rSize);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupRRect.prototype.cst.RRECT, mxShapeMockupRRect);
function mxShapeMockupAnchor(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds
}
mxUtils.extend(mxShapeMockupAnchor, mxShape);
mxShapeMockupAnchor.prototype.cst = {
    ANCHOR: "mxgraph.mockup.anchor"
};
mxShapeMockupAnchor.prototype.paintVertexShape = function(c, x, y, w, h) {}
;
mxCellRenderer.registerShape(mxShapeMockupAnchor.prototype.cst.ANCHOR, mxShapeMockupAnchor);
function mxShapeMockupTopButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupTopButton, mxShape);
mxShapeMockupTopButton.prototype.cst = {
    TOP_BUTTON: "mxgraph.mockup.topButton",
    R_SIZE: "rSize"
};
mxShapeMockupTopButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupTopButton.prototype.cst.R_SIZE, "10"));
    c.begin();
    c.moveTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupTopButton.prototype.cst.TOP_BUTTON, mxShapeMockupTopButton);
function mxShapeMockupBottomButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupBottomButton, mxShape);
mxShapeMockupBottomButton.prototype.cst = {
    BOTTOM_BUTTON: "mxgraph.mockup.bottomButton",
    R_SIZE: "rSize"
};
mxShapeMockupBottomButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupBottomButton.prototype.cst.R_SIZE, "10"));
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h - rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
    c.lineTo(rSize, h);
    c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupBottomButton.prototype.cst.BOTTOM_BUTTON, mxShapeMockupBottomButton);
function mxShapeMockupRightButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupRightButton, mxShape);
mxShapeMockupRightButton.prototype.cst = {
    RIGHT_BUTTON: "mxgraph.mockup.rightButton",
    R_SIZE: "rSize"
};
mxShapeMockupRightButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupRightButton.prototype.cst.R_SIZE, "10"));
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, h - rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupRightButton.prototype.cst.RIGHT_BUTTON, mxShapeMockupRightButton);
function mxShapeMockupLeftButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupLeftButton, mxShape);
mxShapeMockupLeftButton.prototype.cst = {
    LEFT_BUTTON: "mxgraph.mockup.leftButton",
    R_SIZE: "rSize"
};
mxShapeMockupLeftButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupLeftButton.prototype.cst.R_SIZE, "10"));
    c.begin();
    c.moveTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(rSize, h);
    c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
    c.lineTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupLeftButton.prototype.cst.LEFT_BUTTON, mxShapeMockupLeftButton);
function mxShapeMockupVideoPlayer(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.barPos = 20;
    this.barHeight = 30
}
mxUtils.extend(mxShapeMockupVideoPlayer, mxShape);
mxShapeMockupVideoPlayer.prototype.cst = {
    FILL_COLOR2: "fillColor2",
    TEXT_COLOR: "textColor",
    STROKE_COLOR2: "strokeColor2",
    STROKE_COLOR3: "strokeColor3",
    SHAPE_VIDEO_PLAYER: "mxgraph.mockup.containers.videoPlayer",
    BAR_POS: "barPos",
    BAR_HEIGHT: "barHeight"
};
mxShapeMockupVideoPlayer.prototype.paintVertexShape = function(c, x, y, w, h) {
    var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var buttonColor = mxUtils.getValue(this.style, mxShapeMockupVideoPlayer.prototype.cst.FILL_COLOR2, "#c4c4c4");
    var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#666666");
    var filledColor = mxUtils.getValue(this.style, mxShapeMockupVideoPlayer.prototype.cst.STROKE_COLOR2, "#008cff");
    var emptyColor = mxUtils.getValue(this.style, mxShapeMockupVideoPlayer.prototype.cst.STROKE_COLOR3, "#c4c4c4");
    var barHeight = mxUtils.getValue(this.style, mxShapeMockupVideoPlayer.prototype.cst.BAR_HEIGHT, "30");
    w = Math.max(w, 5 * barHeight);
    h = Math.max(h, barHeight + 10);
    c.translate(x, y);
    this.background(c, x, y, w, h, bgColor, frameColor);
    c.setShadow(false);
    this.otherShapes(c, x, y, w, h, buttonColor, frameColor, filledColor, emptyColor, barHeight)
}
;
mxShapeMockupVideoPlayer.prototype.background = function(c, x, y, w, h, bgColor, frameColor) {
    c.setFillColor(bgColor);
    c.setStrokeColor(frameColor);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeMockupVideoPlayer.prototype.otherShapes = function(c, x, y, w, h, buttonColor, frameColor, filledColor, emptyColor, barHeight) {
    var barPos = mxUtils.getValue(this.style, mxShapeMockupVideoPlayer.prototype.cst.BAR_POS, "20");
    barPos = Math.max(0, barPos);
    barPos = Math.min(100, barPos);
    var strokeWidth = mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, "1");
    var buttonR = 8;
    var barY = h - barHeight;
    var barMin = buttonR;
    var barMax = w - buttonR;
    var barRange = barMax - barMin;
    var realBarPos = barRange * barPos / 100;
    var barEnd = barMin + realBarPos;
    c.setStrokeColor(filledColor);
    c.begin();
    c.moveTo(0, barY);
    c.lineTo(barEnd, barY);
    c.stroke();
    c.setStrokeColor(emptyColor);
    c.begin();
    c.moveTo(barEnd, barY);
    c.lineTo(w, barY);
    c.stroke();
    c.setStrokeColor(frameColor);
    c.begin();
    c.ellipse(barEnd - buttonR, barY - buttonR, 2 * buttonR, 2 * buttonR);
    c.fillAndStroke();
    c.begin();
    c.setStrokeWidth(strokeWidth / 2);
    c.ellipse(barEnd - buttonR * .5, barY - buttonR * .5, buttonR, buttonR);
    c.fillAndStroke();
    c.setStrokeWidth(strokeWidth);
    var iconSize = barHeight * .3;
    var iconY = h - (barHeight + iconSize) * .5;
    var iconX = barHeight * .3;
    c.setFillColor(buttonColor);
    c.setStrokeColor(buttonColor);
    c.begin();
    c.moveTo(iconX, iconY);
    c.lineTo(iconX + iconSize, iconY + iconSize * .5);
    c.lineTo(iconX, iconY + iconSize);
    c.close();
    c.fillAndStroke();
    var speakerX = barHeight;
    var speakerY = h - barHeight;
    c.moveTo(speakerX + barHeight * .05, speakerY + barHeight * .4);
    c.lineTo(speakerX + barHeight * .15, speakerY + barHeight * .4);
    c.lineTo(speakerX + barHeight * .3, speakerY + barHeight * .25);
    c.lineTo(speakerX + barHeight * .3, speakerY + barHeight * .75);
    c.lineTo(speakerX + barHeight * .15, speakerY + barHeight * .6);
    c.lineTo(speakerX + barHeight * .05, speakerY + barHeight * .6);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(speakerX + barHeight * .4, speakerY + barHeight * .35);
    c.arcTo(barHeight * .2, barHeight * .3, 0, 0, 1, speakerX + barHeight * .4, speakerY + barHeight * .65);
    c.moveTo(speakerX + barHeight * .425, speakerY + barHeight * .25);
    c.arcTo(barHeight * .225, barHeight * .35, 0, 0, 1, speakerX + barHeight * .425, speakerY + barHeight * .75);
    c.stroke();
    var screenX = w - barHeight * 1.3;
    c.begin();
    c.moveTo(screenX + barHeight * .1, speakerY + barHeight * .4);
    c.lineTo(screenX + barHeight * .1, speakerY + barHeight * .3);
    c.lineTo(screenX + barHeight * .25, speakerY + barHeight * .3);
    c.moveTo(screenX + barHeight * .1, speakerY + barHeight * .6);
    c.lineTo(screenX + barHeight * .1, speakerY + barHeight * .7);
    c.lineTo(screenX + barHeight * .25, speakerY + barHeight * .7);
    c.moveTo(screenX + barHeight * .9, speakerY + barHeight * .4);
    c.lineTo(screenX + barHeight * .9, speakerY + barHeight * .3);
    c.lineTo(screenX + barHeight * .75, speakerY + barHeight * .3);
    c.moveTo(screenX + barHeight * .9, speakerY + barHeight * .6);
    c.lineTo(screenX + barHeight * .9, speakerY + barHeight * .7);
    c.lineTo(screenX + barHeight * .75, speakerY + barHeight * .7);
    c.stroke();
    var textColor = mxUtils.getValue(this.style, mxShapeMockupVideoPlayer.prototype.cst.TEXT_COLOR, "#666666");
    c.begin();
    c.setFontSize(barHeight * .5);
    c.setFontColor(textColor);
    c.text(barHeight * 1.9, h - barHeight * .45, 0, 0, "0:00/3:53", mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxShapeMockupVideoPlayer.prototype.cst.SHAPE_VIDEO_PLAYER, mxShapeMockupVideoPlayer);
Graph.handleFactory[mxShapeMockupVideoPlayer.prototype.cst.SHAPE_VIDEO_PLAYER] = function(state) {
    var handles = [Graph.createHandle(state, ["barPos"], function(bounds) {
        var barPos = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, "barPos", this.barPos))));
        var barH = parseFloat(mxUtils.getValue(this.state.style, "barHeight", this.barHeight));
        return new mxPoint(bounds.x + (bounds.width - 16) * barPos / bounds.width / 100 * bounds.width + 8,bounds.y + bounds.height - barH - 20)
    }, function(bounds, pt) {
        this.state.style["barPos"] = Math.round(1E3 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 1E3
    })];
    var handle2 = Graph.createHandle(state, ["barHeight"], function(bounds) {
        var barHeight = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, "barHeight", this.barHeight))));
        return new mxPoint(bounds.x + bounds.width - 20,bounds.y + bounds.height - barHeight)
    }, function(bounds, pt) {
        this.state.style["barHeight"] = Math.round(1E3 * Math.max(0, Math.min(bounds.height, bounds.y + bounds.height - pt.y))) / 1E3
    });
    handles.push(handle2);
    return handles
}
;
function mxShapeMockupAccordion(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupAccordion, mxShape);
mxShapeMockupAccordion.prototype.cst = {
    TEXT_COLOR: "textColor",
    TEXT_COLOR2: "textColor2",
    TEXT_SIZE: "textSize",
    SHAPE_ACCORDION: "mxgraph.mockup.containers.accordion",
    STROKE_COLOR2: "strokeColor2",
    FILL_COLOR2: "fillColor2",
    SELECTED: "+",
    MAIN_TEXT: "mainText"
};
mxShapeMockupAccordion.prototype.paintVertexShape = function(c, x, y, w, h) {
    var textStrings = mxUtils.getValue(this.style, mxShapeMockupAccordion.prototype.cst.MAIN_TEXT, "+Group 1, Group 2, Group 3").toString().split(",");
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupAccordion.prototype.cst.TEXT_COLOR, "#666666");
    var selectedFontColor = mxUtils.getValue(this.style, mxShapeMockupAccordion.prototype.cst.TEXT_COLOR2, "#ffffff");
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupAccordion.prototype.cst.TEXT_SIZE, "17").toString();
    var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#666666");
    var separatorColor = mxUtils.getValue(this.style, mxShapeMockupAccordion.prototype.cst.STROKE_COLOR2, "#c4c4c4");
    var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var selectedFillColor = mxUtils.getValue(this.style, mxShapeMockupAccordion.prototype.cst.FILL_COLOR2, "#008cff");
    var buttonNum = textStrings.length;
    var maxButtonWidth = 0;
    var selectedButton = -1;
    var rSize = 10;
    var labelOffset = 5;
    for (var i = 0; i < buttonNum; i++) {
        var buttonText = textStrings[i];
        if (buttonText.charAt(0) === mxShapeMockupAccordion.prototype.cst.SELECTED) {
            buttonText = textStrings[i].substring(1);
            selectedButton = i
        }
        var currWidth = mxUtils.getSizeForString(buttonText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
        if (currWidth > maxButtonWidth)
            maxButtonWidth = currWidth
    }
    var minButtonHeight = fontSize * 1.5;
    var minH = buttonNum * minButtonHeight;
    var trueH = Math.max(h, minH);
    var minW = 2 * labelOffset + maxButtonWidth;
    var trueW = Math.max(w, minW);
    c.translate(x, y);
    this.background(c, trueW, trueH, rSize, buttonNum, labelOffset, buttonNum * minButtonHeight, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton, minButtonHeight);
    c.setShadow(false);
    var currWidth = 0;
    for (var i = 0; i < buttonNum; i++) {
        if (i === selectedButton)
            c.setFontColor(selectedFontColor);
        else
            c.setFontColor(fontColor);
        currWidth = currWidth + labelOffset;
        var currHeight = 0;
        if (selectedButton === -1 || i <= selectedButton)
            currHeight = i * minButtonHeight + minButtonHeight * .5;
        else
            currHeight = trueH - (buttonNum - i - .5) * minButtonHeight;
        this.buttonText(c, trueW, currHeight, textStrings[i], fontSize)
    }
}
;
mxShapeMockupAccordion.prototype.background = function(c, w, h, rSize, buttonNum, labelOffset, minH, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton, minButtonHeight) {
    c.begin();
    c.setStrokeColor(frameColor);
    c.setFillColor(bgColor);
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke();
    c.setStrokeColor(separatorColor);
    c.begin();
    for (var i = 1; i < buttonNum; i++)
        if (i !== selectedButton)
            if (selectedButton === -1 || i < selectedButton) {
                var currHeight = i * minButtonHeight;
                c.moveTo(0, currHeight);
                c.lineTo(w, currHeight)
            } else {
                var currHeight = h - (buttonNum - i) * minButtonHeight;
                c.moveTo(0, currHeight);
                c.lineTo(w, currHeight)
            }
    c.stroke();
    c.setStrokeColor(mxConstants.NONE);
    c.setFillColor(selectedFillColor);
    if (selectedButton !== -1) {
        c.begin();
        var buttonTop = minButtonHeight * selectedButton;
        var buttonBottom = minButtonHeight * (selectedButton + 1);
        c.moveTo(0, buttonTop);
        c.lineTo(w, buttonTop);
        c.lineTo(w, buttonBottom);
        c.lineTo(0, buttonBottom);
        c.close();
        c.fill()
    }
    c.begin();
    c.setStrokeColor(frameColor);
    c.setFillColor(bgColor);
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.stroke()
}
;
mxShapeMockupAccordion.prototype.buttonText = function(c, w, h, textString, fontSize) {
    if (textString.charAt(0) === mxShapeMockupAccordion.prototype.cst.SELECTED)
        textString = textString.substring(1);
    c.begin();
    c.setFontSize(fontSize);
    c.text(w * .5, h, 0, 0, textString, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxShapeMockupAccordion.prototype.cst.SHAPE_ACCORDION, mxShapeMockupAccordion);
function mxShapeMockupBrowserWindow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupBrowserWindow, mxShape);
mxShapeMockupBrowserWindow.prototype.cst = {
    STROKE_COLOR2: "strokeColor2",
    STROKE_COLOR3: "strokeColor3",
    MAIN_TEXT: "mainText",
    SHAPE_BROWSER_WINDOW: "mxgraph.mockup.containers.browserWindow"
};
mxShapeMockupBrowserWindow.prototype.paintVertexShape = function(c, x, y, w, h) {
    var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#666666");
    var closeColor = mxUtils.getValue(this.style, mxShapeMockupBrowserWindow.prototype.cst.STROKE_COLOR2, "#008cff");
    var insideColor = mxUtils.getValue(this.style, mxShapeMockupBrowserWindow.prototype.cst.STROKE_COLOR3, "#c4c4c4");
    w = Math.max(w, 260);
    h = Math.max(h, 110);
    c.translate(x, y);
    this.background(c, x, y, w, h, bgColor, frameColor);
    c.setShadow(false);
    this.otherShapes(c, x, y, w, h, frameColor, insideColor, closeColor)
}
;
mxShapeMockupBrowserWindow.prototype.background = function(c, x, y, w, h, bgColor, frameColor) {
    c.setFillColor(bgColor);
    c.setStrokeColor(frameColor);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeMockupBrowserWindow.prototype.otherShapes = function(c, x, y, w, h, frameColor, insideColor, closeColor) {
    var strokeWidth = mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, "1");
    var mainText = mxUtils.getValue(this.style, mxShapeMockupBrowserWindow.prototype.cst.MAIN_TEXT, "http://www.draw.io,Page 1").toString().split(",");
    c.setStrokeColor(frameColor);
    c.ellipse(w - 75, 5, 20, 20);
    c.stroke();
    c.ellipse(w - 50, 5, 20, 20);
    c.stroke();
    c.setStrokeColor(closeColor);
    c.ellipse(w - 25, 5, 20, 20);
    c.stroke();
    c.setStrokeColor(insideColor);
    c.begin();
    c.moveTo(0, 40);
    c.lineTo(30, 40);
    c.lineTo(30, 15);
    c.arcTo(5, 5, 0, 0, 1, 35, 10);
    c.lineTo(170, 10);
    c.arcTo(5, 5, 0, 0, 1, 175, 15);
    c.lineTo(175, 40);
    c.lineTo(w, 40);
    c.stroke();
    c.begin();
    c.moveTo(0, 110);
    c.lineTo(w, 110);
    c.stroke();
    c.begin();
    c.moveTo(100, 60);
    c.arcTo(5, 5, 0, 0, 1, 105, 55);
    c.lineTo(w - 15, 55);
    c.arcTo(5, 5, 0, 0, 1, w - 10, 60);
    c.lineTo(w - 10, 85);
    c.arcTo(5, 5, 0, 0, 1, w - 15, 90);
    c.lineTo(105, 90);
    c.arcTo(5, 5, 0, 0, 1, 100, 85);
    c.close();
    c.stroke();
    var textColor = mxUtils.getValue(this.style, mxShapeMockupBrowserWindow.prototype.cst.TEXT_COLOR, "#666666");
    c.setFontColor(textColor);
    c.setFontSize(17);
    c.text(65, 25, 0, 0, mainText[1], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(130, 73, 0, 0, mainText[0], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.stroke();
    c.translate(37, 17);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(11, 0);
    c.lineTo(15, 4);
    c.lineTo(15, 18);
    c.lineTo(0, 18);
    c.close();
    c.stroke();
    c.setStrokeWidth(strokeWidth * .5);
    c.begin();
    c.moveTo(11, 0);
    c.lineTo(11, 4);
    c.lineTo(15, 5);
    c.stroke();
    c.setStrokeWidth(strokeWidth * 2);
    c.translate(70, 47);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(11, 0);
    c.lineTo(15, 4);
    c.lineTo(15, 18);
    c.lineTo(0, 18);
    c.close();
    c.stroke();
    c.setStrokeWidth(strokeWidth * .5);
    c.begin();
    c.moveTo(11, 0);
    c.lineTo(11, 4);
    c.lineTo(15, 5);
    c.stroke();
    var iSi = 20;
    c.setFillColor(insideColor);
    c.begin();
    c.setStrokeWidth(strokeWidth * 2);
    c.translate(-95, 0);
    c.moveTo(0, iSi * .5);
    c.lineTo(iSi * .5, 0);
    c.lineTo(iSi * .5, iSi * .3);
    c.lineTo(iSi, iSi * .3);
    c.lineTo(iSi, iSi * .7);
    c.lineTo(iSi * .5, iSi * .7);
    c.lineTo(iSi * .5, iSi);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.translate(30, 0);
    c.moveTo(iSi, iSi * .5);
    c.lineTo(iSi * .5, 0);
    c.lineTo(iSi * .5, iSi * .3);
    c.lineTo(0, iSi * .3);
    c.lineTo(0, iSi * .7);
    c.lineTo(iSi * .5, iSi * .7);
    c.lineTo(iSi * .5, iSi);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.translate(30, 0);
    c.moveTo(iSi * .78, iSi * .665);
    c.arcTo(iSi * .3, iSi * .3, 0, 1, 1, iSi * .675, iSi * .252);
    c.lineTo(iSi * .595, iSi * .325);
    c.lineTo(iSi * .99, iSi * .415);
    c.lineTo(iSi * .9, iSi * .04);
    c.lineTo(iSi * .815, iSi * .12);
    c.arcTo(iSi * .49, iSi * .49, 0, 1, 0, iSi * .92, iSi * .8);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupBrowserWindow.prototype.cst.SHAPE_BROWSER_WINDOW, mxShapeMockupBrowserWindow);
function mxShapeMockupUserMale(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupUserMale, mxShape);
mxShapeMockupUserMale.prototype.cst = {
    STROKE_COLOR2: "strokeColor2",
    SHAPE_MALE_USER: "mxgraph.mockup.containers.userMale"
};
mxShapeMockupUserMale.prototype.paintVertexShape = function(c, x, y, w, h) {
    var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#666666");
    var insideColor = mxUtils.getValue(this.style, mxShapeMockupUserMale.prototype.cst.STROKE_COLOR2, "#008cff");
    c.translate(x, y);
    this.background(c, x, y, w, h, bgColor, frameColor);
    c.setShadow(false);
    this.otherShapes(c, x, y, w, h, insideColor, frameColor)
}
;
mxShapeMockupUserMale.prototype.background = function(c, x, y, w, h, bgColor, frameColor) {
    c.setFillColor(bgColor);
    c.setStrokeColor(frameColor);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeMockupUserMale.prototype.otherShapes = function(c, x, y, w, h, insideColor, frameColor) {
    c.setStrokeColor(insideColor);
    c.setLineCap("round");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(w * .5, h * .6721);
    c.curveTo(w * .3891, h * .6721, w * .31, h * .5648, w * .31, h * .3962);
    c.curveTo(w * .31, h * .3656, w * .3012, h * .3473, w * .3051, h * .3227);
    c.curveTo(w * .3126, h * .2762, w * .3124, h * .2212, w * .332, h * .1939);
    c.curveTo(w * .354, h * .1633, w * .4382, h * .12, w * .5, h * .12);
    c.stroke();
    c.begin();
    c.moveTo(w * .3046, h * .3716);
    c.curveTo(w * .3046, h * .3716, w * .3046, h * .341, w * .2826, h * .3594);
    c.curveTo(w * .2606, h * .3778, w * .2661, h * .4452, w * .266, h * .4452);
    c.quadTo(w * .2715, h * .4942, w * .277, h * .5065);
    c.curveTo(w * .2825, h * .5187, w * .277, h * .5187, w * .2935, h * .5371);
    c.curveTo(w * .31, h * .5554, w * .3375, h * .5615, w * .3375, h * .5616);
    c.stroke();
    c.begin();
    c.moveTo(w * .3829, h * .6213);
    c.curveTo(w * .3829, h * .6213, w * .405, h * .7704, w * .2921, h * .7888);
    c.curveTo(w * .2536, h * .795, w * .1328, h * .85, w * .1052, h * .8745);
    c.curveTo(w * .0776, h * .899, w * .0641, h * .9316, w * .0571, h * .9622);
    c.quadTo(w * .05, h, w * .05, h);
    c.stroke();
    c.begin();
    c.moveTo(w * .3427, h * .4185);
    c.curveTo(w * .3427, h * .4185, w * .3427, h * .3839, w * .3427, h * .3593);
    c.curveTo(w * .3427, h * .3348, w * .3663, h * .3103, w * .3718, h * .3041);
    c.curveTo(w * .3773, h * .298, w * .3822, h * .2673, w * .3877, h * .2551);
    c.curveTo(w * .3932, h * .2429, w * .4095, h * .2429, w * .4259, h * .2367);
    c.curveTo(w * .4424, h * .2306, w * .4984, h * .2357, w * .4984, h * .2357);
    c.stroke();
    c.begin();
    c.moveTo(w * .365, h * .7427);
    c.curveTo(w * .365, h * .7427, w * .3772, h * .8076, w * .4286, h * .8224);
    c.curveTo(w * .4816, h * .8377, w * .5028, h * .8347, w * .5028, h * .8347);
    c.stroke();
    c.begin();
    c.moveTo(w * .3322, h * .7764);
    c.curveTo(w * .3322, h * .7764, w * .3556, h * .8386, w * .4038, h * .8684);
    c.curveTo(w * .4533, h * .8991, w * .5029, h * .8929, w * .5029, h * .8929);
    c.stroke();
    c.begin();
    c.moveTo(w * .2717, h * .9);
    c.lineTo(w * .2717, h);
    c.stroke();
    c.begin();
    c.moveTo(w * .1671, h * .8991);
    c.curveTo(w * .1671, h * .8991, w * .1726, h * .9114, w * .1836, h * .9481);
    c.curveTo(w * .1946, h * .9849, w * .2, h, w * .2, h);
    c.stroke();
    c.begin();
    c.moveTo(w * .5, h * .6721);
    c.curveTo(w * .6109, h * .6721, w * .69, h * .5648, w * .69, h * .3962);
    c.curveTo(w * .69, h * .3656, w * .6988, h * .3473, w * .6949, h * .3227);
    c.curveTo(w * .6847, h * .2762, w * .6876, h * .2212, w * .668, h * .1939);
    c.curveTo(w * .646, h * .1633, w * .5618, h * .12, w * .5, h * .12);
    c.stroke();
    c.begin();
    c.moveTo(w * .6954, h * .3716);
    c.curveTo(w * .6954, h * .3716, w * .6954, h * .341, w * .7174, h * .3594);
    c.curveTo(w * .7394, h * .3778, w * .7339, h * .4452, w * .734, h * .4452);
    c.quadTo(w * .7285, h * .4942, w * .723, h * .5065);
    c.curveTo(w * .7175, h * .5187, w * .723, h * .5187, w * .7065, h * .5371);
    c.curveTo(w * .69, h * .5554, w * .6625, h * .5615, w * .6625, h * .5616);
    c.stroke();
    c.begin();
    c.moveTo(w * .6171, h * .6213);
    c.curveTo(w * .6171, h * .6213, w * .595, h * .7704, w * .7079, h * .7888);
    c.curveTo(w * .7464, h * .795, w * .8672, h * .85, w * .8948, h * .8745);
    c.curveTo(w * .9224, h * .899, w * .9359, h * .9316, w * .9429, h * .9622);
    c.quadTo(w * .95, h, w * .95, h);
    c.stroke();
    c.begin();
    c.moveTo(w * .6573, h * .4185);
    c.curveTo(w * .6573, h * .4185, w * .6573, h * .3839, w * .6573, h * .3593);
    c.curveTo(w * .6573, h * .3348, w * .6337, h * .3103, w * .6282, h * .3041);
    c.curveTo(w * .6227, h * .298, w * .6178, h * .2673, w * .6123, h * .2551);
    c.curveTo(w * .6068, h * .2429, w * .5905, h * .2429, w * .5741, h * .2367);
    c.curveTo(w * .5576, h * .2306, w * .5016, h * .2357, w * .5016, h * .2357);
    c.stroke();
    c.begin();
    c.moveTo(w * .635, h * .7427);
    c.curveTo(w * .635, h * .7427, w * .6228, h * .8076, w * .5714, h * .8224);
    c.curveTo(w * .5184, h * .8377, w * .4972, h * .8347, w * .4972, h * .8347);
    c.stroke();
    c.begin();
    c.moveTo(w * .6678, h * .7764);
    c.curveTo(w * .6678, h * .7764, w * .6444, h * .8386, w * .5962, h * .8684);
    c.curveTo(w * .5467, h * .8991, w * .4971, h * .8929, w * .4971, h * .8929);
    c.stroke();
    c.begin();
    c.moveTo(w * .7283, h * .9);
    c.lineTo(w * .7283, h);
    c.stroke();
    c.begin();
    c.moveTo(w * .8329, h * .8991);
    c.curveTo(w * .8329, h * .8991, w * .8274, h * .9114, w * .8164, h * .9481);
    c.curveTo(w * .8054, h * .9849, w * .8, h, w * .8, h);
    c.stroke();
    c.setStrokeColor(frameColor);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupUserMale.prototype.cst.SHAPE_MALE_USER, mxShapeMockupUserMale);
function mxShapeMockupUserFemale(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupUserFemale, mxShape);
mxShapeMockupUserFemale.prototype.cst = {
    STROKE_COLOR2: "strokeColor2",
    SHAPE_FEMALE_USER: "mxgraph.mockup.containers.userFemale"
};
mxShapeMockupUserFemale.prototype.paintVertexShape = function(c, x, y, w, h) {
    var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#666666");
    var insideColor = mxUtils.getValue(this.style, mxShapeMockupUserFemale.prototype.cst.STROKE_COLOR2, "#008cff");
    c.translate(x, y);
    this.background(c, x, y, w, h, bgColor, frameColor);
    c.setShadow(false);
    this.otherShapes(c, x, y, w, h, insideColor, frameColor)
}
;
mxShapeMockupUserFemale.prototype.background = function(c, x, y, w, h, bgColor, frameColor) {
    c.setFillColor(bgColor);
    c.setStrokeColor(frameColor);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeMockupUserFemale.prototype.otherShapes = function(c, x, y, w, h, insideColor, frameColor) {
    c.setStrokeColor(insideColor);
    c.setLineCap("round");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(w * .3148, h * .468);
    c.curveTo(w * .3045, h * .3195, w * .3176, h * .2383, w * .3302, h * .2069);
    c.curveTo(w * .3508, h * .1557, w * .44, h * .1156, w * .5026, h * .1156);
    c.stroke();
    c.begin();
    c.moveTo(w * .5029, h * .6728);
    c.curveTo(w * .4616, h * .6728, w * .4018, h * .6177, w * .3663, h * .5653);
    c.stroke();
    c.begin();
    c.moveTo(w * .3108, h * .4021);
    c.curveTo(w * .3108, h * .4021, w * .3091, h * .3765, w * .2891, h * .3933);
    c.curveTo(w * .2691, h * .4101, w * .2782, h * .4661, w * .2782, h * .4661);
    c.quadTo(w * .2862, h * .5067, w * .2922, h * .5166);
    c.curveTo(w * .2982, h * .5265, w * .2929, h * .5268, w * .3097, h * .5412);
    c.stroke();
    c.begin();
    c.moveTo(w * .4038, h * .6176);
    c.curveTo(w * .4038, h * .6176, w * .4324, h * .7778, w * .3375, h * .7963);
    c.curveTo(w * .3054, h * .8026, w * .1753, h * .8578, w * .15, h * .8826);
    c.curveTo(w * .1247, h * .9074, w * .1126, h * .9412, w * .1063, h * .9722);
    c.curveTo(w * .1, h * 1.0032, w * .1, h, w * .1, h);
    c.stroke();
    c.begin();
    c.moveTo(w * .6377, h * .3365);
    c.curveTo(w * .5927, h * .2634, w * .5206, h * .2634, w * .5206, h * .2634);
    c.quadTo(w * .3769, h * .2591, w * .3713, h * .2659);
    c.curveTo(w * .3657, h * .2727, w * .3405, h * .3674, w * .3405, h * .3946);
    c.curveTo(w * .3405, h * .4218, w * .3405, h * .4602, w * .3405, h * .4602);
    c.quadTo(w * .3546, h * .6401, w * .3546, h * .6626);
    c.stroke();
    c.begin();
    c.moveTo(w * .2931, h * .818);
    c.curveTo(w * .2931, h * .818, w * .3224, h * .9159, w * .3826, h * .9677);
    c.curveTo(w * .4446, h * 1.01, w * .5065, h, w * .5065, h);
    c.stroke();
    c.begin();
    c.moveTo(w * .2995, h * .9106);
    c.lineTo(w * .2995, h);
    c.stroke();
    c.begin();
    c.moveTo(w * .2081, h * .907);
    c.curveTo(w * .2081, h * .907, w * .2131, h * .9194, w * .2232, h * .9565);
    c.curveTo(w * .2333, h * .9936, w * .24, h, w * .24, h);
    c.stroke();
    c.begin();
    c.moveTo(w * .6951, h * .4988);
    c.curveTo(w * .6951, h * .4662, w * .7042, h * .3453, w * .7, h * .32);
    c.curveTo(w * .6923, h * .273, w * .6926, h * .2175, w * .6727, h * .19);
    c.curveTo(w * .6504, h * .159, w * .5651, h * .1157, w * .5025, h * .1157);
    c.stroke();
    c.begin();
    c.moveTo(w * .5029, h * .6728);
    c.curveTo(w * .5546, h * .6728, w * .6107, h * .6316, w * .6461, h * .5602);
    c.stroke();
    c.begin();
    c.moveTo(w * .696, h * .4022);
    c.curveTo(w * .696, h * .4022, w * .6983, h * .3766, w * .7179, h * .4106);
    c.curveTo(w * .7375, h * .4278, w * .7273, h * .4836, w * .7273, h * .4836);
    c.quadTo(w * .7184, h * .5241, w * .7123, h * .5338);
    c.curveTo(w * .7062, h * .5436, w * .7114, h * .544, w * .6943, h * .558);
    c.stroke();
    c.begin();
    c.moveTo(w * .5995, h * .6278);
    c.curveTo(w * .5995, h * .6278, w * .5724, h * .7777, w * .6663, h * .7963);
    c.curveTo(w * .6984, h * .8026, w * .8386, h * .8578, w * .8638, h * .8826);
    c.curveTo(w * .8891, h * .9074, w * .9016, h * .9412, w * .9079, h * .9722);
    c.curveTo(w * .9142, h * 1.0032, w * .91, h, w * .91, h);
    c.stroke();
    c.begin();
    c.moveTo(w * .6545, h * .6802);
    c.lineTo(w * .6545, h * .3986);
    c.stroke();
    c.begin();
    c.moveTo(w * .7132, h * .8078);
    c.curveTo(w * .7132, h * .8078, w * .6839, h * .916, w * .6237, h * .9678);
    c.curveTo(w * .5617, h * 1.01, w * .4998, h, w * .4998, h);
    c.stroke();
    c.begin();
    c.moveTo(w * .7111, h * .9106);
    c.lineTo(w * .7111, h);
    c.stroke();
    c.begin();
    c.moveTo(w * .8075, h * .907);
    c.curveTo(w * .8075, h * .907, w * .8025, h * .9194, w * .7924, h * .9565);
    c.curveTo(w * .7823, h * .9936, w * .775, h, w * .775, h);
    c.stroke();
    c.begin();
    c.moveTo(w * .3148, h * .5448);
    c.curveTo(w * .3148, h * .5448, w * .32, h * .6216, w * .3148, h * .6677);
    c.quadTo(w * .2891, h * .7343, w * .2891, h * .7343);
    c.lineTo(w * .3303, h * .7625);
    c.lineTo(w * .39, h * .7625);
    c.stroke();
    c.begin();
    c.moveTo(w * .6852, h * .5448);
    c.curveTo(w * .6852, h * .5448, w * .68, h * .6216, w * .6852, h * .6677);
    c.quadTo(w * .7109, h * .7343, w * .7109, h * .7343);
    c.lineTo(w * .6697, h * .7625);
    c.lineTo(w * .62, h * .7625);
    c.stroke();
    c.setStrokeColor(frameColor);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupUserFemale.prototype.cst.SHAPE_FEMALE_USER, mxShapeMockupUserFemale);
function mxShapeMockupGroup(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupGroup, mxShape);
mxShapeMockupGroup.prototype.cst = {
    MAIN_TEXT: "mainText",
    TEXT_SIZE: "textSize",
    TEXT_COLOR: "textColor",
    FILL_COLOR2: "fillColor2",
    SHAPE_GROUP: "mxgraph.mockup.containers.group"
};
mxShapeMockupGroup.prototype.paintVertexShape = function(c, x, y, w, h) {
    var groupString = mxUtils.getValue(this.style, mxShapeMockupGroup.prototype.cst.MAIN_TEXT, "Group").toString();
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupGroup.prototype.cst.TEXT_SIZE, "17");
    var textWidth = mxUtils.getSizeForString(groupString, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
    if (textWidth === 0)
        textWidth = Math.max(80, textWidth);
    c.translate(x, y);
    w = Math.max(w, textWidth + 15);
    h = Math.max(h, fontSize + 10);
    this.background(c, w, h, textWidth, fontSize);
    c.setShadow(false);
    this.foreground(c, w, h, textWidth, fontSize);
    this.buttonText(c, w, h, groupString, fontSize)
}
;
mxShapeMockupGroup.prototype.background = function(c, w, h, textWidth, fontSize) {
    c.roundrect(0, fontSize * .5, w, h - fontSize * .5, 5, 5);
    c.fillAndStroke()
}
;
mxShapeMockupGroup.prototype.foreground = function(c, w, h, textWidth, fontSize) {
    var fillColor = mxUtils.getValue(this.style, mxShapeMockupGroup.prototype.cst.FILL_COLOR2, "#000000");
    c.setFillColor(fillColor);
    c.roundrect(3, 0, textWidth + 6, fontSize * 1.5, fontSize * .25, fontSize * .25);
    c.fill()
}
;
mxShapeMockupGroup.prototype.buttonText = function(c, w, h, textString, fontSize) {
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupGroup.prototype.cst.TEXT_COLOR, "#ffffff");
    c.setFontColor(fontColor);
    c.setFontSize(fontSize);
    c.text(6, 0, 0, 0, textString, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_TOP, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxShapeMockupGroup.prototype.cst.SHAPE_GROUP, mxShapeMockupGroup);
function mxShapeMockupWindow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupWindow, mxShape);
mxShapeMockupWindow.prototype.cst = {
    MAIN_TEXT: "mainText",
    TEXT_SIZE: "textSize",
    TEXT_COLOR: "textColor",
    STROKE_COLOR2: "strokeColor2",
    STROKE_COLOR3: "strokeColor3",
    SHAPE_WINDOW: "mxgraph.mockup.containers.window"
};
mxShapeMockupWindow.prototype.paintVertexShape = function(c, x, y, w, h) {
    var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#666666");
    var closeColor = mxUtils.getValue(this.style, mxShapeMockupWindow.prototype.cst.STROKE_COLOR2, "#008cff");
    var insideColor = mxUtils.getValue(this.style, mxShapeMockupWindow.prototype.cst.STROKE_COLOR3, "#c4c4c4");
    c.translate(x, y);
    h = Math.max(h, 30);
    w = Math.max(w, 90);
    this.background(c, x, y, w, h, bgColor, frameColor);
    c.setShadow(false);
    this.otherShapes(c, x, y, w, h, frameColor, insideColor, closeColor)
}
;
mxShapeMockupWindow.prototype.background = function(c, x, y, w, h, bgColor, frameColor) {
    c.setFillColor(bgColor);
    c.setStrokeColor(frameColor);
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupWindow.prototype.otherShapes = function(c, x, y, w, h, frameColor, insideColor, closeColor) {
    var strokeWidth = mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, "1");
    c.setStrokeColor(frameColor);
    c.ellipse(w - 75, 5, 20, 20);
    c.stroke();
    c.ellipse(w - 50, 5, 20, 20);
    c.stroke();
    c.setStrokeColor(closeColor);
    c.ellipse(w - 25, 5, 20, 20);
    c.stroke();
    c.setStrokeColor(insideColor);
    c.begin();
    c.moveTo(0, 30);
    c.lineTo(w, 30);
    c.stroke();
    var windowTitle = mxUtils.getValue(this.style, mxShapeMockupWindow.prototype.cst.MAIN_TEXT, "Window Title");
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupWindow.prototype.cst.TEXT_COLOR, "#666666");
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupWindow.prototype.cst.TEXT_SIZE, "17").toString();
    c.setFontColor(fontColor);
    c.setFontSize(fontSize);
    c.text(10, 15, 0, 0, windowTitle, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupWindow.prototype.cst.SHAPE_WINDOW, mxShapeMockupWindow);
function mxShapeMockupHorTabBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupHorTabBar, mxShape);
mxShapeMockupHorTabBar.prototype.cst = {
    BLOCK: "block",
    CONE: "cone",
    HALF_CONE: "halfCone",
    ROUND: "round",
    TEXT_SIZE: "textSize",
    TAB_NAMES: "tabs",
    TAB_STYLE: "tabStyle",
    STYLE_FILLCOLOR2: "fillColor2",
    TEXT_COLOR: "textColor",
    SEL_TEXT_COLOR: "textColor2",
    SHAPE_HOR_TAB_BAR: "mxgraph.mockup.containers.horTabBar"
};
mxShapeMockupHorTabBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupHorTabBar.prototype.cst.TEXT_SIZE, "17").toString();
    var tabNames = mxUtils.getValue(this.style, mxShapeMockupHorTabBar.prototype.cst.TAB_NAMES, "Tab 1,+Tab 2,Tab 3").toString().split(",");
    var tabH = fontSize * 1.5;
    var startOffset = 10;
    var tabOffset = 5;
    var labelOffset = 10;
    var tabCount = tabNames.length;
    var minW = 2 * startOffset + (tabCount - 1) * tabOffset + tabCount * 2 * labelOffset;
    var rSize = 5;
    var labelWidths = new Array;
    var selectedTab = -1;
    for (var i = 0; i < tabCount; i++) {
        var currLabel = tabNames[i];
        if (currLabel.charAt(0) === "+") {
            currLabel = currLabel.substring(1);
            selectedTab = i
        }
        currW = mxUtils.getSizeForString(currLabel, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
        if (currW === 0)
            labelWidths[i] = 40;
        else
            labelWidths[i] = currW;
        minW = minW + labelWidths[i]
    }
    w = Math.max(w, minW);
    h = Math.max(h, tabH + rSize);
    c.translate(x, y);
    this.background(c, w, h, rSize, tabH);
    c.setShadow(false);
    this.backTabs(c, w, h, rSize, tabH, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab);
    this.focusTab(c, w, h, rSize, tabH, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab);
    this.tabText(c, w, h, rSize, tabH, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab, tabNames)
}
;
mxShapeMockupHorTabBar.prototype.background = function(c, w, h, rSize, tabH) {
    c.begin();
    c.moveTo(0, tabH + rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, tabH);
    c.lineTo(w - rSize, tabH);
    c.arcTo(rSize, rSize, 0, 0, 1, w, tabH + rSize);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeMockupHorTabBar.prototype.backTabs = function(c, w, h, rSize, tabH, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab) {
    var tabStyle = mxUtils.getValue(this.style, mxShapeMockupHorTabBar.prototype.cst.TAB_STYLE, mxShapeMockupHorTabBar.prototype.cst.BLOCK);
    var currW = startOffset;
    for (var i = 0; i < tabCount; i++) {
        var tabW = labelWidths[i] + 2 * labelOffset;
        if (selectedTab !== i) {
            if (tabStyle === mxShapeMockupHorTabBar.prototype.cst.BLOCK)
                c.rect(currW, 0, tabW, tabH);
            else if (tabStyle === mxShapeMockupHorTabBar.prototype.cst.CONE) {
                c.begin();
                c.moveTo(currW, tabH);
                c.lineTo(currW + labelOffset * .5, 0);
                c.lineTo(currW + tabW - labelOffset * .5, 0);
                c.lineTo(currW + tabW, tabH)
            } else if (tabStyle === mxShapeMockupHorTabBar.prototype.cst.HALF_CONE) {
                c.begin();
                c.moveTo(currW, tabH);
                c.lineTo(currW + labelOffset * .5, 0);
                c.lineTo(currW + tabW, 0);
                c.lineTo(currW + tabW, tabH)
            } else if (tabStyle === mxShapeMockupHorTabBar.prototype.cst.ROUND) {
                c.begin();
                c.moveTo(currW - rSize, tabH);
                c.arcTo(rSize, rSize, 0, 0, 0, currW, tabH - rSize);
                c.lineTo(currW, rSize);
                c.arcTo(rSize, rSize, 0, 0, 1, currW + rSize, 0);
                c.lineTo(currW + tabW - rSize, 0);
                c.arcTo(rSize, rSize, 0, 0, 1, currW + tabW, rSize);
                c.lineTo(currW + tabW, tabH - rSize);
                c.arcTo(rSize, rSize, 0, 0, 0, currW + tabW + rSize, tabH)
            }
            c.fillAndStroke()
        }
        currW = currW + tabW + tabOffset
    }
}
;
mxShapeMockupHorTabBar.prototype.focusTab = function(c, w, h, rSize, tabH, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab) {
    var tabStyle = mxUtils.getValue(this.style, mxShapeMockupHorTabBar.prototype.cst.TAB_STYLE, mxShapeMockupHorTabBar.prototype.cst.BLOCK);
    var selectedFill = mxUtils.getValue(this.style, mxShapeMockupHorTabBar.prototype.cst.STYLE_FILLCOLOR2, "#008cff");
    var currW = startOffset;
    c.setStrokeColor(selectedFill);
    c.setFillColor(selectedFill);
    for (var i = 0; i <= selectedTab; i++) {
        var tabW = labelWidths[i] + 2 * labelOffset;
        if (selectedTab === i) {
            if (tabStyle === mxShapeMockupHorTabBar.prototype.cst.BLOCK) {
                c.begin();
                c.moveTo(0, tabH + rSize);
                c.arcTo(rSize, rSize, 0, 0, 1, rSize, tabH);
                c.lineTo(currW, tabH);
                c.lineTo(currW, 0);
                c.lineTo(currW + tabW, 0);
                c.lineTo(currW + tabW, tabH);
                c.lineTo(w - rSize, tabH);
                c.arcTo(rSize, rSize, 0, 0, 1, w, tabH + rSize);
                c.close()
            } else if (tabStyle === mxShapeMockupHorTabBar.prototype.cst.CONE) {
                c.begin();
                c.moveTo(0, tabH + rSize);
                c.arcTo(rSize, rSize, 0, 0, 1, rSize, tabH);
                c.lineTo(currW, tabH);
                c.lineTo(currW + labelOffset * .5, 0);
                c.lineTo(currW + tabW - labelOffset * .5, 0);
                c.lineTo(currW + tabW, tabH);
                c.lineTo(w - rSize, tabH);
                c.arcTo(rSize, rSize, 0, 0, 1, w, tabH + rSize);
                c.close()
            } else if (tabStyle === mxShapeMockupHorTabBar.prototype.cst.HALF_CONE) {
                c.begin();
                c.moveTo(0, tabH + rSize);
                c.arcTo(rSize, rSize, 0, 0, 1, rSize, tabH);
                c.lineTo(currW, tabH);
                c.lineTo(currW + labelOffset * .5, 0);
                c.lineTo(currW + tabW, 0);
                c.lineTo(currW + tabW, tabH);
                c.lineTo(w - rSize, tabH);
                c.arcTo(rSize, rSize, 0, 0, 1, w, tabH + rSize);
                c.close()
            } else if (tabStyle === mxShapeMockupHorTabBar.prototype.cst.ROUND) {
                c.begin();
                c.moveTo(0, tabH + rSize);
                c.arcTo(rSize, rSize, 0, 0, 1, rSize, tabH);
                c.lineTo(currW - rSize, tabH);
                c.arcTo(rSize, rSize, 0, 0, 0, currW, tabH - rSize);
                c.lineTo(currW, rSize);
                c.arcTo(rSize, rSize, 0, 0, 1, currW + rSize, 0);
                c.lineTo(currW + tabW - rSize, 0);
                c.arcTo(rSize, rSize, 0, 0, 1, currW + tabW, rSize);
                c.lineTo(currW + tabW, tabH - rSize);
                c.arcTo(rSize, rSize, 0, 0, 0, currW + tabW + rSize, tabH);
                c.lineTo(w - rSize, tabH);
                c.arcTo(rSize, rSize, 0, 0, 1, w, tabH + rSize);
                c.close()
            }
            c.fillAndStroke()
        }
        currW = currW + tabW + tabOffset
    }
}
;
mxShapeMockupHorTabBar.prototype.tabText = function(c, w, h, rSize, tabH, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab, tabNames) {
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupHorTabBar.prototype.cst.TEXT_COLOR, "#666666");
    var selFontColor = mxUtils.getValue(this.style, mxShapeMockupHorTabBar.prototype.cst.SEL_TEXT_COLOR, "#ffffff");
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupHorTabBar.prototype.cst.TEXT_SIZE, "17").toString();
    c.setFontColor(fontColor);
    c.setFontSize(fontSize);
    var currW = startOffset;
    for (var i = 0; i < tabCount; i++) {
        var currLabel = tabNames[i];
        if (i === selectedTab)
            c.setFontColor(selFontColor);
        if (currLabel.charAt(0) === "+")
            currLabel = currLabel.substring(1);
        var tabW = labelWidths[i] + 2 * labelOffset;
        c.text(currW + labelOffset, tabH * .5, 0, 0, currLabel, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
        currW = currW + tabW + tabOffset;
        if (i === selectedTab)
            c.setFontColor(fontColor)
    }
}
;
mxCellRenderer.registerShape(mxShapeMockupHorTabBar.prototype.cst.SHAPE_HOR_TAB_BAR, mxShapeMockupHorTabBar);
function mxShapeMockupVerTabBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupVerTabBar, mxShape);
mxShapeMockupVerTabBar.prototype.cst = {
    BLOCK: "block",
    ROUND: "round",
    TEXT_SIZE: "textSize",
    TAB_NAMES: "tabs",
    TAB_STYLE: "tabStyle",
    STYLE_FILLCOLOR2: "fillColor2",
    TEXT_COLOR: "textColor",
    SEL_TEXT_COLOR: "textColor2",
    SHAPE_VER_TAB_BAR: "mxgraph.mockup.containers.verTabBar"
};
mxShapeMockupVerTabBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupVerTabBar.prototype.cst.TEXT_SIZE, "17").toString();
    var tabNames = mxUtils.getValue(this.style, mxShapeMockupVerTabBar.prototype.cst.TAB_NAMES, "Tab 1,+Tab 2,Tab 3").toString().split(",");
    var tabH = fontSize * 1.5;
    var startOffset = 10;
    var tabOffset = 5;
    var labelOffset = 10;
    var tabCount = tabNames.length;
    var rSize = 5;
    var labelWidths = new Array;
    var selectedTab = -1;
    for (var i = 0; i < tabCount; i++) {
        var currLabel = tabNames[i];
        if (currLabel.charAt(0) === "+") {
            currLabel = currLabel.substring(1);
            selectedTab = i
        }
        var currW = mxUtils.getSizeForString(currLabel, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
        if (currW === 0)
            labelWidths[i] = 42;
        else
            labelWidths[i] = currW
    }
    var tabW = 2 * labelOffset + Math.max.apply(Math, labelWidths);
    var minW = tabW + rSize;
    w = Math.max(w, minW);
    h = Math.max(h, 2 * startOffset + tabCount * tabH + (tabCount - 1) * tabOffset);
    c.translate(x, y);
    this.background(c, w, h, rSize, tabW);
    c.setShadow(false);
    this.backTabs(c, w, h, rSize, tabH, tabW, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab);
    this.focusTab(c, w, h, rSize, tabH, tabW, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab);
    this.tabText(c, w, h, rSize, tabH, tabW, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab, tabNames)
}
;
mxShapeMockupVerTabBar.prototype.background = function(c, w, h, rSize, tabW) {
    c.begin();
    c.moveTo(tabW + rSize, h);
    c.arcTo(rSize, rSize, 0, 0, 1, tabW, h - rSize);
    c.lineTo(tabW, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, tabW + rSize, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeMockupVerTabBar.prototype.backTabs = function(c, w, h, rSize, tabH, tabW, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab) {
    var tabStyle = mxUtils.getValue(this.style, mxShapeMockupVerTabBar.prototype.cst.TAB_STYLE, mxShapeMockupVerTabBar.prototype.cst.BLOCK);
    var currH = startOffset;
    for (var i = 0; i < tabCount; i++) {
        if (selectedTab !== i) {
            if (tabStyle === mxShapeMockupVerTabBar.prototype.cst.BLOCK)
                c.rect(0, currH, tabW, tabH);
            else if (tabStyle === mxShapeMockupVerTabBar.prototype.cst.ROUND) {
                c.begin();
                c.moveTo(tabW, currH + tabH + rSize);
                c.arcTo(rSize, rSize, 0, 0, 0, tabW - rSize, currH + tabH);
                c.lineTo(rSize, currH + tabH);
                c.arcTo(rSize, rSize, 0, 0, 1, 0, currH + tabH - rSize);
                c.lineTo(0, currH + rSize);
                c.arcTo(rSize, rSize, 0, 0, 1, rSize, currH);
                c.lineTo(tabW - rSize, currH);
                c.arcTo(rSize, rSize, 0, 0, 0, tabW, currH - rSize)
            }
            c.fillAndStroke()
        }
        currH = currH + tabH + tabOffset
    }
}
;
mxShapeMockupVerTabBar.prototype.focusTab = function(c, w, h, rSize, tabH, tabW, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab) {
    var tabStyle = mxUtils.getValue(this.style, mxShapeMockupVerTabBar.prototype.cst.TAB_STYLE, mxShapeMockupVerTabBar.prototype.cst.BLOCK);
    var selectedFill = mxUtils.getValue(this.style, mxShapeMockupVerTabBar.prototype.cst.STYLE_FILLCOLOR2, "#008cff");
    if (selectedTab !== -1) {
        var currH = startOffset + (tabH + tabOffset) * selectedTab;
        c.setStrokeColor(selectedFill);
        c.setFillColor(selectedFill);
        if (tabStyle === mxShapeMockupVerTabBar.prototype.cst.BLOCK) {
            c.begin();
            c.moveTo(tabW + rSize, h);
            c.arcTo(rSize, rSize, 0, 0, 1, tabW, h - rSize);
            c.lineTo(tabW, currH + tabH);
            c.lineTo(0, currH + tabH);
            c.lineTo(0, currH);
            c.lineTo(tabW, currH);
            c.lineTo(tabW, rSize);
            c.arcTo(rSize, rSize, 0, 0, 1, tabW + rSize, 0);
            c.close()
        } else if (tabStyle === mxShapeMockupVerTabBar.prototype.cst.ROUND) {
            c.begin();
            c.moveTo(tabW + rSize, h);
            c.arcTo(rSize, rSize, 0, 0, 1, tabW, h - rSize);
            c.lineTo(tabW, currH + tabH + rSize);
            c.arcTo(rSize, rSize, 0, 0, 0, tabW - rSize, currH + tabH);
            c.lineTo(rSize, currH + tabH);
            c.arcTo(rSize, rSize, 0, 0, 1, 0, currH + tabH - rSize);
            c.lineTo(0, currH + rSize);
            c.arcTo(rSize, rSize, 0, 0, 1, rSize, currH);
            c.lineTo(tabW - rSize, currH);
            c.arcTo(rSize, rSize, 0, 0, 0, tabW, currH - rSize);
            c.lineTo(tabW, rSize);
            c.arcTo(rSize, rSize, 0, 0, 1, tabW + rSize, 0);
            c.close()
        }
        c.fillAndStroke()
    }
}
;
mxShapeMockupVerTabBar.prototype.tabText = function(c, w, h, rSize, tabH, tabW, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab, tabNames) {
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupVerTabBar.prototype.cst.TEXT_COLOR, "#666666");
    var selFontColor = mxUtils.getValue(this.style, mxShapeMockupVerTabBar.prototype.cst.SEL_TEXT_COLOR, "#ffffff");
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupVerTabBar.prototype.cst.TEXT_SIZE, "17").toString();
    c.setFontColor(fontColor);
    c.setFontSize(fontSize);
    var currH = startOffset;
    for (var i = 0; i < tabCount; i++) {
        var currLabel = tabNames[i];
        if (i === selectedTab)
            c.setFontColor(selFontColor);
        if (currLabel.charAt(0) === "+")
            currLabel = currLabel.substring(1);
        c.text(tabW * .5, currH + tabH * .5, 0, 0, currLabel, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
        currH = currH + tabH + tabOffset;
        if (i === selectedTab)
            c.setFontColor(fontColor)
    }
}
;
mxCellRenderer.registerShape(mxShapeMockupVerTabBar.prototype.cst.SHAPE_VER_TAB_BAR, mxShapeMockupVerTabBar);
function mxShapeMockupAlertBox(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupAlertBox, mxShape);
mxShapeMockupAlertBox.prototype.cst = {
    MAIN_TEXT: "mainText",
    SUB_TEXT: "subText",
    BUTTON_TEXT: "buttonText",
    TEXT_SIZE: "textSize",
    TEXT_COLOR: "textColor",
    STROKE_COLOR2: "strokeColor2",
    STROKE_COLOR3: "strokeColor3",
    SHAPE_ALERT_BOX: "mxgraph.mockup.containers.alertBox"
};
mxShapeMockupAlertBox.prototype.paintVertexShape = function(c, x, y, w, h) {
    var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#666666");
    var closeColor = mxUtils.getValue(this.style, mxShapeMockupAlertBox.prototype.cst.STROKE_COLOR2, "#008cff");
    var insideColor = mxUtils.getValue(this.style, mxShapeMockupAlertBox.prototype.cst.STROKE_COLOR3, "#c4c4c4");
    c.translate(x, y);
    h = Math.max(h, 75);
    w = Math.max(w, 90);
    this.background(c, x, y, w, h, bgColor, frameColor);
    c.setShadow(false);
    this.foreground(c, x, y, w, h, frameColor, insideColor, closeColor)
}
;
mxShapeMockupAlertBox.prototype.background = function(c, x, y, w, h, bgColor, frameColor) {
    c.setFillColor(bgColor);
    c.setStrokeColor(frameColor);
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupAlertBox.prototype.foreground = function(c, x, y, w, h, frameColor, insideColor, closeColor) {
    var strokeWidth = mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, "1");
    c.setStrokeColor(closeColor);
    c.ellipse(w - 25, 5, 20, 20);
    c.stroke();
    c.setStrokeColor(insideColor);
    c.begin();
    c.moveTo(0, 30);
    c.lineTo(w, 30);
    c.stroke();
    var windowTitle = mxUtils.getValue(this.style, mxShapeMockupAlertBox.prototype.cst.MAIN_TEXT, "Window Title").toString();
    var subText = mxUtils.getValue(this.style, mxShapeMockupAlertBox.prototype.cst.SUB_TEXT, "Sub Text").toString().split(",");
    var buttonText = mxUtils.getValue(this.style, mxShapeMockupAlertBox.prototype.cst.BUTTON_TEXT, "OK,Cancel").toString().split(",");
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupAlertBox.prototype.cst.TEXT_COLOR, "#666666");
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupAlertBox.prototype.cst.TEXT_SIZE, "17").toString();
    var buttonCount = buttonText.length;
    var buttonOffset = 10;
    var buttonW = (w - buttonOffset * (buttonCount + 1)) / buttonCount;
    c.setFontColor(fontColor);
    c.setFontSize(fontSize);
    c.text(10, 15, 0, 0, windowTitle, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    var currW = buttonOffset;
    for (var i = 0; i < buttonText.length; i++) {
        if (buttonText[i] !== "") {
            c.rect(currW, h - 10 - fontSize * 1.5, buttonW, fontSize * 1.5);
            c.stroke();
            c.text(currW + buttonW * .5, h - 10 - fontSize * .75, 0, 0, buttonText[i], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
        }
        currW = currW + buttonW + buttonOffset
    }
    for (var i = 0; i < subText.length; i++)
        c.text(w * .5, 30 + fontSize * (i * 1.5 + .75), 0, 0, subText[i], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupAlertBox.prototype.cst.SHAPE_ALERT_BOX, mxShapeMockupAlertBox);
function mxShapeMockupContainersRRect(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupContainersRRect, mxShape);
mxShapeMockupContainersRRect.prototype.cst = {
    RRECT: "mxgraph.mockup.containers.rrect",
    R_SIZE: "rSize"
};
mxShapeMockupContainersRRect.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupContainersRRect.prototype.cst.R_SIZE, "10"));
    c.roundrect(0, 0, w, h, rSize);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupContainersRRect.prototype.cst.RRECT, mxShapeMockupContainersRRect);
function mxShapeMockupContainersAnchor(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds
}
mxUtils.extend(mxShapeMockupContainersAnchor, mxShape);
mxShapeMockupContainersAnchor.prototype.cst = {
    ANCHOR: "mxgraph.mockup.containers.anchor"
};
mxShapeMockupContainersAnchor.prototype.paintVertexShape = function(c, x, y, w, h) {}
;
mxCellRenderer.registerShape(mxShapeMockupContainersAnchor.prototype.cst.ANCHOR, mxShapeMockupContainersAnchor);
function mxShapeMockupContrainersTopButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupContrainersTopButton, mxShape);
mxShapeMockupContrainersTopButton.prototype.cst = {
    TOP_BUTTON: "mxgraph.mockup.containers.topButton",
    R_SIZE: "rSize"
};
mxShapeMockupContrainersTopButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupContrainersTopButton.prototype.cst.R_SIZE, "10"));
    c.begin();
    c.moveTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupContrainersTopButton.prototype.cst.TOP_BUTTON, mxShapeMockupContrainersTopButton);
function mxShapeMockupContainersLeftButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupContainersLeftButton, mxShape);
mxShapeMockupContainersLeftButton.prototype.cst = {
    LEFT_BUTTON: "mxgraph.mockup.containers.leftButton",
    R_SIZE: "rSize"
};
mxShapeMockupContainersLeftButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupContainersLeftButton.prototype.cst.R_SIZE, "10"));
    c.begin();
    c.moveTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(rSize, h);
    c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
    c.lineTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupContainersLeftButton.prototype.cst.LEFT_BUTTON, mxShapeMockupContainersLeftButton);
function mxShapeMockupContainersMarginRect(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupContainersMarginRect, mxShape);
mxShapeMockupContainersMarginRect.prototype.cst = {
    SHAPE_MARGIN_RECT: "mxgraph.mockup.containers.marginRect",
    MARGIN: "rectMargin",
    MARGIN_TOP: "rectMarginTop",
    MARGIN_LEFT: "rectMarginLeft",
    MARGIN_BOTTOM: "rectMarginBottom",
    MARGIN_RIGHT: "rectMarginRight"
};
mxShapeMockupContainersMarginRect.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h)
}
;
mxShapeMockupContainersMarginRect.prototype.background = function(c, x, y, w, h, state) {
    var margin = parseFloat(mxUtils.getValue(this.style, mxShapeMockupContainersMarginRect.prototype.cst.MARGIN, "0"));
    var marginTop = parseFloat(mxUtils.getValue(this.style, mxShapeMockupContainersMarginRect.prototype.cst.MARGIN_TOP, "0"));
    var marginLeft = parseFloat(mxUtils.getValue(this.style, mxShapeMockupContainersMarginRect.prototype.cst.MARGIN_LEFT, "0"));
    var marginBottom = parseFloat(mxUtils.getValue(this.style, mxShapeMockupContainersMarginRect.prototype.cst.MARGIN_BOTTOM, "0"));
    var marginRight = parseFloat(mxUtils.getValue(this.style, mxShapeMockupContainersMarginRect.prototype.cst.MARGIN_RIGHT, "0"));
    var x1 = margin + marginLeft;
    var y1 = margin + marginTop;
    var w1 = w - marginRight - x1 - margin;
    var h1 = h - marginBottom - y1 - margin;
    if (w1 > 0 && h1 > 0) {
        c.begin();
        c.roundrect(x1, y1, w1, h1, 10, 10);
        c.fillAndStroke()
    }
}
;
mxCellRenderer.registerShape(mxShapeMockupContainersMarginRect.prototype.cst.SHAPE_MARGIN_RECT, mxShapeMockupContainersMarginRect);
function mxShapeMockupContainersMarginRect2(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupContainersMarginRect2, mxShape);
mxShapeMockupContainersMarginRect2.prototype.cst = {
    SHAPE_MARGIN_RECT: "mxgraph.mockup.containers.marginRect2",
    MARGIN: "rectMargin",
    MARGIN_TOP: "rectMarginTop",
    MARGIN_LEFT: "rectMarginLeft",
    MARGIN_BOTTOM: "rectMarginBottom",
    MARGIN_RIGHT: "rectMarginRight"
};
mxShapeMockupContainersMarginRect2.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h)
}
;
mxShapeMockupContainersMarginRect2.prototype.background = function(c, x, y, w, h, state) {
    var margin = parseFloat(mxUtils.getValue(this.style, mxShapeMockupContainersMarginRect2.prototype.cst.MARGIN, "0"));
    var marginTop = parseFloat(mxUtils.getValue(this.style, mxShapeMockupContainersMarginRect2.prototype.cst.MARGIN_TOP, "0"));
    var marginLeft = parseFloat(mxUtils.getValue(this.style, mxShapeMockupContainersMarginRect2.prototype.cst.MARGIN_LEFT, "0"));
    var marginBottom = parseFloat(mxUtils.getValue(this.style, mxShapeMockupContainersMarginRect2.prototype.cst.MARGIN_BOTTOM, "0"));
    var marginRight = parseFloat(mxUtils.getValue(this.style, mxShapeMockupContainersMarginRect2.prototype.cst.MARGIN_RIGHT, "0"));
    var x1 = margin + marginLeft;
    var y1 = margin + marginTop;
    var w1 = w - marginRight - x1 - margin;
    var h1 = h - marginBottom - y1 - margin;
    if (w1 > 0 && h1 > 0) {
        c.begin();
        c.rect(x1, y1, w1, h1);
        c.fillAndStroke()
    }
}
;
mxCellRenderer.registerShape(mxShapeMockupContainersMarginRect2.prototype.cst.SHAPE_MARGIN_RECT, mxShapeMockupContainersMarginRect2);
function mxShapeMockupCheckboxGroup(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupCheckboxGroup, mxShape);
mxShapeMockupCheckboxGroup.prototype.cst = {
    MAIN_TEXT: "mainText",
    TEXT_SIZE: "textSize",
    TEXT_COLOR: "textColor",
    SELECTED: "+",
    SHAPE_CHECKBOX_GROUP: "mxgraph.mockup.forms.checkboxGroup"
};
mxShapeMockupCheckboxGroup.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupCheckboxGroup.prototype.cst.TEXT_COLOR, "#666666,#008cff").toString().split(",");
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupCheckboxGroup.prototype.cst.TEXT_SIZE, "17").toString();
    var optionText = mxUtils.getValue(this.style, mxShapeMockupCheckboxGroup.prototype.cst.MAIN_TEXT, "Option 1").toString().split(",");
    var optionNum = optionText.length;
    var buttonSize = 15;
    var lineH = Math.max(fontSize * 1.5, buttonSize);
    var maxTextWidth = 0;
    var selected = -1;
    var labelOffset = 2.5;
    var minH = optionNum * lineH;
    var trueH = Math.max(h, minH);
    for (var i = 0; i < optionNum; i++) {
        var currText = optionText[i];
        if (currText.charAt(0) === mxShapeMockupCheckboxGroup.prototype.cst.SELECTED) {
            currText = optionText[i].substring(1);
            selected = i
        }
        var currWidth = mxUtils.getSizeForString(currText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
        if (currWidth > maxTextWidth)
            maxTextWidth = currWidth
    }
    var minW = 2 * labelOffset + maxTextWidth + 2 * buttonSize;
    var trueW = Math.max(w, minW);
    c.rect(0, 0, trueW, trueH);
    c.fillAndStroke();
    c.setShadow(false);
    c.setFontSize(fontSize);
    for (var i = 0; i < optionNum; i++) {
        var currHeight = (i * lineH + lineH * .5) * trueH / minH;
        var currText = optionText[i];
        if (currText.charAt(0) === mxShapeMockupCheckboxGroup.prototype.cst.SELECTED) {
            c.setFontColor(fontColor[1]);
            currText = optionText[i].substring(1);
            selected = i
        } else
            c.setFontColor(fontColor[0]);
        c.text(buttonSize * 2 + labelOffset, currHeight, 0, 0, currText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
        var iconX = buttonSize * .5;
        var iconY = currHeight - buttonSize * .5;
        c.setFillColor("#dddddd");
        c.setStrokeColor("#999999");
        if (selected === i) {
            c.setGradient("#aaaaaa", "#666666", iconX, iconY, buttonSize, buttonSize, mxConstants.DIRECTION_SOUTH, 1, 1);
            c.rect(iconX, iconY, buttonSize, buttonSize);
            c.fillAndStroke();
            c.setStrokeColor("#333333");
            c.begin();
            c.moveTo(iconX + buttonSize * .25, iconY + buttonSize * .5);
            c.lineTo(iconX + buttonSize * .5, iconY + buttonSize * .75);
            c.lineTo(iconX + buttonSize * .75, iconY + buttonSize * .25);
            c.stroke()
        } else {
            c.setGradient("#eeeeee", "#cccccc", iconX, iconY, buttonSize, buttonSize, mxConstants.DIRECTION_SOUTH, 1, 1);
            c.rect(iconX, iconY, buttonSize, buttonSize);
            c.fillAndStroke()
        }
        selected = -1
    }
}
;
mxCellRenderer.registerShape(mxShapeMockupCheckboxGroup.prototype.cst.SHAPE_CHECKBOX_GROUP, mxShapeMockupCheckboxGroup);
function mxShapeMockupRadioGroup(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupRadioGroup, mxShape);
mxShapeMockupRadioGroup.prototype.cst = {
    MAIN_TEXT: "mainText",
    TEXT_SIZE: "textSize",
    TEXT_COLOR: "textColor",
    SELECTED: "+",
    SHAPE_RADIO_GROUP: "mxgraph.mockup.forms.radioGroup"
};
mxShapeMockupRadioGroup.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupRadioGroup.prototype.cst.TEXT_COLOR, "#666666,#008cff").toString().split(",");
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupRadioGroup.prototype.cst.TEXT_SIZE, "17").toString();
    var optionText = mxUtils.getValue(this.style, mxShapeMockupRadioGroup.prototype.cst.MAIN_TEXT, "Option 1").toString().split(",");
    var optionNum = optionText.length;
    var buttonSize = 15;
    var lineH = Math.max(fontSize * 1.5, buttonSize);
    var maxTextWidth = 0;
    var selected = -1;
    var labelOffset = 2.5;
    var minH = optionNum * lineH;
    var trueH = Math.max(h, minH);
    for (var i = 0; i < optionNum; i++) {
        var currText = optionText[i];
        if (currText.charAt(0) === mxShapeMockupRadioGroup.prototype.cst.SELECTED) {
            currText = optionText[i].substring(1);
            selected = i
        }
        var currWidth = mxUtils.getSizeForString(currText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
        if (currWidth > maxTextWidth)
            maxTextWidth = currWidth
    }
    var minW = 2 * labelOffset + maxTextWidth + 2 * buttonSize;
    var trueW = Math.max(w, minW);
    c.rect(0, 0, trueW, trueH);
    c.fillAndStroke();
    c.setShadow(false);
    c.setFontSize(fontSize);
    for (var i = 0; i < optionNum; i++) {
        var currHeight = (i * lineH + lineH * .5) * trueH / minH;
        var currText = optionText[i];
        if (currText.charAt(0) === mxShapeMockupRadioGroup.prototype.cst.SELECTED) {
            c.setFontColor(fontColor[1]);
            currText = optionText[i].substring(1);
            selected = i
        } else
            c.setFontColor(fontColor[0]);
        c.text(buttonSize * 2 + labelOffset, currHeight, 0, 0, currText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
        var iconX = buttonSize * .5;
        var iconY = currHeight - buttonSize * .5;
        c.setStrokeColor("#999999");
        if (selected === i) {
            c.setGradient("#aaaaaa", "#666666", iconX, iconY, buttonSize, buttonSize, mxConstants.DIRECTION_SOUTH, 1, 1);
            c.ellipse(iconX, iconY, buttonSize, buttonSize);
            c.fillAndStroke();
            c.setFillColor("#333333");
            c.setStrokeColor("#333333");
            c.ellipse(iconX + buttonSize * .25, iconY + buttonSize * .25, buttonSize * .5, buttonSize * .5);
            c.fillAndStroke()
        } else {
            c.setGradient("#eeeeee", "#cccccc", iconX, iconY, buttonSize, buttonSize, mxConstants.DIRECTION_SOUTH, 1, 1);
            c.ellipse(iconX, iconY, buttonSize, buttonSize);
            c.fillAndStroke()
        }
    }
}
;
mxCellRenderer.registerShape(mxShapeMockupRadioGroup.prototype.cst.SHAPE_RADIO_GROUP, mxShapeMockupRadioGroup);
function mxShapeMockupColorPicker(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupColorPicker, mxShape);
mxShapeMockupColorPicker.prototype.cst = {
    COLOR: "chosenColor",
    SHAPE_COLOR_PICKER: "mxgraph.mockup.forms.colorPicker"
};
mxShapeMockupColorPicker.prototype.paintVertexShape = function(c, x, y, w, h) {
    var chosenColor = mxUtils.getValue(this.style, mxShapeMockupColorPicker.prototype.cst.COLOR, "#aaddff");
    c.translate(x, y);
    c.setStrokeColor("#999999");
    c.roundrect(0, 0, w, h, w * .05, h * .05);
    c.fillAndStroke();
    c.setShadow(false);
    c.setFillColor(chosenColor);
    c.rect(w * .1, h * .1, w * .8, h * .8);
    c.fill();
    c.setFillColor("#ffffff");
    c.begin();
    c.moveTo(w * .75, h * .75);
    c.lineTo(w * .75, h);
    c.lineTo(w * .95, h);
    c.arcTo(w * .05, h * .05, 0, 0, 0, w, h * .95);
    c.lineTo(w, h * .75);
    c.close();
    c.fill();
    c.setFillColor("#999999");
    c.begin();
    c.moveTo(w * .77, h * .77);
    c.lineTo(w * .875, h * .98);
    c.lineTo(w * .98, h * .77);
    c.close();
    c.fill();
    c.roundrect(0, 0, w, h, w * .05, h * .05);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupColorPicker.prototype.cst.SHAPE_COLOR_PICKER, mxShapeMockupColorPicker);
function mxShapeMockupComboBox(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupComboBox, mxShape);
mxShapeMockupComboBox.prototype.cst = {
    MAIN_TEXT: "mainText",
    FILL_COLOR2: "fillColor2",
    TEXT_COLOR: "textColor",
    TEXT_SIZE: "textSize",
    SHAPE_COMBO_BOX: "mxgraph.mockup.forms.comboBox"
};
mxShapeMockupComboBox.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h);
    this.mainText(c, x, y, w, h)
}
;
mxShapeMockupComboBox.prototype.background = function(c, x, y, w, h) {
    c.setFillColor("#ffffff");
    c.roundrect(0, 0, w, h, 5, 5);
    c.fillAndStroke()
}
;
mxShapeMockupComboBox.prototype.foreground = function(c, x, y, w, h) {
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "").toString();
    var fillColor2 = mxUtils.getValue(this.style, mxShapeMockupComboBox.prototype.cst.FILL_COLOR2, "").toString();
    c.setGradient(fillColor, fillColor2, w - 30, 0, 30, h, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.begin();
    c.moveTo(w - 30, 0);
    c.lineTo(w - 5, 0);
    c.arcTo(5, 5, 0, 0, 1, w, 5);
    c.lineTo(w, h - 5);
    c.arcTo(5, 5, 0, 0, 1, w - 5, h);
    c.lineTo(w - 30, h);
    c.close();
    c.fillAndStroke();
    c.setFillColor("#ffffff");
    c.begin();
    c.moveTo(w - 22, h * .5 - 5);
    c.lineTo(w - 15, h * .5 + 5);
    c.lineTo(w - 8, h * .5 - 5);
    c.fill()
}
;
mxShapeMockupComboBox.prototype.mainText = function(c, x, y, w, h) {
    var mainText = mxUtils.getValue(this.style, mxShapeMockupComboBox.prototype.cst.MAIN_TEXT, "Main Text");
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupComboBox.prototype.cst.TEXT_COLOR, "#666666").toString();
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupComboBox.prototype.cst.TEXT_SIZE, "17").toString();
    c.begin();
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    c.text(5, h * .5, 0, 0, mainText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxShapeMockupComboBox.prototype.cst.SHAPE_COMBO_BOX, mxShapeMockupComboBox);
function mxShapeMockupSpinner(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupSpinner, mxShape);
mxShapeMockupSpinner.prototype.cst = {
    LAYOUT: "spinLayout",
    SPINNER_STYLE: "spinStyle",
    ADJ_STYLE: "adjStyle",
    LAYOUT_RIGHT: "right",
    LAYOUT_LEFT: "left",
    LAYOUT_TOP: "top",
    LAYOUT_BOTTOM: "bottom",
    LAYOUT_VERTICAL: "vertical",
    LAYOUT_HORIZONTAL: "horizontal",
    SPINNER_MERGED: "merged",
    SPINNER_NORMAL: "normal",
    ADJ_TRIANGLE: "triangle",
    ADJ_PLUSMINUS: "plusMinus",
    ADJ_ARROW: "arrow",
    MAIN_TEXT: "mainText",
    FILL_COLOR2: "fillColor2",
    TEXT_COLOR: "textColor",
    TEXT_SIZE: "textSize",
    SHAPE_SPINNER: "mxgraph.mockup.forms.spinner"
};
mxShapeMockupSpinner.prototype.paintVertexShape = function(c, x, y, w, h) {
    var spinnerLayout = mxUtils.getValue(this.style, mxShapeMockupSpinner.prototype.cst.LAYOUT, mxShapeMockupSpinner.prototype.cst.LAYOUT_RIGHT);
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h, spinnerLayout);
    this.mainText(c, w, h, spinnerLayout)
}
;
mxShapeMockupSpinner.prototype.background = function(c, w, h) {
    c.setFillColor("#ffffff");
    c.roundrect(0, 0, w, h, 10, 10);
    c.fillAndStroke()
}
;
mxShapeMockupSpinner.prototype.foreground = function(c, w, h, spinnerLayout) {
    var spinnerStyle = mxUtils.getValue(this.style, mxShapeMockupSpinner.prototype.cst.SPINNER_STYLE, mxShapeMockupSpinner.prototype.cst.SPINNER_NORMAL);
    var adjStyle = mxUtils.getValue(this.style, mxShapeMockupSpinner.prototype.cst.ADJ_STYLE, mxShapeMockupSpinner.prototype.cst.ADJ_TRIANGLE);
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    c.setFillColor(fillColor);
    if (spinnerStyle === mxShapeMockupSpinner.prototype.cst.SPINNER_NORMAL)
        if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_RIGHT) {
            c.begin();
            c.moveTo(w - 20, 0);
            c.lineTo(w - 20, h);
            c.moveTo(w - 20, h * .5);
            c.lineTo(w, h * .5);
            c.stroke()
        } else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_LEFT) {
            c.begin();
            c.moveTo(20, 0);
            c.lineTo(20, h);
            c.moveTo(20, h * .5);
            c.lineTo(0, h * .5);
            c.stroke()
        } else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_TOP) {
            c.begin();
            c.moveTo(0, 15);
            c.lineTo(w, 15);
            c.moveTo(w * .5, 15);
            c.lineTo(w * .5, 0);
            c.stroke()
        } else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_BOTTOM) {
            c.begin();
            c.moveTo(0, h - 15);
            c.lineTo(w, h - 15);
            c.moveTo(w * .5, h - 15);
            c.lineTo(w * .5, h);
            c.stroke()
        } else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_VERTICAL) {
            c.begin();
            c.moveTo(0, 15);
            c.lineTo(w, 15);
            c.moveTo(0, h - 15);
            c.lineTo(w, h - 15);
            c.stroke()
        } else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_HORIZONTAL) {
            c.begin();
            c.moveTo(20, 0);
            c.lineTo(20, h);
            c.moveTo(w - 20, 0);
            c.lineTo(w - 20, h);
            c.stroke()
        }
    c.setStrokeColor(fillColor);
    if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_RIGHT)
        if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_TRIANGLE) {
            c.begin();
            c.moveTo(w - 14, h * .25 + 4.5);
            c.lineTo(w - 10, h * .25 - 2.5);
            c.lineTo(w - 6, h * .25 + 4.5);
            c.close();
            c.fillAndStroke()
        } else if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_PLUSMINUS) {
            c.begin();
            c.moveTo(w - 10, h * .25 - 4);
            c.lineTo(w - 10, h * .25 + 4);
            c.moveTo(w - 14, h * .25);
            c.lineTo(w - 6, h * .25);
            c.stroke()
        } else {
            if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_ARROW) {
                c.begin();
                c.moveTo(w - 14, h * .25 + 1.5);
                c.lineTo(w - 10, h * .25 - 2.5);
                c.lineTo(w - 6, h * .25 + 1.5);
                c.close();
                c.moveTo(w - 10, h * .25 + 4.5);
                c.lineTo(w - 10, h * .25 - 2.5);
                c.fillAndStroke()
            }
        }
    else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_LEFT)
        if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_TRIANGLE) {
            c.begin();
            c.moveTo(14, h * .25 + 4.5);
            c.lineTo(10, h * .25 - 2.5);
            c.lineTo(6, h * .25 + 4.5);
            c.close();
            c.fillAndStroke()
        } else if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_PLUSMINUS) {
            c.begin();
            c.moveTo(10, h * .25 - 4);
            c.lineTo(10, h * .25 + 4);
            c.moveTo(14, h * .25);
            c.lineTo(6, h * .25);
            c.stroke()
        } else {
            if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_ARROW) {
                c.begin();
                c.moveTo(14, h * .25 + 1.5);
                c.lineTo(10, h * .25 - 2.5);
                c.lineTo(6, h * .25 + 1.5);
                c.close();
                c.moveTo(10, h * .25 + 4.5);
                c.lineTo(10, h * .25 - 2.5);
                c.fillAndStroke()
            }
        }
    else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_TOP)
        if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_TRIANGLE) {
            c.begin();
            c.moveTo(w * .75 + 4, 12);
            c.lineTo(w * .75, 5);
            c.lineTo(w * .75 - 4, 12);
            c.close();
            c.fillAndStroke()
        } else if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_PLUSMINUS) {
            c.begin();
            c.moveTo(w * .75, 3.5);
            c.lineTo(w * .75, 11.5);
            c.moveTo(w * .75 + 4, 7.5);
            c.lineTo(w * .75 - 4, 7.5);
            c.stroke()
        } else {
            if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_ARROW) {
                c.begin();
                c.moveTo(w * .75 + 4, 9);
                c.lineTo(w * .75, 5);
                c.lineTo(w * .75 - 4, 9);
                c.close();
                c.moveTo(w * .75, 12);
                c.lineTo(w * .75, 5);
                c.fillAndStroke()
            }
        }
    else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_BOTTOM)
        if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_TRIANGLE) {
            c.begin();
            c.moveTo(w * .75 + 4, h - 5);
            c.lineTo(w * .75, h - 12);
            c.lineTo(w * .75 - 4, h - 5);
            c.close();
            c.fillAndStroke()
        } else if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_PLUSMINUS) {
            c.begin();
            c.moveTo(w * .75, h - 3.5);
            c.lineTo(w * .75, h - 11.5);
            c.moveTo(w * .75 + 4, h - 7.5);
            c.lineTo(w * .75 - 4, h - 7.5);
            c.stroke()
        } else {
            if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_ARROW) {
                c.begin();
                c.moveTo(w * .75 + 4, h - 6);
                c.lineTo(w * .75, h - 10);
                c.lineTo(w * .75 - 4, h - 6);
                c.close();
                c.moveTo(w * .75, h - 3);
                c.lineTo(w * .75, h - 10);
                c.fillAndStroke()
            }
        }
    else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_VERTICAL)
        if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_TRIANGLE) {
            c.begin();
            c.moveTo(w * .5 + 4, 12);
            c.lineTo(w * .5, 5);
            c.lineTo(w * .5 - 4, 12);
            c.close();
            c.fillAndStroke()
        } else if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_PLUSMINUS) {
            c.begin();
            c.moveTo(w * .5, 3.5);
            c.lineTo(w * .5, 11.5);
            c.moveTo(w * .5 + 4, 7.5);
            c.lineTo(w * .5 - 4, 7.5);
            c.stroke()
        } else {
            if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_ARROW) {
                c.begin();
                c.moveTo(w * .5 + 4, 9);
                c.lineTo(w * .5, 5);
                c.lineTo(w * .5 - 4, 9);
                c.close();
                c.moveTo(w * .5, 12);
                c.lineTo(w * .5, 5);
                c.fillAndStroke()
            }
        }
    else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_HORIZONTAL)
        if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_TRIANGLE) {
            c.begin();
            c.moveTo(w - 6, h * .5 + 4.5);
            c.lineTo(w - 10, h * .5 - 2.5);
            c.lineTo(w - 14, h * .5 + 4.5);
            c.close();
            c.fillAndStroke()
        } else if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_PLUSMINUS) {
            c.begin();
            c.moveTo(w - 10, h * .5 - 4);
            c.lineTo(w - 10, h * .5 + 4);
            c.moveTo(w - 14, h * .5);
            c.lineTo(w - 6, h * .5);
            c.stroke()
        } else if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_ARROW) {
            c.begin();
            c.moveTo(w - 14, h * .5 + 1.5);
            c.lineTo(w - 10, h * .5 - 2.5);
            c.lineTo(w - 6, h * .5 + 1.5);
            c.close();
            c.moveTo(w - 10, h * .5 + 4.5);
            c.lineTo(w - 10, h * .5 - 2.5);
            c.fillAndStroke()
        }
    if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_RIGHT)
        if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_TRIANGLE) {
            c.begin();
            c.moveTo(w - 14, h * .75 - 4.5);
            c.lineTo(w - 10, h * .75 + 2.5);
            c.lineTo(w - 6, h * .75 - 4.5);
            c.close();
            c.fillAndStroke()
        } else if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_PLUSMINUS) {
            c.begin();
            c.moveTo(w - 14, h * .75);
            c.lineTo(w - 6, h * .75);
            c.stroke()
        } else {
            if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_ARROW) {
                c.begin();
                c.moveTo(w - 14, h * .75 - 1.5);
                c.lineTo(w - 10, h * .75 + 2.5);
                c.lineTo(w - 6, h * .75 - 1.5);
                c.close();
                c.moveTo(w - 10, h * .75 - 4.5);
                c.lineTo(w - 10, h * .75 + 2.5);
                c.fillAndStroke()
            }
        }
    else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_LEFT)
        if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_TRIANGLE) {
            c.begin();
            c.moveTo(14, h * .75 - 4.5);
            c.lineTo(10, h * .75 + 2.5);
            c.lineTo(6, h * .75 - 4.5);
            c.close();
            c.fillAndStroke()
        } else if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_PLUSMINUS) {
            c.begin();
            c.moveTo(14, h * .75);
            c.lineTo(6, h * .75);
            c.stroke()
        } else {
            if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_ARROW) {
                c.begin();
                c.moveTo(14, h * .75 - 1.5);
                c.lineTo(10, h * .75 + 2.5);
                c.lineTo(6, h * .75 - 1.5);
                c.close();
                c.moveTo(10, h * .75 - 4.5);
                c.lineTo(10, h * .75 + 2.5);
                c.fillAndStroke()
            }
        }
    else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_TOP)
        if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_TRIANGLE) {
            c.begin();
            c.moveTo(w * .25 + 4, 5);
            c.lineTo(w * .25, 12);
            c.lineTo(w * .25 - 4, 5);
            c.close();
            c.fillAndStroke()
        } else if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_PLUSMINUS) {
            c.begin();
            c.moveTo(w * .25 + 4, 7.5);
            c.lineTo(w * .25 - 4, 7.5);
            c.stroke()
        } else {
            if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_ARROW) {
                c.begin();
                c.moveTo(w * .25 + 4, 6);
                c.lineTo(w * .25, 10);
                c.lineTo(w * .25 - 4, 6);
                c.close();
                c.moveTo(w * .25, 3);
                c.lineTo(w * .25, 10);
                c.fillAndStroke()
            }
        }
    else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_BOTTOM)
        if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_TRIANGLE) {
            c.begin();
            c.moveTo(w * .25 + 4, h - 12);
            c.lineTo(w * .25, h - 5);
            c.lineTo(w * .25 - 4, h - 12);
            c.close();
            c.fillAndStroke()
        } else if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_PLUSMINUS) {
            c.begin();
            c.moveTo(w * .25 + 4, h - 7.5);
            c.lineTo(w * .25 - 4, h - 7.5);
            c.stroke()
        } else {
            if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_ARROW) {
                c.begin();
                c.moveTo(w * .25 + 4, h - 9);
                c.lineTo(w * .25, h - 5);
                c.lineTo(w * .25 - 4, h - 9);
                c.close();
                c.moveTo(w * .25, h - 12);
                c.lineTo(w * .25, h - 5);
                c.fillAndStroke()
            }
        }
    else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_VERTICAL)
        if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_TRIANGLE) {
            c.begin();
            c.moveTo(w * .5 + 4, h - 12);
            c.lineTo(w * .5, h - 5);
            c.lineTo(w * .5 - 4, h - 12);
            c.close();
            c.fillAndStroke()
        } else if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_PLUSMINUS) {
            c.begin();
            c.moveTo(w * .5 + 4, h - 7.5);
            c.lineTo(w * .5 - 4, h - 7.5);
            c.stroke()
        } else {
            if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_ARROW) {
                c.begin();
                c.moveTo(w * .5 + 4, h - 9);
                c.lineTo(w * .5, h - 5);
                c.lineTo(w * .5 - 4, h - 9);
                c.close();
                c.moveTo(w * .5, h - 12);
                c.lineTo(w * .5, h - 5);
                c.fillAndStroke()
            }
        }
    else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_HORIZONTAL)
        if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_TRIANGLE) {
            c.begin();
            c.moveTo(6, h * .5 - 4.5);
            c.lineTo(10, h * .5 + 2.5);
            c.lineTo(14, h * .5 - 4.5);
            c.close();
            c.fillAndStroke()
        } else if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_PLUSMINUS) {
            c.begin();
            c.moveTo(14, h * .5);
            c.lineTo(6, h * .5);
            c.stroke()
        } else if (adjStyle === mxShapeMockupSpinner.prototype.cst.ADJ_ARROW) {
            c.begin();
            c.moveTo(14, h * .5 - 1.5);
            c.lineTo(10, h * .5 + 2.5);
            c.lineTo(6, h * .5 - 1.5);
            c.close();
            c.moveTo(10, h * .5 - 4.5);
            c.lineTo(10, h * .5 + 2.5);
            c.fillAndStroke()
        }
}
;
mxShapeMockupSpinner.prototype.mainText = function(c, w, h, spinnerLayout) {
    var spinnerText = mxUtils.getValue(this.style, mxShapeMockupSpinner.prototype.cst.MAIN_TEXT, "100").toString();
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupSpinner.prototype.cst.TEXT_SIZE, "17");
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupSpinner.prototype.cst.TEXT_COLOR, "#666666");
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_RIGHT)
        c.text((w - 20) * .5, h * .5, 0, 0, spinnerText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_LEFT)
        c.text((w + 20) * .5, h * .5, 0, 0, spinnerText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_TOP)
        c.text(w * .5, (h + 15) * .5, 0, 0, spinnerText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_BOTTOM)
        c.text(w * .5, (h - 15) * .5, 0, 0, spinnerText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_VERTICAL)
        c.text(w * .5, h * .5, 0, 0, spinnerText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    else if (spinnerLayout === mxShapeMockupSpinner.prototype.cst.LAYOUT_HORIZONTAL)
        c.text(w * .5, h * .5, 0, 0, spinnerText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxShapeMockupSpinner.prototype.cst.SHAPE_SPINNER, mxShapeMockupSpinner);
function mxShapeMockupMenuBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupMenuBar, mxShape);
mxShapeMockupMenuBar.prototype.cst = {
    MAIN_TEXT: "mainText",
    SHAPE_MENU_BAR: "mxgraph.mockup.forms.menuBar",
    TEXT_COLOR: "textColor",
    TEXT_COLOR2: "textColor2",
    STROKE_COLOR2: "strokeColor2",
    FILL_COLOR2: "fillColor2",
    SELECTED: "+",
    TEXT_SIZE: "textSize"
};
mxShapeMockupMenuBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    var textStrings = mxUtils.getValue(this.style, mxShapeMockupMenuBar.prototype.cst.MAIN_TEXT, "+Menu 1, Menu 2, Menu 3").toString().split(",");
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupMenuBar.prototype.cst.TEXT_COLOR, "#666666");
    var selectedFontColor = mxUtils.getValue(this.style, mxShapeMockupMenuBar.prototype.cst.TEXT_COLOR2, "#ffffff");
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupMenuBar.prototype.cst.TEXT_SIZE, "17").toString();
    var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#666666");
    var separatorColor = mxUtils.getValue(this.style, mxShapeMockupMenuBar.prototype.cst.STROKE_COLOR2, "#c4c4c4");
    var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var selectedFillColor = mxUtils.getValue(this.style, mxShapeMockupMenuBar.prototype.cst.FILL_COLOR2, "#008cff");
    var buttonNum = textStrings.length;
    var buttonWidths = new Array(buttonNum);
    var buttonTotalWidth = 0;
    var selectedButton = -1;
    var rSize = 10;
    var labelOffset = 5;
    for (var i = 0; i < buttonNum; i++) {
        var buttonText = textStrings[i];
        if (buttonText.charAt(0) === mxShapeMockupMenuBar.prototype.cst.SELECTED) {
            buttonText = textStrings[i].substring(1);
            selectedButton = i
        }
        buttonWidths[i] = mxUtils.getSizeForString(buttonText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
        buttonTotalWidth += buttonWidths[i]
    }
    var trueH = Math.max(h, fontSize * 1.5, 20);
    var minW = 2 * labelOffset * buttonNum + buttonTotalWidth;
    var trueW = Math.max(w, minW);
    c.translate(x, y);
    this.background(c, trueW, trueH, rSize, buttonNum, buttonWidths, labelOffset, minW, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton);
    c.setShadow(false);
    var currWidth = 0;
    for (var i = 0; i < buttonNum; i++) {
        if (i === selectedButton)
            c.setFontColor(selectedFontColor);
        else
            c.setFontColor(fontColor);
        currWidth = currWidth + labelOffset;
        this.buttonText(c, currWidth, trueH, textStrings[i], buttonWidths[i], fontSize, minW, trueW);
        currWidth = currWidth + buttonWidths[i] + labelOffset
    }
}
;
mxShapeMockupMenuBar.prototype.background = function(c, w, h, rSize, buttonNum, buttonWidths, labelOffset, minW, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton) {
    c.setStrokeColor(frameColor);
    c.setFillColor(bgColor);
    c.rect(0, 0, w, h);
    c.fillAndStroke();
    c.setStrokeColor(separatorColor);
    c.begin();
    for (var i = 1; i < buttonNum; i++)
        if (i !== selectedButton && i !== selectedButton + 1) {
            var currWidth = 0;
            for (var j = 0; j < i; j++)
                currWidth += buttonWidths[j] + 2 * labelOffset;
            currWidth = currWidth * w / minW;
            c.moveTo(currWidth, 0);
            c.lineTo(currWidth, h)
        }
    c.stroke();
    if (selectedButton !== -1) {
        var buttonLeft = 0;
        c.setFillColor(selectedFillColor);
        for (var i = 0; i < selectedButton; i++)
            buttonLeft += buttonWidths[i] + 2 * labelOffset;
        buttonLeft = buttonLeft * w / minW;
        var buttonRight = (buttonWidths[selectedButton] + 2 * labelOffset) * w / minW;
        buttonRight += buttonLeft;
        c.rect(buttonLeft, 0, buttonRight - buttonLeft, h);
        c.fill()
    }
    c.setStrokeColor(frameColor);
    c.setFillColor(bgColor);
    c.rect(0, 0, w, h);
    c.stroke()
}
;
mxShapeMockupMenuBar.prototype.buttonText = function(c, w, h, textString, buttonWidth, fontSize, minW, trueW) {
    if (textString.charAt(0) === mxShapeMockupMenuBar.prototype.cst.SELECTED)
        textString = textString.substring(1);
    c.setFontSize(fontSize);
    c.text((w + buttonWidth * .5) * trueW / minW, h * .5, 0, 0, textString, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxShapeMockupMenuBar.prototype.cst.SHAPE_MENU_BAR, mxShapeMockupMenuBar);
function mxShapeMockupHorSlider(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupHorSlider, mxShape);
mxShapeMockupHorSlider.prototype.cst = {
    STYLE: "sliderStyle",
    SLIDER_BASIC: "basic",
    SLIDER_FANCY: "fancy",
    SLIDER_POS: "sliderPos",
    HANDLE_TRIANGLE: "triangle",
    HANDLE_CIRCLE: "circle",
    HANDLE_HANDLE: "handle",
    HANDLE_STYLE: "handleStyle",
    FILL_COLOR2: "fillColor2",
    SHAPE_HOR_SLIDER: "mxgraph.mockup.forms.horSlider"
};
mxShapeMockupHorSlider.prototype.paintVertexShape = function(c, x, y, w, h) {
    var sliderStyle = mxUtils.getValue(this.style, mxShapeMockupHorSlider.prototype.cst.STYLE, mxShapeMockupHorSlider.prototype.cst.SLIDER_BASIC);
    var rSize = 5;
    c.translate(x, y);
    this.background(c, w, h, rSize, sliderStyle);
    c.setShadow(false);
    this.foreground(c, w, h, rSize, sliderStyle);
    this.sliderPos = 20
}
;
mxShapeMockupHorSlider.prototype.background = function(c, w, h, rSize, sliderStyle) {
    if (sliderStyle === mxShapeMockupHorSlider.prototype.cst.SLIDER_BASIC) {
        c.begin();
        c.moveTo(0, h * .5);
        c.lineTo(w, h * .5);
        c.stroke()
    } else if (sliderStyle === mxShapeMockupHorSlider.prototype.cst.SLIDER_FANCY) {
        c.roundrect(0, h * .5 - rSize, w, 2 * rSize, rSize, rSize);
        c.fillAndStroke()
    }
}
;
mxShapeMockupHorSlider.prototype.foreground = function(c, w, h, rSize, sliderStyle) {
    var sliderPos = mxUtils.getValue(this.style, mxShapeMockupHorSlider.prototype.cst.SLIDER_POS, "20");
    var handleStyle = mxUtils.getValue(this.style, mxShapeMockupHorSlider.prototype.cst.HANDLE_STYLE, mxShapeMockupHorSlider.prototype.cst.HANDLE_CIRCLE);
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var fillColor2 = mxUtils.getValue(this.style, mxShapeMockupHorSlider.prototype.cst.FILL_COLOR2, "#ddeeff");
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#999999");
    sliderPos = Math.min(100, sliderPos);
    sliderPos = Math.max(0, sliderPos);
    if (sliderStyle === mxShapeMockupHorSlider.prototype.cst.SLIDER_BASIC) {
        c.setStrokeColor(fillColor2);
        var barCenterPos = w * sliderPos / 100;
        c.begin();
        c.moveTo(0, h * .5);
        c.lineTo(barCenterPos, h * .5);
        c.stroke();
        c.setStrokeColor(strokeColor)
    } else if (sliderStyle === mxShapeMockupHorSlider.prototype.cst.SLIDER_FANCY) {
        var barCenterPos = 10 + (w - 10) * sliderPos / 100;
        c.setFillColor(fillColor2);
        c.roundrect(0, h * .5 - rSize, barCenterPos, 2 * rSize, rSize, rSize);
        c.fillAndStroke();
        c.setFillColor(fillColor)
    }
    var handleCenterPos = 5 + (w - 10) * sliderPos / 100;
    if (handleStyle === mxShapeMockupHorSlider.prototype.cst.HANDLE_CIRCLE) {
        c.ellipse(handleCenterPos - 10, h * .5 - 10, 20, 20);
        c.fillAndStroke()
    } else if (handleStyle === mxShapeMockupHorSlider.prototype.cst.HANDLE_TRIANGLE) {
        c.begin();
        c.moveTo(handleCenterPos - 10, h * .5 + 10);
        c.lineTo(handleCenterPos, h * .5 - 10);
        c.lineTo(handleCenterPos + 10, h * .5 + 10);
        c.close();
        c.fillAndStroke()
    } else if (handleStyle === mxShapeMockupHorSlider.prototype.cst.HANDLE_HANDLE) {
        c.begin();
        c.moveTo(handleCenterPos - 7, h * .5 + 10);
        c.lineTo(handleCenterPos - 7, h * .5);
        c.lineTo(handleCenterPos, h * .5 - 10);
        c.lineTo(handleCenterPos + 7, h * .5);
        c.lineTo(handleCenterPos + 7, h * .5 + 10);
        c.close();
        c.fillAndStroke()
    }
}
;
mxCellRenderer.registerShape(mxShapeMockupHorSlider.prototype.cst.SHAPE_HOR_SLIDER, mxShapeMockupHorSlider);
Graph.handleFactory[mxShapeMockupHorSlider.prototype.cst.SHAPE_HOR_SLIDER] = function(state) {
    var handles = [Graph.createHandle(state, ["sliderPos"], function(bounds) {
        var sliderPos = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, "sliderPos", this.sliderPos))));
        return new mxPoint(bounds.x + (bounds.width - 10) * sliderPos / bounds.width / 100 * bounds.width + 5,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["sliderPos"] = Math.round(1E3 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 1E3
    })];
    return handles
}
;
function mxShapeMockupListBox(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupListBox, mxShape);
mxShapeMockupListBox.prototype.cst = {
    MAIN_TEXT: "mainText",
    SUB_TEXT: "subText",
    BUTTON_TEXT: "buttonText",
    TEXT_SIZE: "textSize",
    TEXT_COLOR: "textColor",
    STROKE_COLOR2: "strokeColor2",
    STROKE_COLOR3: "strokeColor3",
    SELECTED_COLOR: "selectedColor",
    SELECTED: "+",
    SHAPE_LIST_BOX: "mxgraph.mockup.forms.listBox"
};
mxShapeMockupListBox.prototype.paintVertexShape = function(c, x, y, w, h) {
    var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#666666");
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupListBox.prototype.cst.TEXT_SIZE, "17").toString();
    var selectedButton = -1;
    var maxShapeWidth = w;
    var subText = mxUtils.getValue(this.style, mxShapeMockupListBox.prototype.cst.SUB_TEXT, "Sub Text").toString().split(",");
    for (var i = 0; i < subText.length; i++) {
        var itemText = subText[i];
        if (itemText.charAt(0) === mxShapeMockupListBox.prototype.cst.SELECTED) {
            itemText = subText[i].substring(1);
            selectedButton = i
        }
        var currWidth = mxUtils.getSizeForString(itemText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
        if (currWidth > maxShapeWidth)
            maxShapeWidth = currWidth
    }
    c.translate(x, y);
    w = Math.min(w, maxShapeWidth);
    h = Math.max(h, 30 + subText.length * fontSize * 1.5);
    this.background(c, w, h, bgColor, frameColor);
    c.setShadow(false);
    this.foreground(c, w, h, frameColor, selectedButton, subText, fontSize)
}
;
mxShapeMockupListBox.prototype.background = function(c, w, h, bgColor, frameColor) {
    c.setFillColor(bgColor);
    c.setStrokeColor(frameColor);
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupListBox.prototype.foreground = function(c, w, h, frameColor, selectedButton, subText, fontSize) {
    var strokeWidth = mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, "1");
    var selectedColor = mxUtils.getValue(this.style, mxShapeMockupListBox.prototype.cst.SELECTED_COLOR, "#ddeeff");
    if (selectedButton !== -1) {
        c.setFillColor(selectedColor);
        c.rect(0, 30 + selectedButton * fontSize * 1.5, w, fontSize * 1.5);
        c.fill()
    }
    c.begin();
    c.moveTo(0, 30);
    c.lineTo(w, 30);
    c.stroke();
    var windowTitle = mxUtils.getValue(this.style, mxShapeMockupListBox.prototype.cst.MAIN_TEXT, "Window Title").toString();
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupListBox.prototype.cst.TEXT_COLOR, "#666666,#008cff").toString().split(",");
    c.setFontColor(fontColor[1]);
    c.setFontSize(fontSize);
    c.text(10, 15, 0, 0, windowTitle, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setFontColor(fontColor[0]);
    for (var i = 0; i < subText.length; i++) {
        var currText = subText[i];
        if (currText.charAt(0) === mxShapeMockupListBox.prototype.cst.SELECTED)
            currText = subText[i].substring(1);
        c.text(10, 30 + fontSize * (i * 1.5 + .75), 0, 0, currText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
    }
    c.rect(0, 0, w, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupListBox.prototype.cst.SHAPE_LIST_BOX, mxShapeMockupListBox);
function mxShapeMockupPwField(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupPwField, mxShape);
mxShapeMockupPwField.prototype.cst = {
    MAIN_TEXT: "mainText",
    TEXT_COLOR: "textColor",
    TEXT_SIZE: "textSize",
    SHAPE_PW_FIELD: "mxgraph.mockup.forms.pwField"
};
mxShapeMockupPwField.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxShapeMockupPwField.prototype.background = function(c, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupPwField.prototype.foreground = function(c, w, h) {
    var mainText = mxUtils.getValue(this.style, mxShapeMockupPwField.prototype.cst.MAIN_TEXT, "******");
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupPwField.prototype.cst.TEXT_COLOR, "#666666");
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupPwField.prototype.cst.TEXT_SIZE, "17");
    c.setFontColor(fontColor);
    c.setFontSize(fontSize);
    c.text(5, h * .5, 0, 0, mainText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxShapeMockupPwField.prototype.cst.SHAPE_PW_FIELD, mxShapeMockupPwField);
function mxShapeMockupSplitter(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupSplitter, mxShape);
mxShapeMockupSplitter.prototype.cst = {
    MAIN_TEXT: "mainText",
    TEXT_COLOR: "textColor",
    TEXT_SIZE: "textSize",
    SHAPE_SPLITTER: "mxgraph.mockup.forms.splitter"
};
mxShapeMockupSplitter.prototype.paintVertexShape = function(c, x, y, w, h) {
    w = Math.max(w, 35);
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxShapeMockupSplitter.prototype.background = function(c, w, h) {
    c.begin();
    c.moveTo(0, h * .5 - 5);
    c.lineTo(w, h * .5 - 5);
    c.lineTo(w, h * .5 + 5);
    c.lineTo(0, h * .5 + 5);
    c.close();
    c.fill()
}
;
mxShapeMockupSplitter.prototype.foreground = function(c, w, h) {
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#999999");
    c.begin();
    c.moveTo(0, h * .5 - 5);
    c.lineTo(w, h * .5 - 5);
    c.moveTo(w, h * .5 + 5);
    c.lineTo(0, h * .5 + 5);
    c.stroke();
    c.setFillColor(strokeColor);
    c.ellipse(w * .5 - 17, h * .5 - 2, 4, 4);
    c.fill();
    c.ellipse(w * .5 - 2, h * .5 - 2, 4, 4);
    c.fill();
    c.ellipse(w * .5 + 13, h * .5 - 2, 4, 4);
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeMockupSplitter.prototype.cst.SHAPE_SPLITTER, mxShapeMockupSplitter);
function mxShapeMockupWedgeBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupWedgeBar, mxShape);
mxShapeMockupWedgeBar.prototype.cst = {
    BLOCK: "block",
    CONE: "cone",
    HALF_CONE: "halfCone",
    ROUND: "round",
    TEXT_SIZE: "textSize",
    TAB_NAMES: "tabs",
    TAB_STYLE: "tabStyle",
    STYLE_FILLCOLOR2: "fillColor2",
    TEXT_COLOR: "textColor",
    SEL_TEXT_COLOR: "textColor2",
    SHAPE_WEDGE_BAR: "mxgraph.mockup.forms.wedgeBar"
};
mxShapeMockupWedgeBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupWedgeBar.prototype.cst.TEXT_SIZE, "17").toString();
    var tabNames = mxUtils.getValue(this.style, mxShapeMockupWedgeBar.prototype.cst.TAB_NAMES, "Tab 1,+Tab 2,Tab 3").toString().split(",");
    var tabH = fontSize * 1.5;
    var startOffset = 10;
    var tabOffset = 5;
    var labelOffset = 10;
    var tabCount = tabNames.length;
    var minW = 2 * startOffset + (tabCount - 1) * tabOffset + tabCount * 2 * labelOffset;
    var rSize = 5;
    var labelWidths = new Array;
    var selectedTab = -1;
    for (var i = 0; i < tabCount; i++) {
        var currLabel = tabNames[i];
        if (currLabel.charAt(0) === "+") {
            currLabel = currLabel.substring(1);
            selectedTab = i
        }
        var currW = mxUtils.getSizeForString(currLabel, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
        if (currW === 0)
            labelWidths[i] = 42;
        else
            labelWidths[i] = currW;
        minW = minW + labelWidths[i]
    }
    w = Math.max(w, minW);
    h = Math.max(h, tabH + rSize);
    c.translate(x, y);
    c.setShadow(false);
    this.backTabs(c, w, h, rSize, tabH, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab);
    this.focusTab(c, w, h, rSize, tabH, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab);
    this.tabText(c, w, h, rSize, tabH, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab, tabNames)
}
;
mxShapeMockupWedgeBar.prototype.backTabs = function(c, w, h, rSize, tabH, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab) {
    var tabStyle = mxUtils.getValue(this.style, mxShapeMockupWedgeBar.prototype.cst.TAB_STYLE, mxShapeMockupWedgeBar.prototype.cst.BLOCK);
    var currW = startOffset;
    for (var i = 0; i < tabCount; i++) {
        var tabW = labelWidths[i] + 2 * labelOffset;
        if (selectedTab !== i) {
            if (tabStyle === mxShapeMockupWedgeBar.prototype.cst.BLOCK) {
                c.begin();
                c.moveTo(currW, tabH);
                c.lineTo(currW, 0);
                c.lineTo(currW + tabW, 0);
                c.lineTo(currW + tabW, tabH)
            } else if (tabStyle === mxShapeMockupWedgeBar.prototype.cst.CONE) {
                c.begin();
                c.moveTo(currW, tabH);
                c.lineTo(currW + labelOffset * .5, 0);
                c.lineTo(currW + tabW - labelOffset * .5, 0);
                c.lineTo(currW + tabW, tabH)
            } else if (tabStyle === mxShapeMockupWedgeBar.prototype.cst.HALF_CONE) {
                c.begin();
                c.moveTo(currW, tabH);
                c.lineTo(currW + labelOffset * .5, 0);
                c.lineTo(currW + tabW, 0);
                c.lineTo(currW + tabW, tabH)
            } else if (tabStyle === mxShapeMockupWedgeBar.prototype.cst.ROUND) {
                c.begin();
                c.moveTo(currW - rSize, tabH);
                c.arcTo(rSize, rSize, 0, 0, 0, currW, tabH - rSize);
                c.lineTo(currW, rSize);
                c.arcTo(rSize, rSize, 0, 0, 1, currW + rSize, 0);
                c.lineTo(currW + tabW - rSize, 0);
                c.arcTo(rSize, rSize, 0, 0, 1, currW + tabW, rSize);
                c.lineTo(currW + tabW, tabH - rSize);
                c.arcTo(rSize, rSize, 0, 0, 0, currW + tabW + rSize, tabH)
            }
            c.fillAndStroke()
        }
        currW = currW + tabW + tabOffset
    }
}
;
mxShapeMockupWedgeBar.prototype.focusTab = function(c, w, h, rSize, tabH, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab) {
    var tabStyle = mxUtils.getValue(this.style, mxShapeMockupWedgeBar.prototype.cst.TAB_STYLE, mxShapeMockupWedgeBar.prototype.cst.BLOCK);
    var selectedFill = mxUtils.getValue(this.style, mxShapeMockupWedgeBar.prototype.cst.STYLE_FILLCOLOR2, "#008cff");
    var currW = startOffset;
    c.setStrokeColor(selectedFill);
    c.setFillColor(selectedFill);
    for (var i = 0; i <= selectedTab; i++) {
        var tabW = labelWidths[i] + 2 * labelOffset;
        if (selectedTab === i) {
            if (tabStyle === mxShapeMockupWedgeBar.prototype.cst.BLOCK) {
                c.begin();
                c.moveTo(currW, tabH);
                c.lineTo(currW, 0);
                c.lineTo(currW + tabW, 0);
                c.lineTo(currW + tabW, tabH)
            } else if (tabStyle === mxShapeMockupWedgeBar.prototype.cst.CONE) {
                c.begin();
                c.moveTo(currW, tabH);
                c.lineTo(currW + labelOffset * .5, 0);
                c.lineTo(currW + tabW - labelOffset * .5, 0);
                c.lineTo(currW + tabW, tabH)
            } else if (tabStyle === mxShapeMockupWedgeBar.prototype.cst.HALF_CONE) {
                c.begin();
                c.moveTo(currW, tabH);
                c.lineTo(currW + labelOffset * .5, 0);
                c.lineTo(currW + tabW, 0);
                c.lineTo(currW + tabW, tabH)
            } else if (tabStyle === mxShapeMockupWedgeBar.prototype.cst.ROUND) {
                c.begin();
                c.moveTo(currW - rSize, tabH);
                c.arcTo(rSize, rSize, 0, 0, 0, currW, tabH - rSize);
                c.lineTo(currW, rSize);
                c.arcTo(rSize, rSize, 0, 0, 1, currW + rSize, 0);
                c.lineTo(currW + tabW - rSize, 0);
                c.arcTo(rSize, rSize, 0, 0, 1, currW + tabW, rSize);
                c.lineTo(currW + tabW, tabH - rSize);
                c.arcTo(rSize, rSize, 0, 0, 0, currW + tabW + rSize, tabH)
            }
            c.fillAndStroke()
        }
        currW = currW + tabW + tabOffset
    }
}
;
mxShapeMockupWedgeBar.prototype.tabText = function(c, w, h, rSize, tabH, startOffset, tabOffset, labelOffset, tabCount, labelWidths, selectedTab, tabNames) {
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupWedgeBar.prototype.cst.TEXT_COLOR, "#666666");
    var selFontColor = mxUtils.getValue(this.style, mxShapeMockupWedgeBar.prototype.cst.SEL_TEXT_COLOR, "#ffffff");
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupWedgeBar.prototype.cst.TEXT_SIZE, "17").toString();
    c.setFontColor(fontColor);
    c.setFontSize(fontSize);
    var currW = startOffset;
    for (var i = 0; i < tabCount; i++) {
        var currLabel = tabNames[i];
        if (i === selectedTab)
            c.setFontColor(selFontColor);
        if (currLabel.charAt(0) === "+")
            currLabel = currLabel.substring(1);
        var tabW = labelWidths[i] + 2 * labelOffset;
        c.text(currW + labelOffset, tabH * .5, 0, 0, currLabel, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
        currW = currW + tabW + tabOffset;
        if (i === selectedTab)
            c.setFontColor(fontColor)
    }
}
;
mxCellRenderer.registerShape(mxShapeMockupWedgeBar.prototype.cst.SHAPE_WEDGE_BAR, mxShapeMockupWedgeBar);
function mxShapeMockupSearchBox(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupSearchBox, mxShape);
mxShapeMockupSearchBox.prototype.cst = {
    MAIN_TEXT: "mainText",
    TEXT_COLOR: "textColor",
    TEXT_SIZE: "textSize",
    STROKE_COLOR2: "strokeColor2",
    SHAPE_SEARCH_BOX: "mxgraph.mockup.forms.searchBox"
};
mxShapeMockupSearchBox.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxShapeMockupSearchBox.prototype.background = function(c, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupSearchBox.prototype.foreground = function(c, w, h) {
    var mainText = mxUtils.getValue(this.style, mxShapeMockupSearchBox.prototype.cst.MAIN_TEXT, "Search");
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupSearchBox.prototype.cst.TEXT_COLOR, "#666666");
    var strokeColor2 = mxUtils.getValue(this.style, mxShapeMockupSearchBox.prototype.cst.STROKE_COLOR2, "#008cff");
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupSearchBox.prototype.cst.TEXT_SIZE, "17");
    c.setFontColor(fontColor);
    c.setFontSize(fontSize);
    c.text(5, h * .5, 0, 0, mainText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setStrokeColor(strokeColor2);
    c.ellipse(w - 15, h * .5 - 8, 10, 10);
    c.stroke();
    c.begin();
    c.moveTo(w - 19, h * .5 + 9);
    c.lineTo(w - 13, h * .5 + 1);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupSearchBox.prototype.cst.SHAPE_SEARCH_BOX, mxShapeMockupSearchBox);
function mxShapeMockupSignIn(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupSignIn, mxShape);
mxShapeMockupSignIn.prototype.cst = {
    MAIN_TEXT: "mainText",
    TEXT_COLOR: "textColor",
    TEXT_COLOR2: "textColor2",
    TEXT_SIZE: "textSize",
    TEXT_SIZE2: "textSize2",
    STROKE_COLOR2: "strokeColor2",
    FILL_COLOR2: "fillColor2",
    SHAPE_SIGN_IN: "mxgraph.mockup.forms.signIn"
};
mxShapeMockupSignIn.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxShapeMockupSignIn.prototype.background = function(c, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupSignIn.prototype.foreground = function(c, w, h) {
    var mainText = mxUtils.getValue(this.style, mxShapeMockupSignIn.prototype.cst.MAIN_TEXT, "Sign In,User Name:,johndoe,Password:,********,Forgot Password?,New User,SIGN IN,SIGN UP").toString().split(",");
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupSignIn.prototype.cst.TEXT_COLOR, "#666666");
    var fontColor2 = mxUtils.getValue(this.style, mxShapeMockupSignIn.prototype.cst.TEXT_COLOR2, "#ffffff");
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupSignIn.prototype.cst.TEXT_SIZE, "12");
    var fontSize2 = mxUtils.getValue(this.style, mxShapeMockupSignIn.prototype.cst.TEXT_SIZE2, "15");
    var strokeColor2 = mxUtils.getValue(this.style, mxShapeMockupSignIn.prototype.cst.STROKE_COLOR2, "#ddeeff");
    var fillColor2 = mxUtils.getValue(this.style, mxShapeMockupSignIn.prototype.cst.FILL_COLOR2, "#66bbff");
    c.setFillColor(fillColor2);
    c.roundrect(w * .09, h * .52, w * .36, h * .09, 5, 5);
    c.fill();
    c.roundrect(w * .09, h * .84, w * .36, h * .09, 5, 5);
    c.fill();
    c.rect(w * .05, h * .22, w * .75, h * .08);
    c.stroke();
    c.rect(w * .05, h * .4, w * .75, h * .08);
    c.stroke();
    c.setStrokeColor(strokeColor2);
    c.setStrokeWidth(2);
    c.begin();
    c.moveTo(w * .05, h * .12);
    c.lineTo(w * .95, h * .12);
    c.moveTo(w * .05, h * .72);
    c.lineTo(w * .95, h * .72);
    c.stroke();
    c.setFontColor(fontColor);
    c.setFontSize(fontSize);
    c.text(w * .05, h * .1, 0, 0, mainText[0], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_BOTTOM, 0, null, 0, 0, 0);
    c.text(w * .05, h * .2, 0, 0, mainText[1], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_BOTTOM, 0, null, 0, 0, 0);
    c.text(w * .075, h * .26, 0, 0, mainText[2], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .05, h * .38, 0, 0, mainText[3], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_BOTTOM, 0, null, 0, 0, 0);
    c.text(w * .075, h * .44, 0, 0, mainText[4], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .05, h * .8, 0, 0, mainText[6], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setStrokeWidth(1);
    c.setFontColor("#9999ff");
    c.setStrokeColor("#9999ff");
    var forgotW = mxUtils.getSizeForString(mainText[5], fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
    c.text(w * .05, h * .7, 0, 0, mainText[5], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_BOTTOM, 0, null, 0, 0, 0);
    c.begin();
    c.moveTo(w * .05, h * .7);
    c.lineTo(w * .05 + forgotW, h * .7);
    c.stroke();
    c.setFontColor(fontColor2);
    c.setFontStyle(mxConstants.FONT_BOLD);
    c.setFontSize(fontSize2);
    c.text(w * .27, h * .565, 0, 0, mainText[7], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .27, h * .885, 0, 0, mainText[8], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxShapeMockupSignIn.prototype.cst.SHAPE_SIGN_IN, mxShapeMockupSignIn);
function mxShapeMockupCalendar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupCalendar, mxShape);
mxShapeMockupCalendar.prototype.cst = {
    SHAPE_CALENDAR: "mxgraph.mockup.forms.calendar",
    DAYS: "days",
    SELECTED_DAY: "selDay",
    PREV_DAYS: "prevDays",
    FIRST_DAY: "firstDay",
    START_ON: "startOn",
    DAY_NAMES: "dayNames",
    MAIN_TEXT: "mainText",
    TEXT_SIZE: "textSize",
    TEXT_COLOR: "textColor",
    TEXT_COLOR2: "textColor2",
    STROKE_COLOR2: "strokeColor2",
    FILL_COLOR2: "fillColor2"
};
mxShapeMockupCalendar.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxShapeMockupCalendar.prototype.background = function(c, w, h) {
    c.roundrect(0, 0, w, h, w * .0312, h * .0286);
    c.fillAndStroke()
}
;
mxShapeMockupCalendar.prototype.foreground = function(c, w, h) {
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#999999");
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var strokeColor2 = mxUtils.getValue(this.style, mxShapeMockupCalendar.prototype.cst.STROKE_COLOR2, "#008cff");
    var fillColor2 = mxUtils.getValue(this.style, mxShapeMockupCalendar.prototype.cst.FILL_COLOR2, "#ddeeff");
    var mainText = mxUtils.getValue(this.style, mxShapeMockupCalendar.prototype.cst.MAIN_TEXT, "");
    var textSize = mxUtils.getValue(this.style, mxShapeMockupCalendar.prototype.cst.TEXT_SIZE, "15");
    var textColor = mxUtils.getValue(this.style, mxShapeMockupCalendar.prototype.cst.TEXT_COLOR, "#999999");
    var textColor2 = mxUtils.getValue(this.style, mxShapeMockupCalendar.prototype.cst.TEXT_COLOR2, "#ffffff");
    var days = parseInt(mxUtils.getValue(this.style, mxShapeMockupCalendar.prototype.cst.DAYS, "30"), 10);
    var prevDays = parseInt(mxUtils.getValue(this.style, mxShapeMockupCalendar.prototype.cst.PREV_DAYS, "31"), 10);
    var firstDay = parseInt(mxUtils.getValue(this.style, mxShapeMockupCalendar.prototype.cst.FIRST_DAY, "0"), 10);
    var startOn = parseInt(mxUtils.getValue(this.style, mxShapeMockupCalendar.prototype.cst.START_ON, "6", 10));
    var dayNames = mxUtils.getValue(this.style, mxShapeMockupCalendar.prototype.cst.DAY_NAMES, "Mo,Tu,We,Th,Fr,Sa,Su").toString().split(",");
    var selDay = parseInt(mxUtils.getValue(this.style, mxShapeMockupCalendar.prototype.cst.SELECTED_DAY, "24"), 10);
    fistDay = Math.max(firstDay, 0);
    startOn = Math.max(startOn, 0);
    fistDay = Math.min(firstDay, 6);
    startOn = Math.min(startOn, 6);
    c.roundrect(w * .05, h * .0457, w * .1438, h * .1029, w * .025, h * .0229);
    c.stroke();
    c.roundrect(w * .8125, h * .0457, w * .1438, h * .1029, w * .025, h * .0229);
    c.stroke();
    c.setStrokeWidth(2);
    c.setStrokeColor(strokeColor2);
    c.begin();
    c.moveTo(w * .1438, h * .0743);
    c.lineTo(w * .1, h * .0971);
    c.lineTo(w * .1438, h * .12);
    c.moveTo(w * .8625, h * .0743);
    c.lineTo(w * .9062, h * .0971);
    c.lineTo(w * .8625, h * .12);
    c.stroke();
    c.setFontSize(textSize);
    c.setFontColor(textColor);
    c.text(w * .5, h * .0971, 0, 0, mainText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    var range = w * .875;
    var cellSize = range / 7;
    for (var i = 0; i < 7; i++) {
        var currX = w * .0625 + cellSize * .5 + i * cellSize;
        var j = i + startOn;
        if (j > 6)
            j = j - 7;
        c.text(currX, h * .2114, 0, 0, dayNames[j], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
    }
    c.setStrokeWidth(1);
    var x = 0;
    var selX = -1;
    var selY = -1;
    if (firstDay !== startOn) {
        c.setStrokeColor(strokeColor);
        c.setFillColor(fillColor2);
        var diff = firstDay - startOn;
        if (diff < 0)
            diff = diff + 7;
        for (var i = 0; i < diff; i++) {
            var currX = w * .0625 + i * cellSize;
            c.rect(currX, h * .2686, cellSize, h * .1143);
            c.fillAndStroke();
            var tmp = prevDays - diff + i + 1;
            c.text(currX + cellSize * .5, h * .2686 + cellSize * .5, 0, 0, tmp.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
        }
        x = diff
    }
    c.setFillColor(fillColor);
    c.setStrokeColor(strokeColor);
    var y = 0;
    for (var i = 0; i < days; i++) {
        var d = i + 1;
        var currX = w * .0625 + x * cellSize;
        var currY = h * .2686 + y * h * .1143;
        if (d === selDay) {
            selX = currX;
            selY = currY
        } else {
            c.rect(currX, currY, cellSize, h * .1143);
            c.fillAndStroke();
            c.text(currX + cellSize * .5, currY + cellSize * .5, 0, 0, d.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
        }
        if (x < 6)
            x++;
        else {
            x = 0;
            y++
        }
    }
    var i = 1;
    c.setFillColor(fillColor2);
    while (y < 6) {
        var currX = w * .0625 + x * cellSize;
        var currY = h * .2686 + y * h * .1143;
        c.rect(currX, currY, cellSize, h * .1143);
        c.fillAndStroke();
        c.text(currX + cellSize * .5, currY + cellSize * .5, 0, 0, i.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
        if (x < 6)
            x++;
        else {
            x = 0;
            y++
        }
        i++
    }
    if (selX >= 0) {
        c.setStrokeColor("#ff0000");
        c.setStrokeWidth(2);
        c.setFillColor(strokeColor2);
        c.setFontColor(textColor2);
        c.rect(selX, selY, cellSize, h * .1143);
        c.fillAndStroke();
        c.text(selX + cellSize * .5, selY + cellSize * .5, 0, 0, selDay.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
    }
}
;
mxCellRenderer.registerShape(mxShapeMockupCalendar.prototype.cst.SHAPE_CALENDAR, mxShapeMockupCalendar);
function mxShapeMockupEmailForm(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupEmailForm, mxShape);
mxShapeMockupEmailForm.prototype.cst = {
    MAIN_TEXT: "mainText",
    TEXT_COLOR: "textColor",
    SHOW_CC: "showCC",
    SHOW_BCC: "showBCC",
    TEXT_SIZE: "textSize",
    SHAPE_EMAIL_FORM: "mxgraph.mockup.forms.emailForm"
};
mxShapeMockupEmailForm.prototype.paintVertexShape = function(c, x, y, w, h) {
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupEmailForm.prototype.cst.TEXT_SIZE, "12");
    var showCC = mxUtils.getValue(this.style, mxShapeMockupEmailForm.prototype.cst.SHOW_CC, "true");
    var showBCC = mxUtils.getValue(this.style, mxShapeMockupEmailForm.prototype.cst.SHOW_BCC, "true");
    var tabX = fontSize * 4;
    var optCount = 0;
    if (showCC === "true")
        optCount++;
    if (showBCC === "true")
        optCount++;
    w = Math.max(w, fontSize * 5);
    h = Math.max(h, fontSize * 10.5 + optCount * fontSize * 3);
    c.translate(x, y);
    this.background(c, w, h, fontSize, tabX, showCC, showBCC);
    c.setShadow(false);
    this.foreground(c, w, h, fontSize, tabX, showCC, showBCC)
}
;
mxShapeMockupEmailForm.prototype.background = function(c, w, h, fontSize, tabX, showCC, showBCC) {
    var messX = fontSize * 9;
    if (showCC === "true") {
        messX = messX + fontSize * 3;
        c.rect(tabX, fontSize * 9, w - tabX, fontSize * 1.5);
        c.fillAndStroke()
    }
    if (showBCC === "true") {
        c.rect(tabX, messX, w - tabX, fontSize * 1.5);
        messX = messX + fontSize * 3;
        c.fillAndStroke()
    }
    c.rect(tabX, 0, w - tabX, fontSize * 1.5);
    c.fillAndStroke();
    c.rect(tabX, fontSize * 3, w - tabX, fontSize * 1.5);
    c.fillAndStroke();
    c.rect(tabX, fontSize * 6, w - tabX, fontSize * 1.5);
    c.fillAndStroke();
    c.rect(0, messX, w, h - messX);
    c.fillAndStroke()
}
;
mxShapeMockupEmailForm.prototype.foreground = function(c, w, h, fontSize, tabX, showCC, showBCC) {
    var mainText = mxUtils.getValue(this.style, mxShapeMockupEmailForm.prototype.cst.MAIN_TEXT, "john@jgraph.com,Greeting,fred@jgraph.com,,,Lorem ipsum").toString().split(",");
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupEmailForm.prototype.cst.TEXT_COLOR, "#666666");
    c.setFontColor(fontColor);
    c.setFontSize(fontSize);
    c.text(tabX - fontSize * .5, fontSize * .75, 0, 0, "From", mxConstants.ALIGN_RIGHT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(tabX - fontSize * .5, fontSize * 3.75, 0, 0, "Subject", mxConstants.ALIGN_RIGHT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(tabX - fontSize * .5, fontSize * 6.75, 0, 0, "To", mxConstants.ALIGN_RIGHT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(tabX + fontSize * .5, fontSize * .75, 0, 0, mainText[0], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(tabX + fontSize * .5, fontSize * 3.75, 0, 0, mainText[1], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(tabX + fontSize * .5, fontSize * 6.75, 0, 0, mainText[2], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    var messX = fontSize * 9;
    if (showCC === "true") {
        messX = messX + fontSize * 3;
        c.text(tabX - fontSize * .5, fontSize * 9.75, 0, 0, "CC", mxConstants.ALIGN_RIGHT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
        c.text(tabX + fontSize * .5, fontSize * 9.75, 0, 0, mainText[3], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
    }
    if (showBCC === "true") {
        c.text(tabX - fontSize * .5, messX + fontSize * .75, 0, 0, "BCC", mxConstants.ALIGN_RIGHT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
        c.text(tabX + fontSize * .5, messX + fontSize * .75, 0, 0, mainText[4], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
        messX = messX + fontSize * 3
    }
    c.text(fontSize * .5, messX + fontSize * .75, 0, 0, mainText[5], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxShapeMockupEmailForm.prototype.cst.SHAPE_EMAIL_FORM, mxShapeMockupEmailForm);
function mxShapeMockupFormsRRect(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupFormsRRect, mxShape);
mxShapeMockupFormsRRect.prototype.cst = {
    RRECT: "mxgraph.mockup.forms.rrect",
    R_SIZE: "rSize"
};
mxShapeMockupFormsRRect.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupFormsRRect.prototype.cst.R_SIZE, "10"));
    c.roundrect(0, 0, w, h, rSize);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupFormsRRect.prototype.cst.RRECT, mxShapeMockupFormsRRect);
function mxShapeMockupFormsAnchor(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds
}
mxUtils.extend(mxShapeMockupFormsAnchor, mxShape);
mxShapeMockupFormsAnchor.prototype.cst = {
    ANCHOR: "mxgraph.mockup.forms.anchor"
};
mxShapeMockupFormsAnchor.prototype.paintVertexShape = function(c, x, y, w, h) {}
;
mxCellRenderer.registerShape(mxShapeMockupFormsAnchor.prototype.cst.ANCHOR, mxShapeMockupFormsAnchor);
function mxShapeMockupFormsCheckbox(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupFormsCheckbox, mxShape);
mxShapeMockupFormsCheckbox.prototype.cst = {
    CHECKBOX: "mxgraph.mockup.forms.checkbox"
};
mxShapeMockupFormsCheckbox.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.rect(0, 0, w, h);
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .8, h * .2);
    c.lineTo(w * .4, h * .8);
    c.lineTo(w * .25, h * .6);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupFormsCheckbox.prototype.cst.CHECKBOX, mxShapeMockupFormsCheckbox);
function mxShapeMockupFormsURect(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupFormsURect, mxShape);
mxShapeMockupFormsURect.prototype.cst = {
    U_RECT: "mxgraph.mockup.forms.uRect"
};
mxShapeMockupFormsURect.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.moveTo(0, h);
    c.lineTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupFormsURect.prototype.cst.U_RECT, mxShapeMockupFormsURect);
function mxShapeMockupBarChart(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupBarChart, mxShape);
mxShapeMockupBarChart.prototype.cst = {
    STROKE_COLOR2: "strokeColor2",
    STROKE_COLOR3: "strokeColor3",
    FILL_COLOR2: "fillColor2",
    FILL_COLOR3: "fillColor3",
    SHAPE_BAR_CHART: "mxgraph.mockup.graphics.barChart"
};
mxShapeMockupBarChart.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    var bgFill = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "none");
    if (bgFill !== "none")
        c.setShadow(false);
    this.bars(c, x, y, w, h)
}
;
mxShapeMockupBarChart.prototype.background = function(c, x, y, w, h, bgColor, frameColor) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupBarChart.prototype.bars = function(c, x, y, w, h) {
    var barStroke = mxUtils.getValue(this.style, mxShapeMockupBarChart.prototype.cst.STROKE_COLOR2, "none");
    var coordStroke = mxUtils.getValue(this.style, mxShapeMockupBarChart.prototype.cst.STROKE_COLOR3, "#666666");
    var barFill1 = mxUtils.getValue(this.style, mxShapeMockupBarChart.prototype.cst.FILL_COLOR2, "#008cff");
    var barFill2 = mxUtils.getValue(this.style, mxShapeMockupBarChart.prototype.cst.FILL_COLOR3, "#dddddd");
    var strokeWidth = mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, "1");
    c.setStrokeColor(barStroke);
    c.setFillColor(barFill1);
    c.rect(0, h * .2, w * .75, h * .05);
    c.fillAndStroke();
    c.rect(0, h * .45, w * .6, h * .05);
    c.fillAndStroke();
    c.rect(0, h * .7, w * .95, h * .05);
    c.fillAndStroke();
    c.setFillColor(barFill2);
    c.rect(0, h * .25, w * .85, h * .05);
    c.fillAndStroke();
    c.rect(0, h * .5, w * .65, h * .05);
    c.fillAndStroke();
    c.rect(0, h * .75, w * .8, h * .05);
    c.fillAndStroke();
    c.setStrokeWidth(strokeWidth * 2);
    c.setStrokeColor(coordStroke);
    c.setShadow(false);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(0, h);
    c.lineTo(w, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupBarChart.prototype.cst.SHAPE_BAR_CHART, mxShapeMockupBarChart);
function mxShapeMockupColumnChart(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupColumnChart, mxShape);
mxShapeMockupColumnChart.prototype.cst = {
    STROKE_COLOR2: "strokeColor2",
    STROKE_COLOR3: "strokeColor3",
    FILL_COLOR2: "fillColor2",
    FILL_COLOR3: "fillColor3",
    SHAPE_COLUMN_CHART: "mxgraph.mockup.graphics.columnChart"
};
mxShapeMockupColumnChart.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    var bgFill = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "none");
    if (bgFill !== "none")
        c.setShadow(false);
    this.bars(c, x, y, w, h)
}
;
mxShapeMockupColumnChart.prototype.background = function(c, x, y, w, h, bgColor, frameColor) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupColumnChart.prototype.bars = function(c, x, y, w, h) {
    var barStroke = mxUtils.getValue(this.style, mxShapeMockupColumnChart.prototype.cst.STROKE_COLOR2, "none");
    var coordStroke = mxUtils.getValue(this.style, mxShapeMockupColumnChart.prototype.cst.STROKE_COLOR3, "#666666");
    var barFill1 = mxUtils.getValue(this.style, mxShapeMockupColumnChart.prototype.cst.FILL_COLOR2, "#008cff");
    var barFill2 = mxUtils.getValue(this.style, mxShapeMockupColumnChart.prototype.cst.FILL_COLOR3, "#dddddd");
    var strokeWidth = mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, "1");
    c.setStrokeColor(barStroke);
    c.setFillColor(barFill1);
    c.rect(w * .2, h * .25, w * .05, h * .75);
    c.fillAndStroke();
    c.rect(w * .45, h * .4, w * .05, h * .6);
    c.fillAndStroke();
    c.rect(w * .7, h * .05, w * .05, h * .95);
    c.fillAndStroke();
    c.setFillColor(barFill2);
    c.rect(w * .25, h * .15, w * .05, h * .85);
    c.fillAndStroke();
    c.rect(w * .5, h * .35, w * .05, h * .65);
    c.fillAndStroke();
    c.rect(w * .75, h * .2, w * .05, h * .8);
    c.fillAndStroke();
    c.setStrokeWidth(strokeWidth * 2);
    c.setStrokeColor(coordStroke);
    c.setShadow(false);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(0, h);
    c.lineTo(w, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupColumnChart.prototype.cst.SHAPE_COLUMN_CHART, mxShapeMockupColumnChart);
function mxShapeMockupLineChart(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupLineChart, mxShape);
mxShapeMockupLineChart.prototype.cst = {
    STROKE_COLOR2: "strokeColor2",
    STROKE_COLOR3: "strokeColor3",
    STROKE_COLOR4: "strokeColor4",
    SHAPE_LINE_CHART: "mxgraph.mockup.graphics.lineChart"
};
mxShapeMockupLineChart.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    var bgFill = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "none");
    if (bgFill !== "none")
        c.setShadow(false);
    this.bars(c, x, y, w, h)
}
;
mxShapeMockupLineChart.prototype.background = function(c, x, y, w, h, bgColor, frameColor) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupLineChart.prototype.bars = function(c, x, y, w, h) {
    var coordStroke = mxUtils.getValue(this.style, mxShapeMockupLineChart.prototype.cst.STROKE_COLOR2, "#666666");
    var line1Stroke = mxUtils.getValue(this.style, mxShapeMockupLineChart.prototype.cst.STROKE_COLOR3, "#008cff");
    var line2Stroke = mxUtils.getValue(this.style, mxShapeMockupLineChart.prototype.cst.STROKE_COLOR4, "#dddddd");
    var strokeWidth = mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, "1");
    c.setStrokeWidth(strokeWidth * 2);
    c.setStrokeColor(line2Stroke);
    c.begin();
    c.moveTo(0, h);
    c.lineTo(w * .3, h * .5);
    c.lineTo(w * .6, h * .74);
    c.lineTo(w * .9, h * .24);
    c.stroke();
    c.setStrokeColor(line1Stroke);
    c.begin();
    c.moveTo(0, h);
    c.lineTo(w * .3, h * .65);
    c.lineTo(w * .6, h * .6);
    c.lineTo(w * .9, h * .35);
    c.stroke();
    c.setStrokeColor(coordStroke);
    c.setShadow(false);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(0, h);
    c.lineTo(w, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupLineChart.prototype.cst.SHAPE_LINE_CHART, mxShapeMockupLineChart);
function mxShapeMockupPieChart(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupPieChart, mxShape);
mxShapeMockupPieChart.prototype.cst = {
    PARTS: "parts",
    PART_COLORS: "partColors",
    SHAPE_PIE_CHART: "mxgraph.mockup.graphics.pieChart"
};
mxShapeMockupPieChart.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeMockupPieChart.prototype.background = function(c, x, y, w, h, bgColor, frameColor) {
    c.ellipse(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupPieChart.prototype.foreground = function(c, x, y, w, h) {
    var parts = mxUtils.getValue(this.style, mxShapeMockupPieChart.prototype.cst.PARTS, "10,20,30").toString().split(",");
    var partNum = parts.length;
    var partColors = mxUtils.getValue(this.style, mxShapeMockupPieChart.prototype.cst.PART_COLORS, "#333333,#666666,#999999").toString().split(",");
    var total = 0;
    for (var i = 0; i < partNum; i++)
        total = total + parseInt(parts[i], 10);
    for (var i = 0; i < partNum; i++) {
        if (partColors.length > i)
            c.setFillColor(partColors[i]);
        else
            c.setFillColor("#ff0000");
        var beginPerc = 0;
        var endPerc = 0;
        var currPerc = parseInt(parts[i], 10) / total;
        if (currPerc === .5)
            currPerc = .501;
        for (var j = 0; j < i; j++)
            beginPerc = beginPerc + parseInt(parts[j], 10) / total;
        endPerc = currPerc + beginPerc;
        var startAngle = 2 * Math.PI * beginPerc;
        var endAngle = 2 * Math.PI * endPerc;
        var x1 = w * .5 - w * Math.sin(startAngle) * .5;
        var y1 = h * .5 - h * Math.cos(startAngle) * .5;
        var x2 = w * .5 - w * Math.sin(endAngle) * .5;
        var y2 = h * .5 - h * Math.cos(endAngle) * .5;
        var largeArc = 1;
        var sweep = 1;
        if (endPerc - beginPerc < .5)
            largeArc = 0;
        c.begin();
        c.moveTo(w * .5, h * .5);
        c.lineTo(x2, y2);
        c.arcTo(w * .5, h * .5, 0, largeArc, 1, x1, y1);
        c.close();
        c.fillAndStroke()
    }
}
;
mxCellRenderer.registerShape(mxShapeMockupPieChart.prototype.cst.SHAPE_PIE_CHART, mxShapeMockupPieChart);
function mxShapeMockupIconGrid(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupIconGrid, mxShape);
mxShapeMockupIconGrid.prototype.cst = {
    GRID_SIZE: "gridSize",
    SHAPE_ICON_GRID: "mxgraph.mockup.graphics.iconGrid"
};
mxShapeMockupIconGrid.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var gridSize = mxUtils.getValue(this.style, mxShapeMockupIconGrid.prototype.cst.GRID_SIZE, "3,3").toString().split(",");
    this.background(c, w, h, gridSize);
    c.setShadow(false);
    this.foreground(c, w, h, gridSize)
}
;
mxShapeMockupIconGrid.prototype.background = function(c, w, h, gridSize) {
    var boxSizeX = w / (parseInt(gridSize[0], 10) + (gridSize[0] - 1) * .5);
    var boxSizeY = h / (parseInt(gridSize[1], 10) + (gridSize[1] - 1) * .5);
    for (var i = 0; i < gridSize[0]; i++)
        for (var j = 0; j < gridSize[1]; j++) {
            c.rect(boxSizeX * 1.5 * i, boxSizeY * 1.5 * j, boxSizeX, boxSizeY);
            c.fillAndStroke()
        }
}
;
mxShapeMockupIconGrid.prototype.foreground = function(c, w, h, gridSize) {
    var boxSizeX = w / (parseInt(gridSize[0], 10) + (gridSize[0] - 1) * .5);
    var boxSizeY = h / (parseInt(gridSize[1], 10) + (gridSize[1] - 1) * .5);
    for (var i = 0; i < gridSize[0]; i++)
        for (var j = 0; j < gridSize[1]; j++) {
            c.begin();
            c.moveTo(boxSizeX * 1.5 * i, boxSizeY * 1.5 * j);
            c.lineTo(boxSizeX * 1.5 * i + boxSizeX, boxSizeY * 1.5 * j + boxSizeY);
            c.moveTo(boxSizeX * 1.5 * i + boxSizeX, boxSizeY * 1.5 * j);
            c.lineTo(boxSizeX * 1.5 * i, boxSizeY * 1.5 * j + boxSizeY);
            c.stroke()
        }
}
;
mxCellRenderer.registerShape(mxShapeMockupIconGrid.prototype.cst.SHAPE_ICON_GRID, mxShapeMockupIconGrid);
function mxShapeMockupBubbleChart(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupBubbleChart, mxShape);
mxShapeMockupBubbleChart.prototype.cst = {
    STROKE_COLOR2: "strokeColor2",
    STROKE_COLOR3: "strokeColor3",
    FILL_COLOR2: "fillColor2",
    FILL_COLOR3: "fillColor3",
    SHAPE_BUBBLE_CHART: "mxgraph.mockup.graphics.bubbleChart"
};
mxShapeMockupBubbleChart.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    var bgFill = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "none");
    if (bgFill !== "none")
        c.setShadow(false);
    this.bars(c, x, y, w, h)
}
;
mxShapeMockupBubbleChart.prototype.background = function(c, x, y, w, h, bgColor, frameColor) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupBubbleChart.prototype.bars = function(c, x, y, w, h) {
    var barStroke = mxUtils.getValue(this.style, mxShapeMockupBubbleChart.prototype.cst.STROKE_COLOR2, "none");
    var coordStroke = mxUtils.getValue(this.style, mxShapeMockupBubbleChart.prototype.cst.STROKE_COLOR3, "#666666");
    var barFill1 = mxUtils.getValue(this.style, mxShapeMockupBubbleChart.prototype.cst.FILL_COLOR2, "#008cff");
    var barFill2 = mxUtils.getValue(this.style, mxShapeMockupBubbleChart.prototype.cst.FILL_COLOR3, "#dddddd");
    var strokeWidth = mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, "1");
    c.setStrokeColor(barStroke);
    c.setFillColor(barFill1);
    var cx = w * .4;
    var cy = h * .45;
    var r = Math.min(h, w) * .14;
    c.ellipse(cx - r, cy - r, 2 * r, 2 * r);
    c.fillAndStroke();
    cx = w * .1;
    cy = h * .8;
    r = Math.min(h, w) * .1;
    c.ellipse(cx - r, cy - r, 2 * r, 2 * r);
    c.fillAndStroke();
    cx = w * .7;
    cy = h * .7;
    r = Math.min(h, w) * .22;
    c.ellipse(cx - r, cy - r, 2 * r, 2 * r);
    c.fillAndStroke();
    c.setFillColor(barFill2);
    cx = w * .15;
    cy = h * .25;
    r = Math.min(h, w) * .19;
    c.ellipse(cx - r, cy - r, 2 * r, 2 * r);
    c.fillAndStroke();
    cx = w * .48;
    cy = h * .7;
    r = Math.min(h, w) * .12;
    c.ellipse(cx - r, cy - r, 2 * r, 2 * r);
    c.fillAndStroke();
    cx = w * .74;
    cy = h * .17;
    r = Math.min(h, w) * .1;
    c.ellipse(cx - r, cy - r, 2 * r, 2 * r);
    c.fillAndStroke();
    c.setStrokeWidth(strokeWidth * 2);
    c.setStrokeColor(coordStroke);
    c.setShadow(false);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(0, h);
    c.lineTo(w, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupBubbleChart.prototype.cst.SHAPE_BUBBLE_CHART, mxShapeMockupBubbleChart);
function mxShapeMockupGauge(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.gaugePos = 25
}
mxUtils.extend(mxShapeMockupGauge, mxShape);
mxShapeMockupGauge.prototype.cst = {
    SCALE_COLORS: "scaleColors",
    GAUGE_LABELS: "gaugeLabels",
    NEEDLE_COLOR: "needleColor",
    TEXT_COLOR: "textColor",
    TEXT_SIZE: "textSize",
    GAUGE_POS: "gaugePos",
    SHAPE_GAUGE: "mxgraph.mockup.graphics.gauge"
};
mxShapeMockupGauge.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxShapeMockupGauge.prototype.background = function(c, w, h) {
    c.ellipse(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupGauge.prototype.foreground = function(c, w, h) {
    var gaugePos = mxUtils.getValue(this.style, mxShapeMockupGauge.prototype.cst.GAUGE_POS, "0");
    var scaleColors = mxUtils.getValue(this.style, mxShapeMockupGauge.prototype.cst.SCALE_COLORS, "#888888,#aaaaaa,#444444").toString().split(",");
    var gaugeLabels = mxUtils.getValue(this.style, mxShapeMockupGauge.prototype.cst.GAUGE_LABELS, "CPU[%],0,100").toString().split(",");
    var needleColor = mxUtils.getValue(this.style, mxShapeMockupGauge.prototype.cst.NEEDLE_COLOR, "#008cff");
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var textColor = mxUtils.getValue(this.style, mxShapeMockupGauge.prototype.cst.TEXT_COLOR, "#666666");
    var textSize = mxUtils.getValue(this.style, mxShapeMockupGauge.prototype.cst.TEXT_SIZE, "12");
    gaugePos = Math.max(0, gaugePos);
    gaugePos = Math.min(100, gaugePos);
    c.setFillColor(scaleColors[1]);
    c.begin();
    c.moveTo(w * .05, h * .5);
    c.arcTo(w * .4, h * .4, 0, 0, 1, w * .95, h * .5);
    c.lineTo(w, h * .5);
    c.arcTo(w * .5, h * .5, 0, 0, 0, 0, h * .5);
    c.close();
    c.fill();
    c.setFillColor(scaleColors[0]);
    c.begin();
    c.moveTo(w * .05, h * .5);
    c.arcTo(w * .45, h * .45, 0, 0, 0, w * .182, h * .818);
    c.lineTo(w * .146, h * .854);
    c.arcTo(w * .5, h * .5, 0, 0, 1, 0, h * .5);
    c.close();
    c.fill();
    c.setFillColor(scaleColors[2]);
    c.begin();
    c.moveTo(w, h * .5);
    c.arcTo(w * .5, h * .5, 0, 0, 1, w * .854, h * .854);
    c.lineTo(w * .818, h * .818);
    c.arcTo(w * .45, h * .45, 0, 0, 0, w * .95, h * .5);
    c.close();
    c.fill();
    c.setFontSize(textSize);
    c.setFontColor(textColor);
    c.text(w * .5, h * .3, 0, 0, gaugeLabels[0], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .2, h * .85, 0, 0, gaugeLabels[1], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .8, h * .85, 0, 0, gaugeLabels[2], mxConstants.ALIGN_RIGHT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    var needlePos = .75 * (2 * Math.PI * parseFloat(gaugePos) / 100) + 1.25 * Math.PI;
    var x1 = w * .5 + w * .38 * Math.sin(needlePos);
    var y1 = h * .5 - h * .38 * Math.cos(needlePos);
    var x2 = 0;
    var y2 = 0;
    c.setFillColor(needleColor);
    c.begin();
    c.moveTo(x1, y1);
    x1 = w * .5 + w * .05 * Math.cos(needlePos);
    y1 = h * .5 + h * .05 * Math.sin(needlePos);
    c.lineTo(x1, y1);
    x2 = w * .5 + w * -.05 * Math.sin(needlePos);
    y2 = h * .5 - h * -.05 * Math.cos(needlePos);
    c.arcTo(w * .05, h * .05, 0, 0, 1, x2, y2);
    x1 = x2;
    y1 = y2;
    x2 = w * .5 - w * .05 * Math.cos(needlePos);
    y2 = h * .5 - h * .05 * Math.sin(needlePos);
    c.arcTo(w * .05, h * .05, 0, 0, 1, x2, y2);
    c.close();
    c.fill();
    c.setFillColor(fillColor);
    c.begin();
    c.moveTo(w * .49, h * .49);
    c.lineTo(w * .51, h * .49);
    c.lineTo(w * .51, h * .51);
    c.lineTo(w * .49, h * .51);
    c.close();
    c.fill();
    c.begin();
    c.ellipse(0, 0, w, h);
    c.stroke();
    c.begin();
    c.moveTo(w * .146, h * .854);
    c.lineTo(w * .219, h * .781);
    c.moveTo(w * .854, h * .854);
    c.lineTo(w * .781, h * .781);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupGauge.prototype.cst.SHAPE_GAUGE, mxShapeMockupGauge);
Graph.handleFactory[mxShapeMockupGauge.prototype.cst.SHAPE_GAUGE] = function(state) {
    var handles = [Graph.createHandle(state, ["gaugePos"], function(bounds) {
        var gaugePos = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, "gaugePos", this.gaugePos))));
        return new mxPoint(bounds.x + bounds.width * .2 + gaugePos * .6 * bounds.width / 100,bounds.y + bounds.height * .8)
    }, function(bounds, pt) {
        this.state.style["gaugePos"] = Math.round(1E3 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 1E3
    })];
    return handles
}
;
function mxShapeMockupPlotChart(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupPlotChart, mxShape);
mxShapeMockupPlotChart.prototype.cst = {
    STROKE_COLOR2: "strokeColor2",
    STROKE_COLOR3: "strokeColor3",
    SHAPES_COLORS: "fillColor2",
    SHAPE_PLOT_CHART: "mxgraph.mockup.graphics.plotChart"
};
mxShapeMockupPlotChart.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    var bgFill = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "none");
    if (bgFill !== "none")
        c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeMockupPlotChart.prototype.background = function(c, x, y, w, h, bgColor, frameColor) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupPlotChart.prototype.foreground = function(c, x, y, w, h) {
    var shapeStroke = mxUtils.getValue(this.style, mxShapeMockupPlotChart.prototype.cst.STROKE_COLOR2, "#dddddd");
    var coordStroke = mxUtils.getValue(this.style, mxShapeMockupPlotChart.prototype.cst.STROKE_COLOR3, "#666666");
    var shapesColors = mxUtils.getValue(this.style, mxShapeMockupPlotChart.prototype.cst.SHAPES_COLORS, "#00aaff,#0044ff,#008cff").toString().split(",");
    var strokeWidth = mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, "1");
    var shapeSize = Math.min(w, h) * .03;
    c.setStrokeColor(shapeStroke);
    c.setFillColor(shapesColors[0]);
    var cx = w * .2;
    var cy = h * .8;
    c.begin();
    c.moveTo(cx - shapeSize * .5, cy - shapeSize * .5);
    c.lineTo(cx + shapeSize * .5, cy - shapeSize * .5);
    c.lineTo(cx + shapeSize * .5, cy + shapeSize * .5);
    c.lineTo(cx - shapeSize * .5, cy + shapeSize * .5);
    c.close();
    c.fillAndStroke();
    cx = w * .3;
    cy = h * .65;
    c.begin();
    c.moveTo(cx - shapeSize * .5, cy - shapeSize * .5);
    c.lineTo(cx + shapeSize * .5, cy - shapeSize * .5);
    c.lineTo(cx + shapeSize * .5, cy + shapeSize * .5);
    c.lineTo(cx - shapeSize * .5, cy + shapeSize * .5);
    c.close();
    c.fillAndStroke();
    cx = w * .6;
    cy = h * .44;
    c.begin();
    c.moveTo(cx - shapeSize * .5, cy - shapeSize * .5);
    c.lineTo(cx + shapeSize * .5, cy - shapeSize * .5);
    c.lineTo(cx + shapeSize * .5, cy + shapeSize * .5);
    c.lineTo(cx - shapeSize * .5, cy + shapeSize * .5);
    c.close();
    c.fillAndStroke();
    cx = w * .85;
    cy = h * .9;
    c.begin();
    c.moveTo(cx - shapeSize * .5, cy - shapeSize * .5);
    c.lineTo(cx + shapeSize * .5, cy - shapeSize * .5);
    c.lineTo(cx + shapeSize * .5, cy + shapeSize * .5);
    c.lineTo(cx - shapeSize * .5, cy + shapeSize * .5);
    c.close();
    c.fillAndStroke();
    c.setFillColor(shapesColors[1]);
    cx = w * .08;
    cy = h * .65;
    c.begin();
    c.moveTo(cx, cy - shapeSize * .5);
    c.lineTo(cx + shapeSize * .5, cy + shapeSize * .5);
    c.lineTo(cx - shapeSize * .5, cy + shapeSize * .5);
    c.close();
    c.fillAndStroke();
    cx = w * .58;
    cy = h * .85;
    c.begin();
    c.moveTo(cx, cy - shapeSize * .5);
    c.lineTo(cx + shapeSize * .5, cy + shapeSize * .5);
    c.lineTo(cx - shapeSize * .5, cy + shapeSize * .5);
    c.close();
    c.fillAndStroke();
    cx = w * .72;
    cy = h * .92;
    c.begin();
    c.moveTo(cx, cy - shapeSize * .5);
    c.lineTo(cx + shapeSize * .5, cy + shapeSize * .5);
    c.lineTo(cx - shapeSize * .5, cy + shapeSize * .5);
    c.close();
    c.fillAndStroke();
    c.setFillColor(shapesColors[2]);
    cx = w * .32;
    cy = h * .28;
    c.begin();
    c.moveTo(cx, cy - shapeSize * .75);
    c.lineTo(cx + shapeSize * .75, cy);
    c.lineTo(cx, cy + shapeSize * .75);
    c.lineTo(cx - shapeSize * .75, cy);
    c.close();
    c.fillAndStroke();
    cx = w * .92;
    cy = h * .45;
    c.begin();
    c.moveTo(cx, cy - shapeSize * .75);
    c.lineTo(cx + shapeSize * .75, cy);
    c.lineTo(cx, cy + shapeSize * .75);
    c.lineTo(cx - shapeSize * .75, cy);
    c.close();
    c.fillAndStroke();
    cx = w * .81;
    cy = h * .37;
    c.begin();
    c.moveTo(cx, cy - shapeSize * .75);
    c.lineTo(cx + shapeSize * .75, cy);
    c.lineTo(cx, cy + shapeSize * .75);
    c.lineTo(cx - shapeSize * .75, cy);
    c.close();
    c.fillAndStroke();
    cx = w * .51;
    cy = h * .7;
    c.begin();
    c.moveTo(cx, cy - shapeSize * .75);
    c.lineTo(cx + shapeSize * .75, cy);
    c.lineTo(cx, cy + shapeSize * .75);
    c.lineTo(cx - shapeSize * .75, cy);
    c.close();
    c.fillAndStroke();
    c.setStrokeWidth(strokeWidth * 2);
    c.setStrokeColor(coordStroke);
    c.setShadow(false);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(0, h);
    c.lineTo(w, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupPlotChart.prototype.cst.SHAPE_PLOT_CHART, mxShapeMockupPlotChart);
function mxShapeMockupGanttChart(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupGanttChart, mxShape);
mxShapeMockupGanttChart.prototype.cst = {
    STROKE_COLOR2: "strokeColor2",
    STROKE_COLOR3: "strokeColor3",
    SHAPES_COLORS: "fillColor2",
    TEXT_COLOR: "textColor",
    TEXT_SIZE: "textSize",
    SHAPE_GANTT_CHART: "mxgraph.mockup.graphics.ganttChart"
};
mxShapeMockupGanttChart.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeMockupGanttChart.prototype.background = function(c, x, y, w, h, bgColor, frameColor) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupGanttChart.prototype.foreground = function(c, x, y, w, h) {
    var shapesColors = mxUtils.getValue(this.style, mxShapeMockupGanttChart.prototype.cst.SHAPES_COLORS, "#888888,#bbbbbb").toString().split(",");
    var textColor = mxUtils.getValue(this.style, mxShapeMockupGanttChart.prototype.cst.TEXT_COLOR, "#666666");
    var textSize = mxUtils.getValue(this.style, mxShapeMockupGanttChart.prototype.cst.TEXT_SIZE, "#12");
    c.begin();
    c.moveTo(0, h * .13);
    c.lineTo(w, h * .13);
    c.moveTo(w * .4, 0);
    c.lineTo(w * .4, h);
    c.moveTo(w * .4, h * .065);
    c.lineTo(w, h * .065);
    c.moveTo(w * .03, 0);
    c.lineTo(w * .03, h * .13);
    c.moveTo(w * .1, 0);
    c.lineTo(w * .1, h * .13);
    c.moveTo(w * .315, 0);
    c.lineTo(w * .315, h * .13);
    c.moveTo(w * .45, h * .065);
    c.lineTo(w * .45, h * .13);
    c.moveTo(w * .5, h * .065);
    c.lineTo(w * .5, h);
    c.moveTo(w * .55, h * .065);
    c.lineTo(w * .55, h * .13);
    c.moveTo(w * .6, h * .065);
    c.lineTo(w * .6, h);
    c.moveTo(w * .65, h * .065);
    c.lineTo(w * .65, h * .13);
    c.moveTo(w * .7, h * .065);
    c.lineTo(w * .7, h);
    c.moveTo(w * .75, 0);
    c.lineTo(w * .75, h * .13);
    c.moveTo(w * .8, h * .065);
    c.lineTo(w * .8, h);
    c.moveTo(w * .85, h * .065);
    c.lineTo(w * .85, h * .13);
    c.moveTo(w * .9, h * .065);
    c.lineTo(w * .9, h);
    c.moveTo(w * .95, h * .065);
    c.lineTo(w * .95, h * .13);
    c.stroke();
    c.setFillColor(shapesColors[0]);
    c.begin();
    c.moveTo(w * .41, h * .15);
    c.lineTo(w * .64, h * .15);
    c.lineTo(w * .64, h * .18);
    c.lineTo(w * .625, h * .21);
    c.lineTo(w * .61, h * .18);
    c.lineTo(w * .44, h * .18);
    c.lineTo(w * .425, h * .21);
    c.lineTo(w * .41, h * .18);
    c.close();
    c.moveTo(w * .41, h * .24);
    c.lineTo(w * .49, h * .24);
    c.lineTo(w * .49, h * .275);
    c.lineTo(w * .41, h * .275);
    c.close();
    c.moveTo(w * .46, h * .31);
    c.lineTo(w * .64, h * .31);
    c.lineTo(w * .64, h * .345);
    c.lineTo(w * .46, h * .345);
    c.close();
    c.moveTo(w * .56, h * .39);
    c.lineTo(w * .69, h * .39);
    c.lineTo(w * .69, h * .425);
    c.lineTo(w * .56, h * .425);
    c.close();
    c.fill();
    c.setFillColor(shapesColors[1]);
    c.begin();
    c.moveTo(w * .46, h * .32);
    c.lineTo(w * .58, h * .32);
    c.lineTo(w * .58, h * .335);
    c.lineTo(w * .46, h * .335);
    c.close();
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeMockupGanttChart.prototype.cst.SHAPE_GANTT_CHART, mxShapeMockupGanttChart);
function mxShapeMockupSimpleIcon(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupSimpleIcon, mxShape);
mxShapeMockupSimpleIcon.prototype.cst = {
    SIMPLE_ICON: "mxgraph.mockup.graphics.simpleIcon"
};
mxShapeMockupSimpleIcon.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.rect(0, 0, w, h);
    c.fillAndStroke();
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, h);
    c.moveTo(0, h);
    c.lineTo(w, 0);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupSimpleIcon.prototype.cst.SIMPLE_ICON, mxShapeMockupSimpleIcon);
function mxShapeMockupGraphicsAnchor(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds
}
mxUtils.extend(mxShapeMockupGraphicsAnchor, mxShape);
mxShapeMockupGraphicsAnchor.prototype.cst = {
    ANCHOR: "mxgraph.mockup.graphics.anchor"
};
mxShapeMockupGraphicsAnchor.prototype.paintVertexShape = function(c, x, y, w, h) {}
;
mxCellRenderer.registerShape(mxShapeMockupGraphicsAnchor.prototype.cst.ANCHOR, mxShapeMockupGraphicsAnchor);
function mxShapeMockupGraphicsRRect(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupGraphicsRRect, mxShape);
mxShapeMockupGraphicsRRect.prototype.cst = {
    RRECT: "mxgraph.mockup.graphics.rrect",
    R_SIZE: "rSize"
};
mxShapeMockupGraphicsRRect.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupGraphicsRRect.prototype.cst.R_SIZE, "10"));
    c.roundrect(0, 0, w, h, rSize);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupGraphicsRRect.prototype.cst.RRECT, mxShapeMockupGraphicsRRect);
function mxShapeMockupCurlyBrace(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupCurlyBrace, mxShape);
mxShapeMockupCurlyBrace.prototype.cst = {
    SHAPE_CURLY_BRACE: "mxgraph.mockup.markup.curlyBrace"
};
mxShapeMockupCurlyBrace.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h)
}
;
mxShapeMockupCurlyBrace.prototype.background = function(c, x, y, w, h) {
    var midY = h * .5;
    var rSize = Math.min(w * .125, midY);
    c.begin();
    c.moveTo(0, midY + rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, midY);
    c.lineTo(w * .5 - rSize, midY);
    c.arcTo(rSize, rSize, 0, 0, 0, w * .5, midY - rSize);
    c.arcTo(rSize, rSize, 0, 0, 0, w * .5 + rSize, midY);
    c.lineTo(w - rSize, midY);
    c.arcTo(rSize, rSize, 0, 0, 1, w, midY + rSize);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupCurlyBrace.prototype.cst.SHAPE_CURLY_BRACE, mxShapeMockupCurlyBrace);
function mxShapeMockupLine(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupLine, mxShape);
mxShapeMockupLine.prototype.cst = {
    SHAPE_LINE: "mxgraph.mockup.markup.line"
};
mxShapeMockupLine.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(w, h * .5);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupLine.prototype.cst.SHAPE_LINE, mxShapeMockupLine);
function mxShapeMockupScratchOut(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupScratchOut, mxShape);
mxShapeMockupScratchOut.prototype.cst = {
    SHAPE_SCRATCH_OUT: "mxgraph.mockup.markup.scratchOut"
};
mxShapeMockupScratchOut.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.moveTo(w * .038, h * .095);
    c.curveTo(w * .038, h * .095, w * .289, h * -.045, w * .186, h * .05);
    c.curveTo(w * .084, h * .145, w * -.046, h * .251, w * .072, h * .208);
    c.curveTo(w * .191, h * .164, w * .522, h * -.09, w * .366, h * .062);
    c.curveTo(w * .21, h * .215, w * -.094, h * .38, w * .108, h * .304);
    c.curveTo(w * .309, h * .228, w * .73, h * -.126, w * .544, h * .096);
    c.curveTo(w * .358, h * .319, w * -.168, h * .592, w * .108, h * .476);
    c.curveTo(w * .382, h * .36, w * .972, h * -.138, w * .779, h * .114);
    c.curveTo(w * .585, h * .365, w * -.12, h * .688, w * .071, h * .639);
    c.curveTo(w * .262, h * .59, w * 1.174, h * .012, w * .936, h * .238);
    c.curveTo(w * .699, h * .462, w * -.216, h * .855, w * .085, h * .806);
    c.curveTo(w * .386, h * .758, w * 1.185, h * .26, w * .935, h * .534);
    c.curveTo(w * .685, h * .808, w * -.186, h * .94, w * .236, h * .895);
    c.curveTo(w * .659, h * .85, w * 1.095, h * .608, w * .905, h * .769);
    c.curveTo(w * .715, h * .93, w * .286, h * .962, w * .661, h * .931);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupScratchOut.prototype.cst.SHAPE_SCRATCH_OUT, mxShapeMockupScratchOut);
function mxShapeMockupRedX(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupRedX, mxShape);
mxShapeMockupRedX.prototype.cst = {
    SHAPE_RED_X: "mxgraph.mockup.markup.redX"
};
mxShapeMockupRedX.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.moveTo(w * .1, 0);
    c.lineTo(w * .5, h * .4);
    c.lineTo(w * .9, 0);
    c.lineTo(w, h * .1);
    c.lineTo(w * .6, h * .5);
    c.lineTo(w, h * .9);
    c.lineTo(w * .9, h);
    c.lineTo(w * .5, h * .6);
    c.lineTo(w * .1, h);
    c.lineTo(0, h * .9);
    c.lineTo(w * .4, h * .5);
    c.lineTo(0, h * .1);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupRedX.prototype.cst.SHAPE_RED_X, mxShapeMockupRedX);
function mxShapeMockupPlaybackControls(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupPlaybackControls, mxShape);
mxShapeMockupPlaybackControls.prototype.cst = {
    SHAPE_PLAYBACK_CONTROLS: "mxgraph.mockup.misc.playbackControls",
    FILL_COLOR2: "fillColor2",
    STROKE_COLOR2: "strokeColor2",
    FILL_COLOR3: "fillColor3",
    STROKE_COLOR3: "strokeColor3"
};
mxShapeMockupPlaybackControls.prototype.paintVertexShape = function(c, x, y, w, h) {
    var controlBarHeight = 30;
    var buttonSize = 22;
    var h = Math.max(h, controlBarHeight);
    var w = Math.max(225, w);
    c.translate(x, y);
    this.background(c, w, h, controlBarHeight);
    c.setShadow(false);
    this.foreground(c, w, h, controlBarHeight, buttonSize)
}
;
mxShapeMockupPlaybackControls.prototype.background = function(c, w, h, controlBarHeight) {
    c.rect(0, (h - controlBarHeight) * .5, w, controlBarHeight);
    c.fillAndStroke()
}
;
mxShapeMockupPlaybackControls.prototype.foreground = function(c, w, h, controlBarHeight, buttonSize) {
    var fillColor2 = mxUtils.getValue(this.style, mxShapeMockupPlaybackControls.prototype.cst.FILL_COLOR2, "#99ddff");
    var strokeColor2 = mxUtils.getValue(this.style, mxShapeMockupPlaybackControls.prototype.cst.STROKE_COLOR2, "none");
    var fillColor3 = mxUtils.getValue(this.style, mxShapeMockupPlaybackControls.prototype.cst.FILL_COLOR3, "#ffffff");
    var strokeColor3 = mxUtils.getValue(this.style, mxShapeMockupPlaybackControls.prototype.cst.STROKE_COLOR3, "none");
    c.setStrokeColor(strokeColor2);
    c.setFillColor(fillColor2);
    c.ellipse(10, h * .5 - buttonSize * .5, buttonSize, buttonSize);
    c.fillAndStroke();
    c.ellipse(40, h * .5 - buttonSize * .5, buttonSize, buttonSize);
    c.fillAndStroke();
    c.ellipse(70, h * .5 - buttonSize * .5, buttonSize, buttonSize);
    c.fillAndStroke();
    c.ellipse(100, h * .5 - buttonSize * .5, buttonSize, buttonSize);
    c.fillAndStroke();
    c.ellipse(130, h * .5 - buttonSize * .5, buttonSize, buttonSize);
    c.fillAndStroke();
    c.ellipse(160, h * .5 - buttonSize * .5, buttonSize, buttonSize);
    c.fillAndStroke();
    c.ellipse(190, h * .5 - buttonSize * .5, buttonSize, buttonSize);
    c.fillAndStroke();
    c.setStrokeColor(strokeColor3);
    c.setFillColor(fillColor3);
    var t = h * .5 - controlBarHeight * .5;
    c.begin();
    c.moveTo(16, t + 10);
    c.lineTo(16, t + 20);
    c.lineTo(18, t + 20);
    c.lineTo(18, t + 10);
    c.close();
    c.moveTo(20, t + 15);
    c.lineTo(25, t + 20);
    c.lineTo(25, t + 10);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(44, t + 15);
    c.lineTo(49, t + 20);
    c.lineTo(49, t + 10);
    c.close();
    c.moveTo(51, t + 15);
    c.lineTo(56, t + 20);
    c.lineTo(56, t + 10);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(77, t + 15);
    c.lineTo(82, t + 20);
    c.lineTo(82, t + 10);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(108, t + 10);
    c.lineTo(108, t + 20);
    c.lineTo(110, t + 20);
    c.lineTo(110, t + 10);
    c.close();
    c.moveTo(117, t + 15);
    c.lineTo(112, t + 20);
    c.lineTo(112, t + 10);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(144, t + 15);
    c.lineTo(139, t + 20);
    c.lineTo(139, t + 10);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(171, t + 15);
    c.lineTo(166, t + 20);
    c.lineTo(166, t + 10);
    c.close();
    c.moveTo(178, t + 15);
    c.lineTo(173, t + 20);
    c.lineTo(173, t + 10);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(203, t + 10);
    c.lineTo(203, t + 20);
    c.lineTo(205, t + 20);
    c.lineTo(205, t + 10);
    c.close();
    c.moveTo(201, t + 15);
    c.lineTo(196, t + 20);
    c.lineTo(196, t + 10);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupPlaybackControls.prototype.cst.SHAPE_PLAYBACK_CONTROLS, mxShapeMockupPlaybackControls);
function mxShapeMockupProgressBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.barPos = 20
}
mxUtils.extend(mxShapeMockupProgressBar, mxShape);
mxShapeMockupProgressBar.prototype.cst = {
    SHAPE_PROGRESS_BAR: "mxgraph.mockup.misc.progressBar",
    BAR_POS: "barPos",
    FILL_COLOR2: "fillColor2"
};
mxShapeMockupProgressBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxShapeMockupProgressBar.prototype.background = function(c, w, h) {
    c.roundrect(0, h * .5 - 5, w, 10, 5, 5);
    c.fillAndStroke()
}
;
mxShapeMockupProgressBar.prototype.foreground = function(c, w, h) {
    var fillColor2 = mxUtils.getValue(this.style, mxShapeMockupProgressBar.prototype.cst.FILL_COLOR2, "#ddeeff");
    var barPos = mxUtils.getValue(this.style, mxShapeMockupProgressBar.prototype.cst.BAR_POS, "80");
    barPos = Math.min(barPos, 100);
    barPos = Math.max(barPos, 0);
    var deadzone = 0;
    var virRange = w - 2 * deadzone;
    var truePos = deadzone + virRange * barPos / 100;
    c.setFillColor(fillColor2);
    c.roundrect(0, h * .5 - 5, truePos, 10, 5, 5);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupProgressBar.prototype.cst.SHAPE_PROGRESS_BAR, mxShapeMockupProgressBar);
Graph.handleFactory[mxShapeMockupProgressBar.prototype.cst.SHAPE_PROGRESS_BAR] = function(state) {
    var handles = [Graph.createHandle(state, ["barPos"], function(bounds) {
        var barPos = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, "barPos", this.barPos))));
        return new mxPoint(bounds.x + barPos * bounds.width / 100,bounds.y + bounds.height * .5)
    }, function(bounds, pt) {
        this.state.style["barPos"] = Math.round(1E3 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 1E3
    })];
    return handles
}
;
function mxShapeMockupShoppingCart(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupShoppingCart, mxShape);
mxShapeMockupShoppingCart.prototype.cst = {
    SHAPE_SHOPPING_CART: "mxgraph.mockup.misc.shoppingCart"
};
mxShapeMockupShoppingCart.prototype.paintVertexShape = function(c, x, y, w, h) {
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    c.translate(x, y);
    c.setStrokeWidth(3);
    c.begin();
    c.moveTo(w * .975, h * .025);
    c.lineTo(w * .82, h * .055);
    c.lineTo(w * .59, h * .66);
    c.lineTo(w * .7, h * .765);
    c.arcTo(w * .06, h * .06, 0, 0, 1, w * .665, h * .86);
    c.lineTo(w * .05, h * .86);
    c.moveTo(w * .74, h * .26);
    c.lineTo(w * .03, h * .28);
    c.lineTo(w * .065, h * .61);
    c.lineTo(w * .59, h * .66);
    c.stroke();
    c.setStrokeWidth(1);
    c.begin();
    c.moveTo(w * .15, h * .28);
    c.lineTo(w * .15, h * .62);
    c.moveTo(w * .265, h * .275);
    c.lineTo(w * .265, h * .63);
    c.moveTo(w * .38, h * .27);
    c.lineTo(w * .38, h * .64);
    c.moveTo(w * .495, h * .265);
    c.lineTo(w * .495, h * .65);
    c.moveTo(w * .61, h * .265);
    c.lineTo(w * .61, h * .61);
    c.stroke();
    c.begin();
    c.moveTo(w * .69, h * .405);
    c.lineTo(w * .045, h * .405);
    c.moveTo(w * .645, h * .52);
    c.lineTo(w * .055, h * .52);
    c.stroke();
    c.setFillColor(strokeColor);
    c.ellipse(w * .075, h * .89, w * .1, h * .1);
    c.fillAndStroke();
    c.ellipse(w * .62, h * .89, w * .1, h * .1);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupShoppingCart.prototype.cst.SHAPE_SHOPPING_CART, mxShapeMockupShoppingCart);
function mxShapeMockupRating(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupRating, mxShape);
mxShapeMockupRating.prototype.cst = {
    SHAPE_RATING: "mxgraph.mockup.misc.rating",
    RATING_STYLE: "ratingStyle",
    RATING_SCALE: "ratingScale",
    RATING_HEART: "heart",
    RATING_STAR: "star",
    EMPTY_FILL_COLOR: "emptyFillColor",
    GRADE: "grade"
};
mxShapeMockupRating.prototype.paintVertexShape = function(c, x, y, w, h) {
    var ratingStyle = mxUtils.getValue(this.style, mxShapeMockupRating.prototype.cst.RATING_STYLE, mxShapeMockupRating.prototype.cst.RATING_STAR);
    var grade = mxUtils.getValue(this.style, mxShapeMockupRating.prototype.cst.GRADE, "5");
    var ratingScale = mxUtils.getValue(this.style, mxShapeMockupRating.prototype.cst.RATING_SCALE, "10");
    c.translate(x, y);
    if (ratingStyle === mxShapeMockupRating.prototype.cst.RATING_STAR)
        for (var i = 0; i < grade; i++) {
            c.begin();
            c.moveTo(i * h * 1.5, .33 * h);
            c.lineTo(i * h * 1.5 + .364 * h, .33 * h);
            c.lineTo(i * h * 1.5 + .475 * h, 0);
            c.lineTo(i * h * 1.5 + .586 * h, .33 * h);
            c.lineTo(i * h * 1.5 + .95 * h, .33 * h);
            c.lineTo(i * h * 1.5 + .66 * h, .551 * h);
            c.lineTo(i * h * 1.5 + .775 * h, .9 * h);
            c.lineTo(i * h * 1.5 + .475 * h, .684 * h);
            c.lineTo(i * h * 1.5 + .175 * h, .9 * h);
            c.lineTo(i * h * 1.5 + .29 * h, .551 * h);
            c.close();
            c.fillAndStroke()
        }
    else if (ratingStyle === mxShapeMockupRating.prototype.cst.RATING_HEART)
        for (var i = 0; i < grade; i++) {
            c.begin();
            c.moveTo(i * h * 1.5 + h * .519, h * .947);
            c.curveTo(i * h * 1.5 + h * .558, h * .908, i * h * 1.5 + h * .778, h * .682, i * h * 1.5 + h * .916, h * .54);
            c.curveTo(i * h * 1.5 + h * 1.039, h * .414, i * h * 1.5 + h * 1.036, h * .229, i * h * 1.5 + h * .924, h * .115);
            c.curveTo(i * h * 1.5 + h * .812, 0, i * h * 1.5 + h * .631, 0, i * h * 1.5 + h * .519, h * .115);
            c.curveTo(i * h * 1.5 + h * .408, 0, i * h * 1.5 + h * .227, 0, i * h * 1.5 + h * .115, h * .115);
            c.curveTo(i * h * 1.5 + h * .03, h * .229, i * h * 1.5, h * .414, i * h * 1.5 + h * .123, h * .54);
            c.close();
            c.fillAndStroke()
        }
    var emptyFillColor = mxUtils.getValue(this.style, mxShapeMockupRating.prototype.cst.EMPTY_FILL_COLOR, "#ffffff");
    c.setFillColor(emptyFillColor);
    if (ratingStyle === mxShapeMockupRating.prototype.cst.RATING_STAR)
        for (var i = grade; i < ratingScale; i++) {
            c.begin();
            c.moveTo(i * h * 1.5, .33 * h);
            c.lineTo(i * h * 1.5 + .364 * h, .33 * h);
            c.lineTo(i * h * 1.5 + .475 * h, 0);
            c.lineTo(i * h * 1.5 + .586 * h, .33 * h);
            c.lineTo(i * h * 1.5 + .95 * h, .33 * h);
            c.lineTo(i * h * 1.5 + .66 * h, .551 * h);
            c.lineTo(i * h * 1.5 + .775 * h, .9 * h);
            c.lineTo(i * h * 1.5 + .475 * h, .684 * h);
            c.lineTo(i * h * 1.5 + .175 * h, .9 * h);
            c.lineTo(i * h * 1.5 + .29 * h, .551 * h);
            c.close();
            c.fillAndStroke()
        }
    else if (ratingStyle === mxShapeMockupRating.prototype.cst.RATING_HEART)
        for (var i = grade; i < ratingScale; i++) {
            c.begin();
            c.moveTo(i * h * 1.5 + h * .519, h * .947);
            c.curveTo(i * h * 1.5 + h * .558, h * .908, i * h * 1.5 + h * .778, h * .682, i * h * 1.5 + h * .916, h * .54);
            c.curveTo(i * h * 1.5 + h * 1.039, h * .414, i * h * 1.5 + h * 1.036, h * .229, i * h * 1.5 + h * .924, h * .115);
            c.curveTo(i * h * 1.5 + h * .812, 0, i * h * 1.5 + h * .631, 0, i * h * 1.5 + h * .519, h * .115);
            c.curveTo(i * h * 1.5 + h * .408, 0, i * h * 1.5 + h * .227, 0, i * h * 1.5 + h * .115, h * .115);
            c.curveTo(i * h * 1.5 + h * .03, h * .229, i * h * 1.5, h * .414, i * h * 1.5 + h * .123, h * .54);
            c.close();
            c.fillAndStroke()
        }
}
;
mxCellRenderer.registerShape(mxShapeMockupRating.prototype.cst.SHAPE_RATING, mxShapeMockupRating);
function mxShapeMockupMail(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupMail, mxShape);
mxShapeMockupMail.prototype.cst = {
    SHAPE_MAIL: "mxgraph.mockup.misc.mail2"
};
mxShapeMockupMail.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.rect(0, 0, w, h);
    c.fillAndStroke();
    c.setShadow(false);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w * .5, h * .5);
    c.lineTo(w, 0);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupMail.prototype.cst.SHAPE_MAIL, mxShapeMockupMail);
function mxShapeMockupVolumeSlider(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.barPos = 80
}
mxUtils.extend(mxShapeMockupVolumeSlider, mxShape);
mxShapeMockupVolumeSlider.prototype.cst = {
    SHAPE_VOLUME_SLIDER: "mxgraph.mockup.misc.volumeSlider",
    BAR_POS: "barPos",
    FILL_COLOR2: "fillColor2"
};
mxShapeMockupVolumeSlider.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var barPos = mxUtils.getValue(this.style, mxShapeMockupVolumeSlider.prototype.cst.BAR_POS, "80");
    var fillColor2 = mxUtils.getValue(this.style, mxShapeMockupVolumeSlider.prototype.cst.FILL_COLOR2, "#ddeeff");
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#999999");
    barPos = Math.min(barPos, 100);
    barPos = Math.max(barPos, 0);
    var controlBarHeight = 25;
    var h = Math.max(h, controlBarHeight);
    var w = Math.max(w, 3.5 * controlBarHeight);
    var speakerStartX = w - controlBarHeight;
    var speakerStartY = (h - controlBarHeight) * .5;
    c.begin();
    c.moveTo(speakerStartX + controlBarHeight * .05, speakerStartY + controlBarHeight * .35);
    c.lineTo(speakerStartX + controlBarHeight * .15, speakerStartY + controlBarHeight * .35);
    c.lineTo(speakerStartX + controlBarHeight * .3, speakerStartY + controlBarHeight * .2);
    c.lineTo(speakerStartX + controlBarHeight * .3, speakerStartY + controlBarHeight * .8);
    c.lineTo(speakerStartX + controlBarHeight * .15, speakerStartY + controlBarHeight * .65);
    c.lineTo(speakerStartX + controlBarHeight * .05, speakerStartY + controlBarHeight * .65);
    c.close();
    c.fill();
    var barMin = 0;
    var barMax = w - controlBarHeight * 1.3;
    var videoBarStartY = (h - controlBarHeight) * .5;
    var barRange = barMax - barMin;
    var barPos = barRange * barPos / 100;
    var barEnd = barMin + barPos;
    var soundStartX = w - controlBarHeight;
    var soundStartY = (h - controlBarHeight) * .5;
    c.begin();
    c.moveTo(soundStartX + controlBarHeight * .4, soundStartY + controlBarHeight * .35);
    c.arcTo(controlBarHeight * .2, controlBarHeight * .3, 0, 0, 1, soundStartX + controlBarHeight * .4, soundStartY + controlBarHeight * .65);
    c.moveTo(soundStartX + controlBarHeight * .425, soundStartY + controlBarHeight * .25);
    c.arcTo(controlBarHeight * .225, controlBarHeight * .35, 0, 0, 1, soundStartX + controlBarHeight * .425, soundStartY + controlBarHeight * .75);
    c.moveTo(soundStartX + controlBarHeight * .5, soundStartY + controlBarHeight * .2);
    c.arcTo(controlBarHeight * .25, controlBarHeight * .4, 0, 0, 1, soundStartX + controlBarHeight * .5, soundStartY + controlBarHeight * .8);
    c.fillAndStroke();
    var videoBarStartX = 0;
    var videoBarStartY = (h - controlBarHeight) * .5;
    var videoBarEndX = w - controlBarHeight * 1.3;
    c.roundrect(videoBarStartX, videoBarStartY + controlBarHeight * .35, videoBarEndX, controlBarHeight * .3, 5, 5);
    c.fill();
    c.setShadow(false);
    c.setFillColor(fillColor2);
    c.roundrect(barMin, videoBarStartY + controlBarHeight * .35, barEnd, controlBarHeight * .3, 5, 5);
    c.fill();
    c.ellipse(barEnd - controlBarHeight * .25, videoBarStartY + controlBarHeight * .25, controlBarHeight * .5, controlBarHeight * .5);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupVolumeSlider.prototype.cst.SHAPE_VOLUME_SLIDER, mxShapeMockupVolumeSlider);
Graph.handleFactory[mxShapeMockupVolumeSlider.prototype.cst.SHAPE_VOLUME_SLIDER] = function(state) {
    var handles = [Graph.createHandle(state, ["barPos"], function(bounds) {
        var barPos = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, "barPos", this.barPos))));
        return new mxPoint(bounds.x + barPos * (bounds.width - 32.5) / 100,bounds.y + bounds.height * .5)
    }, function(bounds, pt) {
        this.state.style["barPos"] = Math.round(1E3 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 1E3
    })];
    return handles
}
;
function mxShapeMockupEdit(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupEdit, mxShape);
mxShapeMockupEdit.prototype.cst = {
    SHAPE_EDIT: "mxgraph.mockup.misc.editIcon"
};
mxShapeMockupEdit.prototype.paintVertexShape = function(c, x, y, w, h) {
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#999999");
    c.translate(x, y);
    c.roundrect(0, 0, w, h, w * .05, h * .05);
    c.fillAndStroke();
    c.setShadow(false);
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .11, h * .8);
    c.lineTo(w * .2, h * .89);
    c.lineTo(w * .05, h * .95);
    c.close();
    c.moveTo(w * .74, h * .16);
    c.lineTo(w * .84, h * .26);
    c.lineTo(w * .22, h * .88);
    c.lineTo(w * .12, h * .78);
    c.close();
    c.moveTo(w * .755, h * .145);
    c.lineTo(w * .82, h * .08);
    c.lineTo(w * .92, h * .18);
    c.lineTo(w * .855, h * .245);
    c.close();
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeMockupEdit.prototype.cst.SHAPE_EDIT, mxShapeMockupEdit);
function mxShapeMockupPrint(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupPrint, mxShape);
mxShapeMockupPrint.prototype.cst = {
    SHAPE_PRINT: "mxgraph.mockup.misc.printIcon"
};
mxShapeMockupPrint.prototype.paintVertexShape = function(c, x, y, w, h) {
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#999999");
    c.translate(x, y);
    c.roundrect(0, 0, w, h, w * .05, h * .05);
    c.fillAndStroke();
    c.setShadow(false);
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .15, h * .58);
    c.arcTo(w * .03, h * .03, 0, 0, 1, w * .18, h * .55);
    c.lineTo(w * .82, h * .55);
    c.arcTo(w * .03, h * .03, 0, 0, 1, w * .85, h * .58);
    c.lineTo(w * .85, h * .82);
    c.arcTo(w * .03, h * .03, 0, 0, 1, w * .82, h * .85);
    c.lineTo(w * .18, h * .85);
    c.arcTo(w * .03, h * .03, 0, 0, 1, w * .15, h * .82);
    c.close();
    c.moveTo(w * .7, h * .52);
    c.lineTo(w * .3, h * .52);
    c.lineTo(w * .3, h * .15);
    c.lineTo(w * .55, h * .15);
    c.lineTo(w * .55, h * .3);
    c.lineTo(w * .7, h * .3);
    c.close();
    c.moveTo(w * .57, h * .15);
    c.lineTo(w * .7, h * .28);
    c.lineTo(w * .57, h * .28);
    c.close();
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeMockupPrint.prototype.cst.SHAPE_PRINT, mxShapeMockupPrint);
function mxShapeMockupShare(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupShare, mxShape);
mxShapeMockupShare.prototype.cst = {
    SHAPE_SHARE: "mxgraph.mockup.misc.shareIcon"
};
mxShapeMockupShare.prototype.paintVertexShape = function(c, x, y, w, h) {
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#999999");
    c.translate(x, y);
    c.roundrect(0, 0, w, h, w * .05, h * .05);
    c.fillAndStroke();
    c.setShadow(false);
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .15, h * .18);
    c.arcTo(w * .03, h * .03, 0, 0, 1, w * .18, h * .15);
    c.lineTo(w * .82, h * .15);
    c.arcTo(w * .03, h * .03, 0, 0, 1, w * .85, h * .18);
    c.lineTo(w * .85, h * .82);
    c.arcTo(w * .03, h * .03, 0, 0, 1, w * .82, h * .85);
    c.lineTo(w * .18, h * .85);
    c.arcTo(w * .03, h * .03, 0, 0, 1, w * .15, h * .82);
    c.close();
    c.fill();
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    c.setFillColor(fillColor);
    c.begin();
    c.moveTo(w * .563, h * .34);
    c.arcTo(w * .095, h * .095, 0, 1, 1, w * .603, h * .42);
    c.lineTo(w * .44, h * .5);
    c.lineTo(w * .602, h * .582);
    c.arcTo(w * .095, h * .095, 0, 1, 1, w * .563, h * .653);
    c.lineTo(w * .403, h * .575);
    c.arcTo(w * .095, h * .095, 0, 1, 1, w * .4, h * .42);
    c.close();
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeMockupShare.prototype.cst.SHAPE_SHARE, mxShapeMockupShare);
function mxShapeMockupTrashcan(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupTrashcan, mxShape);
mxShapeMockupTrashcan.prototype.cst = {
    SHAPE_TRASHCAN: "mxgraph.mockup.misc.trashcanIcon"
};
mxShapeMockupTrashcan.prototype.paintVertexShape = function(c, x, y, w, h) {
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#999999");
    c.translate(x, y);
    c.roundrect(0, 0, w, h, w * .05, h * .05);
    c.fillAndStroke();
    c.setShadow(false);
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .24, h * .24);
    c.arcTo(w * .04, h * .04, 0, 0, 1, w * .24, h * .16);
    c.lineTo(w * .4, h * .16);
    c.lineTo(w * .4, h * .12);
    c.lineTo(w * .6, h * .12);
    c.lineTo(w * .6, h * .16);
    c.lineTo(w * .76, h * .16);
    c.arcTo(w * .04, h * .04, 0, 0, 1, w * .76, h * .24);
    c.close();
    c.fill();
    c.roundrect(w * .26, h * .3, w * .1, h * .6, w * .06, h * .06);
    c.fill();
    c.roundrect(w * .44, h * .3, w * .1, h * .6, w * .06, h * .06);
    c.fill();
    c.roundrect(w * .62, h * .3, w * .1, h * .6, w * .06, h * .06);
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeMockupTrashcan.prototype.cst.SHAPE_TRASHCAN, mxShapeMockupTrashcan);
function mxShapeMockupCopyright(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupCopyright, mxShape);
mxShapeMockupCopyright.prototype.cst = {
    SHAPE_COPYRIGHT: "mxgraph.mockup.misc.copyrightIcon"
};
mxShapeMockupCopyright.prototype.paintVertexShape = function(c, x, y, w, h) {
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#999999");
    c.translate(x, y);
    c.ellipse(0, 0, w, h);
    c.fillAndStroke();
    c.setShadow(false);
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .713, h * .288);
    c.arcTo(w * .3, h * .3, 0, 1, 0, w * .713, h * .712);
    c.lineTo(w * .784, h * .783);
    c.arcTo(w * .4, h * .4, 0, 1, 1, w * .784, h * .217);
    c.close();
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeMockupCopyright.prototype.cst.SHAPE_COPYRIGHT, mxShapeMockupCopyright);
function mxShapeMockupRegistered(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupRegistered, mxShape);
mxShapeMockupRegistered.prototype.cst = {
    SHAPE_REGISTERED: "mxgraph.mockup.misc.registeredIcon"
};
mxShapeMockupRegistered.prototype.paintVertexShape = function(c, x, y, w, h) {
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#999999");
    c.translate(x, y);
    c.ellipse(0, 0, w, h);
    c.fillAndStroke();
    c.setShadow(false);
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .29, h * .9);
    c.lineTo(w * .29, h * .09);
    c.lineTo(w * .5, h * .09);
    c.arcTo(w * .2195, h * .2195, 0, 0, 1, w * .545, h * .525);
    c.lineTo(w * .738, h * .91);
    c.lineTo(w * .674, h * .91);
    c.lineTo(w * .4825, h * .53);
    c.lineTo(w * .35, h * .53);
    c.lineTo(w * .35, h * .9);
    c.close();
    c.moveTo(w * .35, h * .47);
    c.lineTo(w * .5, h * .47);
    c.arcTo(w * .15, h * .15, 0, 0, 0, w * .5, h * .15);
    c.lineTo(w * .35, h * .15);
    c.close();
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeMockupRegistered.prototype.cst.SHAPE_REGISTERED, mxShapeMockupRegistered);
function mxShapeMockupVolume(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupVolume, mxShape);
mxShapeMockupVolume.prototype.cst = {
    SHAPE_VOLUME: "mxgraph.mockup.misc.volumeIcon"
};
mxShapeMockupVolume.prototype.paintVertexShape = function(c, x, y, w, h) {
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#999999");
    c.translate(x, y);
    c.roundrect(0, 0, w, h, w * .05, h * .05);
    c.fillAndStroke();
    c.setShadow(false);
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .1, h * .3);
    c.lineTo(w * .3, h * .3);
    c.lineTo(w * .5, h * .15);
    c.lineTo(w * .5, h * .85);
    c.lineTo(w * .3, h * .7);
    c.lineTo(w * .1, h * .7);
    c.close();
    c.fill();
    c.begin();
    c.moveTo(w * .6, h * .4);
    c.arcTo(w * .2, h * .2, 0, 0, 1, w * .6, h * .6);
    c.moveTo(w * .7, h * .3);
    c.arcTo(w * .3, h * .3, 0, 0, 1, w * .7, h * .7);
    c.moveTo(w * .8, h * .2);
    c.arcTo(w * .4, h * .4, 0, 0, 1, w * .8, h * .8);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupVolume.prototype.cst.SHAPE_VOLUME, mxShapeMockupVolume);
function mxShapeMockupRuler(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupRuler, mxShape);
mxShapeMockupRuler.prototype.cst = {
    SHAPE_RULER: "mxgraph.mockup.misc.ruler",
    ORIENTATION: "rulerOrient",
    UNIT_SIZE: "unitSize",
    FACE_UP: "up",
    FACE_DOWN: "down"
};
mxShapeMockupRuler.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxShapeMockupRuler.prototype.background = function(c, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupRuler.prototype.foreground = function(c, w, h) {
    var facing = mxUtils.getValue(this.style, mxShapeMockupRuler.prototype.cst.ORIENTATION, mxShapeMockupRuler.prototype.cst.FACE_DOWN);
    var unitSize = mxUtils.getValue(this.style, mxShapeMockupRuler.prototype.cst.UNIT_SIZE, "10");
    unitSize = Math.max(unitSize, 1);
    var currX = unitSize;
    var i = 1;
    if (facing === mxShapeMockupRuler.prototype.cst.FACE_DOWN) {
        c.begin();
        while (currX < w) {
            var remainder = i % 10;
            if (remainder === 0) {
                c.moveTo(currX, h * .5);
                c.lineTo(currX, h)
            } else if (remainder === 5) {
                c.moveTo(currX, h * .7);
                c.lineTo(currX, h)
            } else {
                c.moveTo(currX, h * .8);
                c.lineTo(currX, h)
            }
            currX = currX + unitSize;
            i = i + 1
        }
        c.stroke()
    } else if (facing === mxShapeMockupRuler.prototype.cst.FACE_UP) {
        c.begin();
        while (currX < w) {
            var remainder = i % 10;
            if (remainder === 0) {
                c.moveTo(currX, h * .5);
                c.lineTo(currX, 0)
            } else if (remainder === 5) {
                c.moveTo(currX, h * .3);
                c.lineTo(currX, 0)
            } else {
                c.moveTo(currX, h * .2);
                c.lineTo(currX, 0)
            }
            currX = currX + unitSize;
            i = i + 1
        }
        c.stroke()
    }
}
;
mxCellRenderer.registerShape(mxShapeMockupRuler.prototype.cst.SHAPE_RULER, mxShapeMockupRuler);
function mxShapeMockupRuler2(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupRuler2, mxShape);
mxShapeMockupRuler2.prototype.cst = {
    SHAPE_RULER: "mxgraph.mockup.misc.ruler2",
    ORIENTATION: "rulerOrient",
    UNIT_SIZE: "unitSize",
    FACE_UP: "up",
    FACE_DOWN: "down"
};
mxShapeMockupRuler2.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxShapeMockupRuler2.prototype.background = function(c, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupRuler2.prototype.foreground = function(c, w, h) {
    var facing = mxUtils.getValue(this.style, mxShapeMockupRuler2.prototype.cst.ORIENTATION, mxShapeMockupRuler2.prototype.cst.FACE_DOWN);
    var fontColor = mxUtils.getValue(this.style, mxConstants.STYLE_FONTCOLOR, "#000000");
    var dx = mxUtils.getValue(this.style, "dx", "100");
    var unitSize = dx / 10;
    unitSize = Math.max(unitSize, 1);
    c.setFontColor(fontColor);
    var currX = unitSize;
    var i = 1;
    if (facing === mxShapeMockupRuler2.prototype.cst.FACE_DOWN) {
        c.begin();
        while (currX < w) {
            var remainder = i % 10;
            if (remainder === 0) {
                c.moveTo(currX, h - 10);
                c.lineTo(currX, h);
                var unit = this.state.view.graph.getLabel(this.state.cell);
                if (!isNaN(unit)) {
                    c.stroke();
                    var num = i * Math.round(100 * unit) / 1E3;
                    if (i != 10 && num != 0)
                        c.text(currX, (h - 10) * .5, 0, 0, num.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
                    c.begin()
                }
            } else if (remainder === 5) {
                c.moveTo(currX, h - 6);
                c.lineTo(currX, h)
            } else {
                c.moveTo(currX, h - 4);
                c.lineTo(currX, h)
            }
            currX = currX + unitSize;
            i = i + 1
        }
        c.stroke()
    } else if (facing === mxShapeMockupRuler2.prototype.cst.FACE_UP) {
        c.begin();
        while (currX < w) {
            var remainder = i % 10;
            if (remainder === 0) {
                c.moveTo(currX, 10);
                c.lineTo(currX, 0);
                var unit = this.state.view.graph.getLabel(this.state.cell);
                if (!isNaN(unit)) {
                    c.stroke();
                    var num = i * Math.round(100 * unit) / 1E3;
                    if (i != 10 && num != 0)
                        c.text(currX, (h + 10) * .5, 0, 0, num.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
                    c.begin()
                }
            } else if (remainder === 5) {
                c.moveTo(currX, 6);
                c.lineTo(currX, 0)
            } else {
                c.moveTo(currX, 4);
                c.lineTo(currX, 0)
            }
            currX = currX + unitSize;
            i = i + 1
        }
        c.stroke()
    }
}
;
mxCellRenderer.registerShape(mxShapeMockupRuler2.prototype.cst.SHAPE_RULER, mxShapeMockupRuler2);
Graph.handleFactory[mxShapeMockupRuler2.prototype.cst.SHAPE_RULER] = function(state) {
    var handles = [Graph.createHandle(state, ["dx", "spacingLeft", "align", "varticalAlign", "spacingBottom", "spacingTop", "spacingRight", "spacing"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        return new mxPoint(bounds.x + dx,bounds.y + bounds.height - 10)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(1E3 * Math.max(0, Math.min(bounds.width, pt.x - bounds.x))) / 1E3;
        this.state.style["spacingLeft"] = Math.round(1E3 * Math.max(0, Math.min(bounds.width, pt.x - bounds.x))) / 1E3 - 4;
        this.state.style["align"] = "left";
        this.state.style["verticalAlign"] = "middle";
        var facing = mxUtils.getValue(this.state.style, "rulerOrient", "1");
        if (facing == "down") {
            this.state.style["spacingBottom"] = 10;
            this.state.style["spacingTop"] = 0;
            console.log("down")
        } else {
            this.state.style["spacingBottom"] = 0;
            this.state.style["spacingTop"] = 10;
            console.log("up")
        }
        this.state.style["spacingRight"] = 0;
        this.state.style["spacing"] = 0
    })];
    return handles
}
;
function mxShapeMockupRevisionTable(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupRevisionTable, mxShape);
mxShapeMockupRevisionTable.prototype.cst = {
    SHAPE_REVISION_TABLE: "mxgraph.mockup.misc.revisionTable",
    MAIN_TEXT: "mainText",
    TEXT_COLOR: "textColor",
    TEXT_SIZE: "textSize"
};
mxShapeMockupRevisionTable.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxShapeMockupRevisionTable.prototype.background = function(c, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupRevisionTable.prototype.foreground = function(c, w, h) {
    var mainText = mxUtils.getValue(this.style, mxShapeMockupRevisionTable.prototype.cst.MAIN_TEXT, "").toString().split(",");
    var textColor = mxUtils.getValue(this.style, mxShapeMockupRevisionTable.prototype.cst.TEXT_COLOR, "#999999");
    var textSize = mxUtils.getValue(this.style, mxShapeMockupRevisionTable.prototype.cst.TEXT_SIZE, "17");
    c.begin();
    c.moveTo(0, h * .33);
    c.lineTo(w, h * .33);
    c.moveTo(0, h * .67);
    c.lineTo(w, h * .67);
    c.moveTo(w * .125, h * .33);
    c.lineTo(w * .125, h);
    c.moveTo(w * .5, h * .33);
    c.lineTo(w * .5, h);
    c.stroke();
    c.setFontSize(textSize);
    c.setFontColor(textColor);
    c.text(w * .5, h * .165, 0, 0, mainText[0], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .0625, h * .5, 0, 0, mainText[1], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .3125, h * .5, 0, 0, mainText[2], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .75, h * .5, 0, 0, mainText[3], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .0625, h * .835, 0, 0, mainText[4], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .3125, h * .835, 0, 0, mainText[5], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .75, h * .835, 0, 0, mainText[6], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxShapeMockupRevisionTable.prototype.cst.SHAPE_REVISION_TABLE, mxShapeMockupRevisionTable);
function mxShapeMockupStatusBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupStatusBar, mxShape);
mxShapeMockupStatusBar.prototype.cst = {
    SHAPE_STATUS_BAR: "mxgraph.mockup.misc.statusBar",
    MAIN_TEXT: "mainText",
    FILL_COLOR2: "fillColor2",
    STROKE_COLOR2: "strokeColor2",
    TEXT_COLOR: "textColor",
    TEXT_SIZE: "textSize"
};
mxShapeMockupStatusBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    w = Math.max(w, 105);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxShapeMockupStatusBar.prototype.background = function(c, w, h) {
    c.rect(0, h * .5 - 15, w, 30);
    c.fillAndStroke()
}
;
mxShapeMockupStatusBar.prototype.foreground = function(c, w, h) {
    var fillColor2 = mxUtils.getValue(this.style, mxShapeMockupStatusBar.prototype.cst.FILL_COLOR2, "#ddeeff");
    var strokeColor2 = mxUtils.getValue(this.style, mxShapeMockupStatusBar.prototype.cst.STROKE_COLOR2, "#008cff");
    var mainText = mxUtils.getValue(this.style, mxShapeMockupStatusBar.prototype.cst.MAIN_TEXT, "").toString().split(",");
    var textColor = mxUtils.getValue(this.style, mxShapeMockupStatusBar.prototype.cst.TEXT_COLOR, "#999999");
    var textSize = mxUtils.getValue(this.style, mxShapeMockupStatusBar.prototype.cst.TEXT_SIZE, "17");
    c.setFillColor(fillColor2);
    c.roundrect(5, h * .5 - 10, (w - 75) * .46, 20, 5, 5);
    c.fill();
    c.roundrect(10 + (w - 75) * .46, h * .5 - 10, (w - 75) * .23, 20, 5, 5);
    c.fill();
    c.roundrect(15 + (w - 75) * .69, h * .5 - 10, (w - 75) * .276, 20, 5, 5);
    c.fill();
    c.setFontSize(textSize);
    c.setFontColor(textColor);
    c.text(10, h * .5, 0, 0, mainText[0], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(10 + (w - 75) * .575, h * .5, 0, 0, mainText[1], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(15 + (w - 75) * .828, h * .5, 0, 0, mainText[2], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setStrokeColor(strokeColor2);
    c.ellipse(w - 25, h * .5 - 10, 20, 20);
    c.stroke();
    c.begin();
    c.moveTo(w - 55, h * .5 + 10);
    c.lineTo(w - 35, h * .5 + 10);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupStatusBar.prototype.cst.SHAPE_STATUS_BAR, mxShapeMockupStatusBar);
function mxShapeMockupPin(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupPin, mxShape);
mxShapeMockupPin.prototype.cst = {
    SHAPE_PIN: "mxgraph.mockup.misc.pin",
    FILL_COLOR2: "fillColor2",
    FILL_COLOR3: "fillColor3"
};
mxShapeMockupPin.prototype.paintVertexShape = function(c, x, y, w, h) {
    var fillColor2 = mxUtils.getValue(this.style, mxShapeMockupPin.prototype.cst.FILL_COLOR2, "#000000");
    var fillColor3 = mxUtils.getValue(this.style, mxShapeMockupPin.prototype.cst.FILL_COLOR3, "#000000");
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    c.setShadow(false);
    c.translate(x, y);
    c.setStrokeWidth(3);
    c.setStrokeColor("#666666");
    c.begin();
    c.moveTo(w * .5, h * .4);
    c.lineTo(w * .5, h);
    c.stroke();
    c.setStrokeWidth(2);
    c.setStrokeColor(strokeColor);
    c.setGradient(fillColor2, fillColor3, 0, 0, w, h * .4, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.setAlpha(.9);
    c.ellipse(0, 0, w, h * .4);
    c.fillAndStroke();
    c.setFillColor("#ffffff");
    c.setAlpha(.5);
    c.ellipse(w * .2, h * .08, w * .3, h * .12);
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeMockupPin.prototype.cst.SHAPE_PIN, mxShapeMockupPin);
function mxShapeMockupMiscRRect(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupMiscRRect, mxShape);
mxShapeMockupMiscRRect.prototype.cst = {
    RRECT: "mxgraph.mockup.misc.rrect",
    R_SIZE: "rSize"
};
mxShapeMockupMiscRRect.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupMiscRRect.prototype.cst.R_SIZE, "10"));
    c.roundrect(0, 0, w, h, rSize);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupMiscRRect.prototype.cst.RRECT, mxShapeMockupMiscRRect);
function mxShapeMockupMiscAnchor(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds
}
mxUtils.extend(mxShapeMockupMiscAnchor, mxShape);
mxShapeMockupMiscAnchor.prototype.cst = {
    ANCHOR: "mxgraph.mockup.misc.anchor"
};
mxShapeMockupMiscAnchor.prototype.paintVertexShape = function(c, x, y, w, h) {}
;
mxCellRenderer.registerShape(mxShapeMockupMiscAnchor.prototype.cst.ANCHOR, mxShapeMockupMiscAnchor);
function mxShapeMockupBreadcrumb(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupBreadcrumb, mxShape);
mxShapeMockupBreadcrumb.prototype.cst = {
    SHAPE_BREADCRUMB: "mxgraph.mockup.navigation.breadcrumb",
    MAIN_TEXT: "mainText",
    TEXT_SIZE: "textSize",
    TEXT_COLOR: "textColor",
    TEXT_COLOR2: "textColor2"
};
mxShapeMockupBreadcrumb.prototype.paintVertexShape = function(c, x, y, w, h) {
    var textStrings = mxUtils.getValue(this.style, mxShapeMockupBreadcrumb.prototype.cst.MAIN_TEXT, "Layer 1, Layer 2, Layer 3").toString().split(",");
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupBreadcrumb.prototype.cst.TEXT_COLOR, "#666666");
    var selectedFontColor = mxUtils.getValue(this.style, mxShapeMockupBreadcrumb.prototype.cst.TEXT_COLOR2, "#008cff");
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupBreadcrumb.prototype.cst.TEXT_SIZE, "17").toString();
    var separatorColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#c4c4c4");
    var buttonNum = textStrings.length;
    var buttonWidths = new Array(buttonNum);
    var buttonTotalWidth = 0;
    var labelOffset = 10;
    for (var i = 0; i < buttonNum; i++) {
        buttonWidths[i] = mxUtils.getSizeForString(textStrings[i], fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
        buttonTotalWidth += buttonWidths[i]
    }
    var trueH = Math.max(h, fontSize * 1.5, 20);
    var minW = 2 * labelOffset * buttonNum + buttonTotalWidth;
    var trueW = Math.max(w, minW);
    c.translate(x, y);
    c.setShadow(false);
    this.separators(c, trueW, trueH, buttonNum, buttonWidths, labelOffset, minW, separatorColor);
    var currWidth = 0;
    for (var i = 0; i < buttonNum; i++) {
        if (i + 1 === buttonNum)
            c.setFontColor(selectedFontColor);
        else
            c.setFontColor(fontColor);
        currWidth = currWidth + labelOffset;
        this.buttonText(c, currWidth, trueH, textStrings[i], buttonWidths[i], fontSize, minW, trueW);
        currWidth = currWidth + buttonWidths[i] + labelOffset
    }
}
;
mxShapeMockupBreadcrumb.prototype.separators = function(c, w, h, buttonNum, buttonWidths, labelOffset, minW, separatorColor) {
    c.setStrokeColor(separatorColor);
    var midY = h * .5;
    var size = 5;
    c.begin();
    for (var i = 1; i < buttonNum; i++) {
        var currWidth = 0;
        for (var j = 0; j < i; j++)
            currWidth += buttonWidths[j] + 2 * labelOffset;
        currWidth = currWidth * w / minW;
        c.moveTo(currWidth - size * .5, midY - size);
        c.lineTo(currWidth + size * .5, midY);
        c.lineTo(currWidth - size * .5, midY + size)
    }
    c.stroke()
}
;
mxShapeMockupBreadcrumb.prototype.buttonText = function(c, w, h, textString, buttonWidth, fontSize, minW, trueW) {
    c.begin();
    c.setFontSize(fontSize);
    c.text((w + buttonWidth * .5) * trueW / minW, h * .5, 0, 0, textString, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxShapeMockupBreadcrumb.prototype.cst.SHAPE_BREADCRUMB, mxShapeMockupBreadcrumb);
function mxShapeMockupStepBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupStepBar, mxShape);
mxShapeMockupStepBar.prototype.cst = {
    SHAPE_STEP_BAR: "mxgraph.mockup.navigation.stepBar",
    SELECTED: "+",
    MAIN_TEXT: "mainText",
    TEXT_SIZE: "textSize",
    TEXT_COLOR: "textColor",
    TEXT_COLOR2: "textColor2"
};
mxShapeMockupStepBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    var textStrings = mxUtils.getValue(this.style, mxShapeMockupStepBar.prototype.cst.MAIN_TEXT, "Step 1, Step 2, Step 3").toString().split(",");
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupStepBar.prototype.cst.TEXT_COLOR, "#666666");
    var currColor = mxUtils.getValue(this.style, mxShapeMockupStepBar.prototype.cst.TEXT_COLOR2, "#008cff");
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupStepBar.prototype.cst.TEXT_SIZE, "17").toString();
    var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#c4c4c4");
    var doneColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#666666");
    var buttonNum = textStrings.length;
    var buttonWidths = new Array(buttonNum);
    var buttonTotalWidth = 0;
    var labelOffset = 10;
    var selectedButton = -1;
    for (var i = 0; i < buttonNum; i++) {
        var buttonText = textStrings[i];
        if (buttonText.charAt(0) === mxShapeMockupStepBar.prototype.cst.SELECTED) {
            buttonText = textStrings[i].substring(1);
            selectedButton = i
        }
        buttonWidths[i] = mxUtils.getSizeForString(buttonText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
        buttonTotalWidth += buttonWidths[i]
    }
    var trueH = Math.max(h, fontSize * 1.5, 20);
    var minW = 2 * labelOffset * buttonNum + buttonTotalWidth;
    var trueW = Math.max(w, minW);
    c.translate(x, y);
    this.stepLineBg(c, trueW, trueH, buttonNum, buttonWidths, labelOffset, minW, bgColor, fontSize, trueW);
    c.setShadow(false);
    this.stepLineFg(c, trueW, trueH, buttonNum, buttonWidths, labelOffset, minW, bgColor, doneColor, currColor, fontSize, trueW, selectedButton);
    var currWidth = 0;
    for (var i = 0; i < buttonNum; i++) {
        if (i >= selectedButton)
            c.setFontColor(fontColor);
        else
            c.setFontColor(bgColor);
        currWidth = currWidth + labelOffset;
        this.buttonText(c, currWidth, trueH, textStrings[i], buttonWidths[i], fontSize, minW, trueW);
        currWidth = currWidth + buttonWidths[i] + labelOffset
    }
}
;
mxShapeMockupStepBar.prototype.stepLineBg = function(c, w, h, buttonNum, buttonWidths, labelOffset, minW, bgColor, fontSize, trueW) {
    c.setStrokeColor(bgColor);
    c.setFillColor(bgColor);
    var midY = fontSize * 2;
    var size = 10;
    var startX = 0;
    var endX = 0;
    for (var i = 0; i < buttonNum; i++) {
        var currWidth = 0;
        for (var j = 0; j < i; j++)
            currWidth += buttonWidths[j] + 2 * labelOffset;
        currWidth += buttonWidths[i] * .5 + labelOffset;
        currWidth = currWidth * w / minW;
        if (i === 0)
            startX = currWidth;
        else if (i + 1 === buttonNum)
            endX = currWidth;
        c.begin();
        c.ellipse(currWidth - size, midY - size, 2 * size, 2 * size);
        c.fillAndStroke()
    }
    c.begin();
    c.rect(startX, midY - size * .2, endX - startX, size * .4);
    c.fillAndStroke()
}
;
mxShapeMockupStepBar.prototype.stepLineFg = function(c, w, h, buttonNum, buttonWidths, labelOffset, minW, bgColor, doneColor, currColor, fontSize, trueW, selectedButton) {
    c.setStrokeColor(doneColor);
    var midY = fontSize * 2;
    var size = 10 * .75;
    var startX = 0;
    var endX = 0;
    var strokeWidth = mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, "1");
    for (var i = 0; i <= selectedButton; i++) {
        var currWidth = 0;
        for (var j = 0; j < i; j++)
            currWidth += buttonWidths[j] + 2 * labelOffset;
        currWidth += buttonWidths[i] * .5 + labelOffset;
        currWidth = currWidth * w / minW;
        if (i === 0)
            startX = currWidth;
        else if (i === selectedButton)
            endX = currWidth
    }
    c.setFillColor(doneColor);
    c.begin();
    c.rect(startX, midY - size * .15, endX - startX, size * .3);
    c.fill();
    c.setFillColor(bgColor);
    for (var i = 0; i <= selectedButton; i++) {
        var currWidth = 0;
        for (var j = 0; j < i; j++)
            currWidth += buttonWidths[j] + 2 * labelOffset;
        currWidth += buttonWidths[i] * .5 + labelOffset;
        currWidth = currWidth * w / minW;
        if (i === 0)
            startX = currWidth;
        else if (i + 1 === selectedButton)
            endX = currWidth;
        if (i < selectedButton) {
            c.setStrokeWidth(strokeWidth);
            c.begin();
            c.ellipse(currWidth - size, midY - size, 2 * size, 2 * size);
            c.fillAndStroke();
            c.setStrokeWidth(strokeWidth * .5);
            c.begin();
            c.ellipse(currWidth - size * .6, midY - size * .6, 2 * size * .6, 2 * size * .6);
            c.fillAndStroke()
        } else {
            c.setStrokeWidth(strokeWidth);
            c.setFillColor(bgColor);
            c.setStrokeColor(bgColor);
            c.begin();
            c.ellipse(currWidth - size / .75, midY - size / .75, 2 * size / .75, 2 * size / .75);
            c.fillAndStroke();
            c.setStrokeWidth(strokeWidth);
            c.setFillColor("#ffffff");
            c.setStrokeColor("#ffffff");
            c.begin();
            c.ellipse(currWidth - size, midY - size, 2 * size, 2 * size);
            c.fillAndStroke();
            c.setFillColor(currColor);
            c.setStrokeColor(currColor);
            c.setStrokeWidth(strokeWidth * .5);
            c.begin();
            c.ellipse(currWidth - size * .7, midY - size * .7, 2 * size * .7, 2 * size * .7);
            c.fillAndStroke()
        }
    }
}
;
mxShapeMockupStepBar.prototype.buttonText = function(c, w, h, textString, buttonWidth, fontSize, minW, trueW) {
    if (textString.charAt(0) === mxShapeMockupStepBar.prototype.cst.SELECTED)
        textString = textString.substring(1);
    c.begin();
    c.setFontSize(fontSize);
    c.text((w + buttonWidth * .5) * trueW / minW, fontSize * .5, 0, 0, textString, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxShapeMockupStepBar.prototype.cst.SHAPE_STEP_BAR, mxShapeMockupStepBar);
function mxShapeMockupCoverFlow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupCoverFlow, mxShape);
mxShapeMockupCoverFlow.prototype.cst = {
    SHAPE_COVER_FLOW: "mxgraph.mockup.navigation.coverFlow"
};
mxShapeMockupCoverFlow.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.moveTo(w * .0924, h * .07);
    c.lineTo(w * .005, h * .01);
    c.lineTo(w * .005, h * .99);
    c.lineTo(w * .0924, h * .93);
    c.moveTo(w * .1774, h * .09);
    c.lineTo(w * .0924, h * .01);
    c.lineTo(w * .0924, h * .99);
    c.lineTo(w * .1774, h * .91);
    c.moveTo(w * .3373, h * .22);
    c.lineTo(w * .1774, h * .01);
    c.lineTo(w * .1774, h * .99);
    c.lineTo(w * .3373, h * .78);
    c.moveTo(w * .912, h * .07);
    c.lineTo(w * .998, h * .01);
    c.lineTo(w * .998, h * .99);
    c.lineTo(w * .912, h * .93);
    c.moveTo(w * .8271, h * .09);
    c.lineTo(w * .912, h * .01);
    c.lineTo(w * .912, h * .99);
    c.lineTo(w * .8271, h * .91);
    c.moveTo(w * .6672, h * .22);
    c.lineTo(w * .8271, h * .01);
    c.lineTo(w * .8271, h * .99);
    c.lineTo(w * .6672, h * .78);
    c.moveTo(w * .3373, h * .005);
    c.lineTo(w * .3373, h * .995);
    c.lineTo(w * .6672, h * .995);
    c.lineTo(w * .6672, h * .005);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupCoverFlow.prototype.cst.SHAPE_COVER_FLOW, mxShapeMockupCoverFlow);
function mxShapeMockupScrollBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupScrollBar, mxShape);
mxShapeMockupScrollBar.prototype.cst = {
    SHAPE_SCROLL_BAR: "mxgraph.mockup.navigation.scrollBar",
    FILL_COLOR2: "fillColor2",
    STROKE_COLOR2: "strokeColor2",
    BAR_POS: "barPos"
};
mxShapeMockupScrollBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    h = 20;
    var buttonX = 20;
    w = Math.max(w, 2 * buttonX);
    c.translate(x, y);
    this.background(c, w, h, buttonX);
    c.setShadow(false);
    this.foreground(c, w, h, buttonX);
    this.barPos = 20
}
;
mxShapeMockupScrollBar.prototype.background = function(c, w, h, buttonX) {
    c.rect(0, 0, w, h);
    c.fillAndStroke();
    c.begin();
    c.moveTo(buttonX, 0);
    c.lineTo(buttonX, h);
    c.moveTo(w - buttonX, 0);
    c.lineTo(w - buttonX, h);
    c.stroke()
}
;
mxShapeMockupScrollBar.prototype.foreground = function(c, w, h, buttonX) {
    var barPos = mxUtils.getValue(this.style, mxShapeMockupScrollBar.prototype.cst.BAR_POS, "20");
    var fillColor2 = mxUtils.getValue(this.style, mxShapeMockupScrollBar.prototype.cst.FILL_COLOR2, "#99ddff");
    var strokeColor2 = mxUtils.getValue(this.style, mxShapeMockupScrollBar.prototype.cst.STROKE_COLOR2, "none");
    barPos = Math.max(0, barPos);
    barPos = Math.min(100, barPos);
    c.setStrokeColor(strokeColor2);
    c.setFillColor(fillColor2);
    c.begin();
    c.moveTo(buttonX * .2, h * .5);
    c.lineTo(buttonX * .8, h * .2);
    c.lineTo(buttonX * .8, h * .8);
    c.close();
    c.moveTo(w - buttonX * .2, h * .5);
    c.lineTo(w - buttonX * .8, h * .2);
    c.lineTo(w - buttonX * .8, h * .8);
    c.close();
    c.fillAndStroke();
    var barWidth = 60;
    var barMin = buttonX;
    var barMax = w - buttonX;
    barWidth = Math.min(barWidth, barMax - barMin);
    var barCenterMin = barMin + barWidth / 2;
    var barCenterMax = barMax - barWidth / 2;
    var barCenterRange = barCenterMax - barCenterMin;
    var barCenterPos = barCenterRange * barPos / 100;
    var barStart = barMin + barCenterPos;
    c.roundrect(barStart, h * .15, barWidth, h * .7, 5, 5);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupScrollBar.prototype.cst.SHAPE_SCROLL_BAR, mxShapeMockupScrollBar);
Graph.handleFactory[mxShapeMockupScrollBar.prototype.cst.SHAPE_SCROLL_BAR] = function(state) {
    var handles = [Graph.createHandle(state, ["barPos"], function(bounds) {
        var barPos = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, "barPos", this.barPos))));
        return new mxPoint(bounds.x + (bounds.width - 100) * barPos / bounds.width / 100 * bounds.width + 50,bounds.y + 10)
    }, function(bounds, pt) {
        this.state.style["barPos"] = Math.round(1E3 * Math.max(0, Math.min(100, (pt.x - bounds.x - 50) * 100 / (bounds.width - 100)))) / 1E3
    })];
    return handles
}
;
function mxShapeMockupPagination(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupPagination, mxShape);
mxShapeMockupPagination.prototype.cst = {
    MAIN_TEXT: "linkText",
    TEXT_SIZE: "textSize",
    TEXT_COLOR: "textColor",
    SHAPE_PAGINATION: "mxgraph.mockup.navigation.pagination"
};
mxShapeMockupPagination.prototype.paintVertexShape = function(c, x, y, w, h) {
    var mainText = mxUtils.getValue(this.style, mxShapeMockupPagination.prototype.cst.MAIN_TEXT, "0-9 A B C D E F G H I J K L M N O P Q R S T U V X Y Z");
    var textSize = mxUtils.getValue(this.style, mxShapeMockupPagination.prototype.cst.TEXT_SIZE, "17");
    var textColor = mxUtils.getValue(this.style, mxShapeMockupPagination.prototype.cst.TEXT_COLOR, "#0000ff");
    c.translate(x, y);
    var width = mxUtils.getSizeForString(mainText, textSize, mxConstants.DEFAULT_FONTFAMILY).width;
    c.setStrokeColor(textColor);
    c.setFontSize(textSize);
    c.setFontColor(textColor);
    c.text(w * .5, h * .5, 0, 0, mainText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.begin();
    c.moveTo(w * .5 - width * .5, (h + parseInt(textSize, 10)) * .5);
    c.lineTo(w * .5 + width * .5, (h + parseInt(textSize, 10)) * .5);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupPagination.prototype.cst.SHAPE_PAGINATION, mxShapeMockupPagination);
function mxShapeMockupPageControl(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupPageControl, mxShape);
mxShapeMockupPageControl.prototype.cst = {
    SHAPE_PAGE_CONTROL: "mxgraph.mockup.navigation.pageControl"
};
mxShapeMockupPageControl.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#000000");
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    var rSize = Math.min(h * .5, w * .05);
    c.setFillColor(strokeColor);
    c.ellipse(0, h * .5 - rSize, 2 * rSize, 2 * rSize);
    c.fill();
    c.setFillColor(fillColor);
    c.ellipse(w * .35 - rSize, h * .5 - rSize, 2 * rSize, 2 * rSize);
    c.fill();
    c.ellipse(w * .65 - rSize, h * .5 - rSize, 2 * rSize, 2 * rSize);
    c.fill();
    c.ellipse(w - 2 * rSize, h * .5 - rSize, 2 * rSize, 2 * rSize);
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeMockupPageControl.prototype.cst.SHAPE_PAGE_CONTROL, mxShapeMockupPageControl);
function mxShapeMockupMapNavigator(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupMapNavigator, mxShape);
mxShapeMockupMapNavigator.prototype.cst = {
    SHAPE_MAP_NAVIGATOR: "mxgraph.mockup.navigation.mapNavigator",
    FILL_COLOR2: "fillColor2",
    STROKE_COLOR2: "strokeColor2",
    STROKE_COLOR3: "strokeColor3"
};
mxShapeMockupMapNavigator.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxShapeMockupMapNavigator.prototype.background = function(c, w, h) {
    c.ellipse(0, 0, w, h * .6);
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .35, h * .584);
    c.lineTo(w * .35, h * .95);
    c.arcTo(w * .083, h * .05, 0, 0, 0, w * .43, h);
    c.lineTo(w * .56, h);
    c.arcTo(w * .083, h * .05, 0, 0, 0, w * .65, h * .95);
    c.lineTo(w * .65, h * .584);
    c.fillAndStroke()
}
;
mxShapeMockupMapNavigator.prototype.foreground = function(c, w, h) {
    var fillColor2 = mxUtils.getValue(this.style, mxShapeMockupMapNavigator.prototype.cst.FILL_COLOR2, "#99ddff");
    var strokeColor2 = mxUtils.getValue(this.style, mxShapeMockupMapNavigator.prototype.cst.STROKE_COLOR2, "none");
    var strokeColor3 = mxUtils.getValue(this.style, mxShapeMockupMapNavigator.prototype.cst.STROKE_COLOR3, "#ffffff");
    c.setFillColor(fillColor2);
    c.setStrokeColor(strokeColor2);
    c.ellipse(w * .4, h * .65, w * .2, h * .12);
    c.fillAndStroke();
    c.ellipse(w * .4, h * .85, w * .2, h * .12);
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .1806, h * .34);
    c.lineTo(w * .1357, h * .366);
    c.lineTo(w * .0228, h * .3);
    c.lineTo(w * .1357, h * .234);
    c.lineTo(w * .1806, h * .26);
    c.lineTo(w * .1142, h * .3);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .433, h * .108);
    c.lineTo(w * .3881, h * .08);
    c.lineTo(w * .4994, h * .012);
    c.lineTo(w * .6123, h * .08);
    c.lineTo(w * .5658, h * .108);
    c.lineTo(w * .4994, h * .068);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .8198, h * .262);
    c.lineTo(w * .868, h * .233);
    c.lineTo(w * .9776, h * .3);
    c.lineTo(w * .868, h * .367);
    c.lineTo(w * .8198, h * .341);
    c.lineTo(w * .8863, h * .3);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .5641, h * .493);
    c.lineTo(w * .6123, h * .522);
    c.lineTo(w * .4994, h * .588);
    c.lineTo(w * .3881, h * .521);
    c.lineTo(w * .4363, h * .493);
    c.lineTo(w * .4994, h * .533);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .3333, h * .32);
    c.lineTo(w * .3333, h * .28);
    c.lineTo(w * .4163, h * .3);
    c.close();
    c.moveTo(w * .4662, h * .2);
    c.lineTo(w * .5326, h * .2);
    c.lineTo(w * .4994, h * .25);
    c.close();
    c.moveTo(w * .6654, h * .28);
    c.lineTo(w * .6654, h * .32);
    c.lineTo(w * .5824, h * .3);
    c.close();
    c.moveTo(w * .5326, h * .4);
    c.lineTo(w * .4662, h * .4);
    c.lineTo(w * .4994, h * .35);
    c.close();
    c.fillAndStroke();
    c.setStrokeWidth(2);
    c.setStrokeColor(strokeColor3);
    c.begin();
    c.moveTo(w * .5, h * .67);
    c.lineTo(w * .5, h * .75);
    c.moveTo(w * .43, h * .71);
    c.lineTo(w * .57, h * .71);
    c.moveTo(w * .43, h * .91);
    c.lineTo(w * .57, h * .91);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupMapNavigator.prototype.cst.SHAPE_MAP_NAVIGATOR, mxShapeMockupMapNavigator);
function mxShapeMockupNavigationAnchor(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds
}
mxUtils.extend(mxShapeMockupNavigationAnchor, mxShape);
mxShapeMockupNavigationAnchor.prototype.cst = {
    ANCHOR: "mxgraph.mockup.navigation.anchor"
};
mxShapeMockupNavigationAnchor.prototype.paintVertexShape = function(c, x, y, w, h) {}
;
mxCellRenderer.registerShape(mxShapeMockupNavigationAnchor.prototype.cst.ANCHOR, mxShapeMockupNavigationAnchor);
function mxShapeMockupLink(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupLink, mxShape);
mxShapeMockupLink.prototype.cst = {
    LINK_TEXT: "linkText",
    TEXT_SIZE: "textSize",
    TEXT_COLOR: "textColor",
    SHAPE_LINK: "mxgraph.mockup.text.link"
};
mxShapeMockupLink.prototype.paintVertexShape = function(c, x, y, w, h) {
    var linkText = mxUtils.getValue(this.style, mxShapeMockupLink.prototype.cst.LINK_TEXT, "Link");
    var textSize = mxUtils.getValue(this.style, mxShapeMockupLink.prototype.cst.TEXT_SIZE, "17");
    var textColor = mxUtils.getValue(this.style, mxShapeMockupLink.prototype.cst.TEXT_COLOR, "#0000ff");
    c.translate(x, y);
    var width = mxUtils.getSizeForString(linkText, textSize, mxConstants.DEFAULT_FONTFAMILY).width;
    c.setStrokeColor(textColor);
    c.setFontSize(textSize);
    c.setFontColor(textColor);
    c.text(w * .5, h * .5, 0, 0, linkText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.begin();
    c.moveTo(w * .5 - width * .5, (h + parseInt(textSize, 10)) * .5);
    c.lineTo(w * .5 + width * .5, (h + parseInt(textSize, 10)) * .5);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupLink.prototype.cst.SHAPE_LINK, mxShapeMockupLink);
function mxShapeMockupLinkBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupLinkBar, mxShape);
mxShapeMockupLinkBar.prototype.cst = {
    MAIN_TEXT: "mainText",
    SHAPE_LINK_BAR: "mxgraph.mockup.text.linkBar",
    TEXT_COLOR: "textColor",
    TEXT_COLOR2: "textColor2",
    STROKE_COLOR2: "strokeColor2",
    FILL_COLOR2: "fillColor2",
    SELECTED: "+",
    TEXT_SIZE: "textSize"
};
mxShapeMockupLinkBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    var textStrings = mxUtils.getValue(this.style, mxShapeMockupLinkBar.prototype.cst.MAIN_TEXT, "+Button 1, Button 2, Button 3").toString().split(",");
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupLinkBar.prototype.cst.TEXT_COLOR, "#666666");
    var selectedFontColor = mxUtils.getValue(this.style, mxShapeMockupLinkBar.prototype.cst.TEXT_COLOR2, "#ffffff");
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupLinkBar.prototype.cst.TEXT_SIZE, "17").toString();
    var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#666666");
    var separatorColor = mxUtils.getValue(this.style, mxShapeMockupLinkBar.prototype.cst.STROKE_COLOR2, "#c4c4c4");
    var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var selectedFillColor = mxUtils.getValue(this.style, mxShapeMockupLinkBar.prototype.cst.FILL_COLOR2, "#008cff");
    var buttonNum = textStrings.length;
    var buttonWidths = new Array(buttonNum);
    var buttonTotalWidth = 0;
    var selectedButton = -1;
    var rSize = 10;
    var labelOffset = 5;
    for (var i = 0; i < buttonNum; i++) {
        var buttonText = textStrings[i];
        if (buttonText.charAt(0) === mxShapeMockupLinkBar.prototype.cst.SELECTED) {
            buttonText = textStrings[i].substring(1);
            selectedButton = i
        }
        var currW = mxUtils.getSizeForString(buttonText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
        if (currW === 0)
            buttonWidths[i] = 42;
        else
            buttonWidths[i] = currW;
        buttonTotalWidth += buttonWidths[i]
    }
    var trueH = Math.max(h, fontSize * 1.5, 20);
    var minW = 2 * labelOffset * buttonNum + buttonTotalWidth;
    var trueW = Math.max(w, minW);
    c.translate(x, y);
    this.background(c, trueW, trueH, rSize, buttonNum, buttonWidths, labelOffset, minW, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton);
    c.setShadow(false);
    var currWidth = 0;
    for (var i = 0; i < buttonNum; i++) {
        if (i === selectedButton) {
            c.setFontColor(selectedFontColor);
            c.setStrokeColor(selectedFontColor)
        } else {
            c.setFontColor(fontColor);
            c.setStrokeColor(fontColor)
        }
        currWidth = currWidth + labelOffset;
        this.buttonText(c, currWidth, trueH, textStrings[i], buttonWidths[i], fontSize, minW, trueW);
        currWidth = currWidth + buttonWidths[i] + labelOffset
    }
}
;
mxShapeMockupLinkBar.prototype.background = function(c, w, h, rSize, buttonNum, buttonWidths, labelOffset, minW, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton) {
    c.begin();
    c.setStrokeColor(frameColor);
    c.setFillColor(bgColor);
    c.rect(0, 0, w, h);
    c.fillAndStroke();
    c.setStrokeColor(separatorColor);
    c.begin();
    for (var i = 1; i < buttonNum; i++)
        if (i !== selectedButton && i !== selectedButton + 1) {
            var currWidth = 0;
            for (var j = 0; j < i; j++)
                currWidth += buttonWidths[j] + 2 * labelOffset;
            currWidth = currWidth * w / minW;
            c.moveTo(currWidth, 0);
            c.lineTo(currWidth, h)
        }
    c.stroke();
    var buttonLeft = 0;
    c.setFillColor(selectedFillColor);
    for (var i = 0; i < selectedButton; i++)
        buttonLeft += buttonWidths[i] + 2 * labelOffset;
    buttonLeft = buttonLeft * w / minW;
    var buttonRight = (buttonWidths[selectedButton] + 2 * labelOffset) * w / minW;
    buttonRight += buttonLeft;
    if (selectedButton === 0) {
        c.rect(0, 0, buttonRight, h);
        c.fill()
    } else if (selectedButton === buttonNum - 1) {
        c.rect(buttonLeft, 0, buttonRight - buttonLeft, h);
        c.fill()
    } else if (selectedButton !== -1) {
        c.rect(buttonLeft, 0, buttonRight - buttonLeft, h);
        c.fill()
    }
    c.setStrokeColor(frameColor);
    c.setFillColor(bgColor);
    c.rect(0, 0, w, h);
    c.stroke()
}
;
mxShapeMockupLinkBar.prototype.buttonText = function(c, w, h, textString, buttonWidth, fontSize, minW, trueW) {
    if (textString.charAt(0) === mxShapeMockupLinkBar.prototype.cst.SELECTED)
        textString = textString.substring(1);
    c.begin();
    c.setFontSize(fontSize);
    c.text((w + buttonWidth * .5) * trueW / minW, h * .5, 0, 0, textString, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    var textW = mxUtils.getSizeForString(textString, fontSize, mxConstants.DEFAULT_FONTFAMILY).width * .5;
    if (textString !== null && textString !== "") {
        c.begin();
        c.moveTo((w + buttonWidth * .5) * trueW / minW - textW, h * .5 + fontSize * .5);
        c.lineTo((w + buttonWidth * .5) * trueW / minW + textW, h * .5 + fontSize * .5);
        c.stroke()
    }
}
;
mxCellRenderer.registerShape(mxShapeMockupLinkBar.prototype.cst.SHAPE_LINK_BAR, mxShapeMockupLinkBar);
function mxShapeMockupCallout(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupCallout, mxShape);
mxShapeMockupCallout.prototype.cst = {
    CALLOUT_TEXT: "linkText",
    CALLOUT_DIR: "callDir",
    CALLOUT_STYLE: "callStyle",
    STYLE_LINE: "line",
    STYLE_RECT: "rect",
    STYLE_ROUNDRECT: "roundRect",
    DIR_NW: "NW",
    DIR_NE: "NE",
    DIR_SE: "SE",
    DIR_SW: "SW",
    TEXT_SIZE: "textSize",
    TEXT_COLOR: "textColor",
    SHAPE_CALLOUT: "mxgraph.mockup.text.callout"
};
mxShapeMockupCallout.prototype.paintVertexShape = function(c, x, y, w, h) {
    var calloutText = mxUtils.getValue(this.style, mxShapeMockupCallout.prototype.cst.CALLOUT_TEXT, "Callout");
    var textSize = mxUtils.getValue(this.style, mxShapeMockupCallout.prototype.cst.TEXT_SIZE, "17");
    var textColor = mxUtils.getValue(this.style, mxShapeMockupCallout.prototype.cst.TEXT_COLOR, "#666666");
    var callStyle = mxUtils.getValue(this.style, mxShapeMockupCallout.prototype.cst.CALLOUT_STYLE, mxShapeMockupCallout.prototype.cst.STYLE_LINE);
    var callDir = mxUtils.getValue(this.style, mxShapeMockupCallout.prototype.cst.CALLOUT_DIR, mxShapeMockupCallout.prototype.cst.DIR_NW);
    var textWidth = mxUtils.getSizeForString(calloutText, textSize, mxConstants.DEFAULT_FONTFAMILY).width;
    textWidth = textWidth * 1.2;
    if (textWidth == 0)
        textWidth = 70;
    c.translate(x, y);
    c.setFontSize(textSize);
    c.setFontColor(textColor);
    var callH = textSize * 1.5;
    if (callDir === mxShapeMockupCallout.prototype.cst.DIR_NW) {
        if (callStyle === mxShapeMockupCallout.prototype.cst.STYLE_LINE) {
            c.begin();
            c.moveTo(0, callH);
            c.lineTo(textWidth, callH);
            c.lineTo(w, h);
            c.stroke()
        } else if (callStyle === mxShapeMockupCallout.prototype.cst.STYLE_RECT) {
            c.rect(0, 0, textWidth, callH);
            c.fillAndStroke();
            c.begin();
            c.moveTo(textWidth * .5, callH);
            c.lineTo(w, h);
            c.stroke()
        } else if (callStyle === mxShapeMockupCallout.prototype.cst.STYLE_ROUNDRECT) {
            c.roundrect(0, 0, textWidth, callH, callH * .25, callH * .25);
            c.fillAndStroke();
            c.begin();
            c.moveTo(textWidth * .5, callH);
            c.lineTo(w, h);
            c.stroke()
        }
        c.text(textWidth * .5, callH * .5, 0, 0, calloutText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
    } else if (callDir === mxShapeMockupCallout.prototype.cst.DIR_NE) {
        if (callStyle === mxShapeMockupCallout.prototype.cst.STYLE_LINE) {
            c.begin();
            c.moveTo(w, callH);
            c.lineTo(w - textWidth, callH);
            c.lineTo(0, h);
            c.stroke()
        } else if (callStyle === mxShapeMockupCallout.prototype.cst.STYLE_RECT) {
            c.rect(w - textWidth, 0, textWidth, callH);
            c.fillAndStroke();
            c.begin();
            c.moveTo(w - textWidth * .5, callH);
            c.lineTo(0, h);
            c.stroke()
        } else if (callStyle === mxShapeMockupCallout.prototype.cst.STYLE_ROUNDRECT) {
            c.roundrect(w - textWidth, 0, textWidth, callH, callH * .25, callH * .25);
            c.fillAndStroke();
            c.begin();
            c.moveTo(w - textWidth * .5, callH);
            c.lineTo(0, h);
            c.stroke()
        }
        c.text(w - textWidth * .5, callH * .5, 0, 0, calloutText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
    } else if (callDir === mxShapeMockupCallout.prototype.cst.DIR_SE) {
        if (callStyle === mxShapeMockupCallout.prototype.cst.STYLE_LINE) {
            c.begin();
            c.moveTo(w, h);
            c.lineTo(w - textWidth, h);
            c.lineTo(0, 0);
            c.stroke()
        } else if (callStyle === mxShapeMockupCallout.prototype.cst.STYLE_RECT) {
            c.rect(w - textWidth, h - callH, textWidth, callH);
            c.fillAndStroke();
            c.begin();
            c.moveTo(w - textWidth * .5, h - callH);
            c.lineTo(0, 0);
            c.stroke()
        } else if (callStyle === mxShapeMockupCallout.prototype.cst.STYLE_ROUNDRECT) {
            c.roundrect(w - textWidth, h - callH, textWidth, callH, callH * .25, callH * .25);
            c.fillAndStroke();
            c.begin();
            c.moveTo(w - textWidth * .5, h - callH);
            c.lineTo(0, 0);
            c.stroke()
        }
        c.text(w - textWidth * .5, h - callH * .5, 0, 0, calloutText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
    } else if (callDir === mxShapeMockupCallout.prototype.cst.DIR_SW) {
        if (callStyle === mxShapeMockupCallout.prototype.cst.STYLE_LINE) {
            c.begin();
            c.moveTo(0, h);
            c.lineTo(textWidth, h);
            c.lineTo(w, 0);
            c.stroke()
        } else if (callStyle === mxShapeMockupCallout.prototype.cst.STYLE_RECT) {
            c.rect(0, h - callH, textWidth, callH);
            c.fillAndStroke();
            c.begin();
            c.moveTo(textWidth * .5, h - callH);
            c.lineTo(w, 0);
            c.stroke()
        } else if (callStyle === mxShapeMockupCallout.prototype.cst.STYLE_ROUNDRECT) {
            c.roundrect(0, h - callH, textWidth, callH, callH * .25, callH * .25);
            c.fillAndStroke();
            c.begin();
            c.moveTo(textWidth * .5, h - callH);
            c.lineTo(w, 0);
            c.stroke()
        }
        c.text(textWidth * .5, h - callH * .5, 0, 0, calloutText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
    }
}
;
mxCellRenderer.registerShape(mxShapeMockupCallout.prototype.cst.SHAPE_CALLOUT, mxShapeMockupCallout);
function mxShapeMockupStickyNote(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupStickyNote, mxShape);
mxShapeMockupStickyNote.prototype.cst = {
    MAIN_TEXT: "mainText",
    TEXT_COLOR: "textColor",
    TEXT_SIZE: "textSize",
    SHAPE_STICKY_NOTE: "mxgraph.mockup.text.stickyNote"
};
mxShapeMockupStickyNote.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxShapeMockupStickyNote.prototype.background = function(c, w, h) {
    c.setFillColor("#ffffcc");
    c.begin();
    c.moveTo(w * .03, h * .07);
    c.lineTo(w * .89, h * .06);
    c.arcTo(2.81 * w, 2.92 * h, 1, 0, 0, w * .99, h * .98);
    c.lineTo(w * .09, h * .99);
    c.arcTo(2.81 * w, 2.92 * h, 1, 0, 1, w * .03, h * .07);
    c.close();
    c.fill()
}
;
mxShapeMockupStickyNote.prototype.foreground = function(c, w, h) {
    var mainText = mxUtils.getValue(this.style, mxShapeMockupStickyNote.prototype.cst.MAIN_TEXT, "Note line 1,Note line 2,Note line 3").toString().split(",");
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupStickyNote.prototype.cst.TEXT_COLOR, "#666666").toString();
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupStickyNote.prototype.cst.TEXT_SIZE, "17").toString();
    c.setFillColor("#ff3300");
    c.begin();
    c.moveTo(w * .28, 0);
    c.lineTo(w * .59, 0);
    c.lineTo(w * .6, h * .12);
    c.lineTo(w * .28, h * .13);
    c.close();
    c.fill();
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    var lineNum = mainText.length;
    var textH = lineNum * fontSize * 1.5;
    for (var i = 0; i < mainText.length; i++)
        c.text(w / 2, (h - textH) / 2 + i * fontSize * 1.5 + fontSize * .75, 0, 0, mainText[i], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxShapeMockupStickyNote.prototype.cst.SHAPE_STICKY_NOTE, mxShapeMockupStickyNote);
function mxShapeMockupBulletedList(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupBulletedList, mxShape);
mxShapeMockupBulletedList.prototype.cst = {
    MAIN_TEXT: "mainText",
    TEXT_COLOR: "textColor",
    TEXT_SIZE: "textSize",
    BULLET_STYLE: "bulletStyle",
    STYLE_HYPHEN: "hyphen",
    STYLE_NUM: "number",
    STYLE_DOT: "dot",
    SHAPE_BULLETED_LIST: "mxgraph.mockup.text.bulletedList"
};
mxShapeMockupBulletedList.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxShapeMockupBulletedList.prototype.background = function(c, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupBulletedList.prototype.foreground = function(c, w, h) {
    var mainText = mxUtils.getValue(this.style, mxShapeMockupBulletedList.prototype.cst.MAIN_TEXT, "Note line 1,Note line 2,Note line 3").toString().split(",");
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupBulletedList.prototype.cst.TEXT_COLOR, "#666666");
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupBulletedList.prototype.cst.TEXT_SIZE, "17");
    var bulletStyle = mxUtils.getValue(this.style, mxShapeMockupBulletedList.prototype.cst.BULLET_STYLE, "none");
    c.setFontColor(fontColor);
    c.setFontSize(fontSize);
    var bullet = "";
    for (var i = 0; i < mainText.length; i++) {
        var currText = "";
        if (bulletStyle === mxShapeMockupBulletedList.prototype.cst.STYLE_NUM)
            currText = i + 1 + ") " + mainText[i];
        else if (bulletStyle === mxShapeMockupBulletedList.prototype.cst.STYLE_HYPHEN)
            currText = "- " + mainText[i];
        else if (bulletStyle === mxShapeMockupBulletedList.prototype.cst.STYLE_DOT)
            currText = String.fromCharCode(8226) + " " + mainText[i];
        else
            currText = "  " + mainText[i];
        c.text(10, i * fontSize * 1.5 + fontSize * .75, 0, 0, currText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
    }
}
;
mxCellRenderer.registerShape(mxShapeMockupBulletedList.prototype.cst.SHAPE_BULLETED_LIST, mxShapeMockupBulletedList);
function mxShapeMockupTextBox(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupTextBox, mxShape);
mxShapeMockupTextBox.prototype.cst = {
    MAIN_TEXT: "mainText",
    TEXT_COLOR: "textColor",
    TEXT_SIZE: "textSize",
    SHAPE_TEXT_BOX: "mxgraph.mockup.text.textBox"
};
mxShapeMockupTextBox.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxShapeMockupTextBox.prototype.background = function(c, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupTextBox.prototype.foreground = function(c, w, h) {
    var mainText = mxUtils.getValue(this.style, mxShapeMockupTextBox.prototype.cst.MAIN_TEXT, "Note line 1").toString().split(",");
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupTextBox.prototype.cst.TEXT_COLOR, "#666666");
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupTextBox.prototype.cst.TEXT_SIZE, "17");
    c.setFontColor(fontColor);
    c.setFontSize(fontSize);
    for (var i = 0; i < mainText.length; i++)
        c.text(5, i * fontSize * 1.5 + fontSize * .75, 0, 0, mainText[i], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxShapeMockupTextBox.prototype.cst.SHAPE_TEXT_BOX, mxShapeMockupTextBox);
function mxShapeMockupCaptcha(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupCaptcha, mxShape);
mxShapeMockupCaptcha.prototype.cst = {
    MAIN_TEXT: "mainText",
    TEXT_COLOR: "textColor",
    TEXT_SIZE: "textSize",
    SHAPE_CAPTCHA: "mxgraph.mockup.text.captcha"
};
mxShapeMockupCaptcha.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxShapeMockupCaptcha.prototype.background = function(c, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupCaptcha.prototype.foreground = function(c, w, h) {
    var mainText = mxUtils.getValue(this.style, mxShapeMockupCaptcha.prototype.cst.MAIN_TEXT, "Note line 1");
    var fontColor = mxUtils.getValue(this.style, mxShapeMockupCaptcha.prototype.cst.TEXT_COLOR, "#666666");
    var fontSize = mxUtils.getValue(this.style, mxShapeMockupCaptcha.prototype.cst.TEXT_SIZE, "25");
    c.setFillColor("#88aaff");
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w * .35, 0);
    c.lineTo(w * .55, h * .85);
    c.lineTo(w * .4, h * .75);
    c.close();
    c.fill();
    c.begin();
    c.moveTo(w * .7, h * .1);
    c.lineTo(w * .95, h * .23);
    c.lineTo(w, h * .4);
    c.lineTo(w, h * .9);
    c.lineTo(w, h);
    c.lineTo(w * .8, h);
    c.close();
    c.fill();
    c.setFontColor(fontColor);
    c.setFontSize(fontSize);
    c.text(w * .5, h * .5, 0, 0, mainText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.rect(0, 0, w, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupCaptcha.prototype.cst.SHAPE_CAPTCHA, mxShapeMockupCaptcha);
function mxShapeMockupAlphanumeric(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupAlphanumeric, mxShape);
mxShapeMockupAlphanumeric.prototype.cst = {
    MAIN_TEXT: "linkText",
    TEXT_SIZE: "textSize",
    TEXT_COLOR: "textColor",
    SHAPE_ALPHANUMERIC: "mxgraph.mockup.text.alphanumeric"
};
mxShapeMockupAlphanumeric.prototype.paintVertexShape = function(c, x, y, w, h) {
    var mainText = mxUtils.getValue(this.style, mxShapeMockupAlphanumeric.prototype.cst.MAIN_TEXT, "0-9 A B C D E F G H I J K L M N O P Q R S T U V X Y Z");
    var textSize = mxUtils.getValue(this.style, mxShapeMockupAlphanumeric.prototype.cst.TEXT_SIZE, "17");
    var textColor = mxUtils.getValue(this.style, mxShapeMockupAlphanumeric.prototype.cst.TEXT_COLOR, "#0000ff");
    c.translate(x, y);
    var width = mxUtils.getSizeForString(mainText, textSize, mxConstants.DEFAULT_FONTFAMILY).width;
    c.setStrokeColor(textColor);
    c.setFontSize(textSize);
    c.setFontColor(textColor);
    c.text(w * .5, h * .5, 0, 0, mainText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.begin();
    c.moveTo(w * .5 - width * .5, (h + parseInt(textSize, 10)) * .5);
    c.lineTo(w * .5 + width * .5, (h + parseInt(textSize, 10)) * .5);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupAlphanumeric.prototype.cst.SHAPE_ALPHANUMERIC, mxShapeMockupAlphanumeric);
function mxShapeMockupTextRRect(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupTextRRect, mxShape);
mxShapeMockupTextRRect.prototype.cst = {
    RRECT: "mxgraph.mockup.text.rrect",
    R_SIZE: "rSize"
};
mxShapeMockupTextRRect.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupTextRRect.prototype.cst.R_SIZE, "10"));
    c.roundrect(0, 0, w, h, rSize);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupTextRRect.prototype.cst.RRECT, mxShapeMockupTextRRect);
var mxMockupC = {
    BAR_HEIGHT: "barHeight",
    BAR_POS: "barPos",
    BG_STYLE: "bgStyle",
    BG_FLAT_GREEN: "bgGreen",
    BG_FLAT_WHITE: "bgWhite",
    BG_FLAT_GRAY: "bgGray",
    BG_FLAT_CUSTOM: "bgFlat",
    BG_MAP: "bgMap",
    BG_STRIPED: "bgStriped",
    BUTTON_STYLE: "buttonStyle",
    BUTTON_TEXT: "buttonText",
    BUTTON_STATE: "buttonState",
    CHEVRON: "chevron",
    GRID_SIZE: "gridSize",
    POINTER_BOTTOM: "bottom",
    POINTER_POS: "pointerPos",
    POINTER_TOP: "top",
    ROUND: "round",
    SELECTED: "+",
    STATE_ON: "on",
    STATE_OFF: "off",
    SUB_TEXT: "subText",
    SHAPE_IADD_ICON: "mxgraph.ios.iAddIcon",
    SHAPE_IALERT_BOX: "mxgraph.ios.iAlertBox",
    SHAPE_IALPHA_LIST: "mxgraph.ios.iAlphaList",
    SHAPE_IAPP_BAR: "mxgraph.ios.iAppBar",
    SHAPE_IARROW_ICON: "mxgraph.ios.iArrowIcon",
    SHAPE_IBG_FLAT: "mxgraph.ios.iBgFlat",
    SHAPE_IBG_MAP: "mxgraph.ios.iBgMap",
    SHAPE_IBG_STRIPED: "mxgraph.ios.iBgStriped",
    SHAPE_IBUTTON: "mxgraph.ios.iButton",
    SHAPE_IBUTTON_BACK: "mxgraph.ios.iButtonBack",
    SHAPE_IBUTTON_FORWARD: "mxgraph.ios.iButtonFw",
    SHAPE_IBUTTON_BAR: "mxgraph.ios.iButtonBar",
    SHAPE_ICALL_BUTTONS: "mxgraph.ios.iCallButtons",
    SHAPE_ICALL_DIALOG: "mxgraph.ios.iCallDialog",
    SHAPE_ICHECKBOX_GROUP: "mxgraph.ios.iCheckboxGroup",
    SHAPE_ICHECK_ICON: "mxgraph.ios.iCheckIcon",
    SHAPE_ICLOUD_PROGRESS_BAR: "mxgraph.ios.iCloudProgressBar",
    SHAPE_ICOMBO_BOX: "mxgraph.ios.iComboBox",
    SHAPE_ICOPY: "mxgraph.ios.iCopy",
    SHAPE_ICOPY_AREA: "mxgraph.ios.iCopyArea",
    SHAPE_IICON_GRID: "mxgraph.ios.iIconGrid",
    SHAPE_IDELETE_APP: "mxgraph.ios.iDeleteApp",
    SHAPE_IDELETE_ICON: "mxgraph.ios.iDeleteIcon",
    SHAPE_IDOWNLOAD_BAR: "mxgraph.ios.iDownloadBar",
    SHAPE_IDIALOG_BOX: "mxgraph.ios.iDialogBox",
    SHAPE_IDIRECTION: "mxgraph.ios.iDir",
    SHAPE_IHOME_PAGE_CONTROL: "mxgraph.ios.iHomePageControl",
    SHAPE_IKEYB_LETTERS: "mxgraph.ios.iKeybLett",
    SHAPE_IKEYB_NUMBERS: "mxgraph.ios.iKeybNumb",
    SHAPE_IKEYB_SYMBOLS: "mxgraph.ios.iKeybSymb",
    SHAPE_ILOCATION_BAR: "mxgraph.ios.iLocBar",
    SHAPE_ILOCK_BUTTON: "mxgraph.ios.iLockButton",
    SHAPE_IHOR_BUTTON_BAR: "mxgraph.ios.iHorButtonBar",
    SHAPE_IINFO_ICON: "mxgraph.ios.iInfoIcon",
    SHAPE_ION_OFF_BUTTON: "mxgraph.ios.iOnOffButton",
    SHAPE_IOPTION: "mxgraph.ios.iOption",
    SHAPE_IPAGE_CONTROL: "mxgraph.ios.iPageControl",
    SHAPE_IPAD: "mxgraph.ios.iPad",
    SHAPE_IPHONE: "mxgraph.ios.iPhone",
    SHAPE_IPIN: "mxgraph.ios.iPin",
    SHAPE_IPREV_NEXT: "mxgraph.ios.iPrevNext",
    SHAPE_IPROGRESS_BAR: "mxgraph.ios.iProgressBar",
    SHAPE_IRADIO_GROUP: "mxgraph.ios.iRadioGroup",
    SHAPE_ISLIDER: "mxgraph.ios.iSlider",
    SHAPE_ISORT_FIND_ICON: "mxgraph.ios.iSortFindIcon",
    SHAPE_ITEXT_INPUT: "mxgraph.ios.iTextInput",
    SHAPE_ITOP_BAR: "mxgraph.ios.iTopBar",
    SHAPE_ITOP_BAR_LOCKED: "mxgraph.ios.iTopBarLocked",
    SHAPE_IURL_BAR: "mxgraph.ios.iURLBar",
    SHAPE_IVIDEO_CONTROLS: "mxgraph.ios.iVideoControls",
    SHAPE_ISCREEN_NAME_BAR: "mxgraph.ios.iScreenNameBar",
    STYLE_FILLCOLOR2: "fillColor2",
    STYLE_FILLCOLOR3: "fillColor3",
    STYLE_TEXTCOLOR: "textColor",
    STYLE_TEXTCOLOR2: "textColor2",
    STYLE_STROKECOLOR2: "strokeColor2",
    STYLE_STROKECOLOR3: "strokeColor3"
};
function mxShapeMockupiPhone(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiPhone, mxShape);
mxShapeMockupiPhone.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = 25;
    this.background(c, x, y, w, h, rSize);
    c.setShadow(false);
    this.foreground(c, x, y, w, h, rSize)
}
;
mxShapeMockupiPhone.prototype.background = function(c, x, y, w, h, rSize) {
    c.setFillColor("#000000");
    c.setStrokeColor("#000000");
    c.roundrect(0, 0, w, h, rSize, rSize);
    c.fillAndStroke()
}
;
mxShapeMockupiPhone.prototype.foreground = function(c, x, y, w, h, rSize) {
    c.setStrokeWidth(1.5);
    c.begin();
    c.setGradient("#808080", "#000000", w * .325, 0, w * .675, h * .5, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.moveTo(w * .325, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, h * .5);
    c.lineTo(w * .7, h * .5);
    c.close();
    c.fill();
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "");
    var bgStyle = mxUtils.getValue(this.style, mxMockupC.BG_STYLE, mxMockupC.BG_FLAT_GREEN);
    c.setStrokeWidth(1);
    if (bgStyle === mxMockupC.BG_FLAT_WHITE) {
        c.setFillColor("#ffffff");
        c.rect(w * .0625, h * .15, w * .875, h * .7);
        c.fill()
    } else if (bgStyle === mxMockupC.BG_FLAT_GREEN) {
        c.setFillColor("#1f2923");
        c.rect(w * .0625, h * .15, w * .875, h * .7);
        c.fill()
    } else if (bgStyle === mxMockupC.BG_FLAT_GRAY) {
        c.setFillColor("#dddddd");
        c.rect(w * .0625, h * .15, w * .875, h * .7);
        c.fill()
    } else if (bgStyle === mxMockupC.BG_FLAT_CUSTOM) {
        c.setFillColor(fillColor);
        c.rect(w * .0625, h * .15, w * .875, h * .7);
        c.fill()
    } else if (bgStyle === mxMockupC.BG_STRIPED) {
        var xOld = x;
        var yOld = y;
        var wOld = w;
        var hOld = h;
        c.translate(w * .0625, h * .15);
        w = w * .875;
        h = h * .7;
        c.setFillColor("#5D7585");
        c.rect(0, 0, w, h);
        c.fillAndStroke();
        var strokeColor = "#18211b";
        var strokeColor2 = "#657E8F";
        c.setStrokeColor(strokeColor2);
        var i = 5;
        c.begin();
        while (i < w) {
            c.moveTo(i, 0);
            c.lineTo(i, h);
            i = i + 5
        }
        c.stroke();
        c.setStrokeColor(strokeColor);
        c.begin();
        c.rect(0, 0, w, h);
        c.stroke();
        w = wOld;
        h = hOld;
        c.translate(-w * .0625, -h * .15)
    } else if (bgStyle === mxMockupC.BG_MAP) {
        var xOld = x;
        var yOld = y;
        var wOld = w;
        var hOld = h;
        c.translate(w * .0625, h * .15);
        w = w * .875;
        h = h * .7;
        c.setFillColor("#ffffff");
        c.rect(0, 0, w, h);
        c.fillAndStroke();
        var fillColor2 = "#96D1FF";
        var strokeColor = "#18211b";
        var strokeColor2 = "#008cff";
        c.setFillColor(fillColor2);
        c.setStrokeColor(strokeColor2);
        c.setStrokeWidth(1);
        c.begin();
        c.moveTo(0, 0);
        c.lineTo(w * .1171, 0);
        c.lineTo(w * .1136, h * .0438);
        c.lineTo(w * .0993, h * .054);
        c.lineTo(0, h * .0446);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .1993, 0);
        c.lineTo(w * .1914, h * .03884);
        c.lineTo(w * .1536, h * .0362);
        c.lineTo(w * .1586, 0);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .24, 0);
        c.lineTo(w * .2257, h * .054);
        c.lineTo(w * .2414, h * .0674);
        c.lineTo(w * .4707, h * .0835);
        c.lineTo(w * .5264, h * .0906);
        c.lineTo(w * .6429, h * .0929);
        c.arcTo(w * .0857, h * .0536, 0, 0, 0, w * .7193, h * .0621);
        c.arcTo(w * .48, h * .2143, 0, 0, 0, w * .7286, 0);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .8, 0);
        c.lineTo(w * .7886, h * .04554);
        c.arcTo(w * .0857, h * .0536, 0, 0, 0, w * .8164, h * .0875);
        c.arcTo(w * .1429, h * .0893, 0, 0, 0, w * .88, h * .1036);
        c.lineTo(w, h * .1112);
        c.lineTo(w, 0);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(0, h * .0933);
        c.lineTo(w * .08, h * .1036);
        c.lineTo(w * .1021, h * .1246);
        c.lineTo(w * .1007, h * .1768);
        c.lineTo(w * .0471, h * .2241);
        c.lineTo(0, h * .2527);
        c.close();
        c.fillAndStroke();
        c.ellipse(w * .1214, h * .0603, w * .0843, h * .0576);
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .1293, h * .1924);
        c.lineTo(w * .1729, h * .142);
        c.lineTo(w * .1407, h * .1411);
        c.lineTo(w * .14, h * .1777);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .4586, h * .1241);
        c.lineTo(w * .455, h * .1835);
        c.lineTo(w * .3893, h * .2246);
        c.lineTo(w * .2171, h * .1362);
        c.lineTo(w * .2171, h * .1308);
        c.lineTo(w * .2293, h * .1214);
        c.lineTo(w * .2857, h * .1174);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .5079, h * .1134);
        c.lineTo(w * .7307, h * .1223);
        c.lineTo(w * .7279, h * .1625);
        c.lineTo(w * .715, h * .1772);
        c.lineTo(w * .6929, h * .1688);
        c.lineTo(w * .625, h * .1795);
        c.lineTo(w * .4779, h * .2835);
        c.lineTo(w * .395, h * .2299);
        c.lineTo(w * .4657, h * .1826);
        c.lineTo(w * .4707, h * .1223);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w, h * .1362);
        c.lineTo(w * .7643, h * .1237);
        c.lineTo(w * .7543, h * .1562);
        c.lineTo(w * .7643, h * .1585);
        c.lineTo(w * .9186, h * .2366);
        c.lineTo(w, h * .1732);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .2079, h * .1545);
        c.lineTo(w * .3886, h * .2536);
        c.lineTo(w * .3414, h * .2933);
        c.lineTo(w * .1743, h * .1969);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .1579, h * .2134);
        c.lineTo(w * .3221, h * .3067);
        c.lineTo(w * .2957, h * .3237);
        c.lineTo(w * .1157, h * .2424);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .405, h * .2656);
        c.lineTo(w * .31, h * .3353);
        c.lineTo(w * .3693, h * .3661);
        c.lineTo(w * .4571, h * .2982);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .7121, h * .1848);
        c.lineTo(w * .6879, h * .1754);
        c.lineTo(w * .6329, h * .1844);
        c.lineTo(w * .61, h * .2018);
        c.lineTo(w * .6207, h * .2085);
        c.lineTo(w * .4986, h * .2982);
        c.lineTo(w * .535, h * .3237);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .5557, h * .3379);
        c.lineTo(w * .7464, h * .1826);
        c.lineTo(w * .8036, h * .2076);
        c.lineTo(w * .595, h * .3616);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .8293, h * .2188);
        c.lineTo(w * .8979, h * .2509);
        c.lineTo(w * .6936, h * .4125);
        c.lineTo(w * .6171, h * .3737);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w, h * .2138);
        c.lineTo(w * .6821, h * .4603);
        c.lineTo(w * .815, h * .5277);
        c.lineTo(w, h * .4);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(0, h * .317);
        c.lineTo(w * .0971, h * .2554);
        c.lineTo(w * .4121, h * .4143);
        c.lineTo(w * .3736, h * .4415);
        c.lineTo(w * .315, h * .4076);
        c.lineTo(w * .3093, h * .4116);
        c.lineTo(w * .3686, h * .4455);
        c.lineTo(w * .285, h * .5045);
        c.lineTo(w * .1114, h * .4134);
        c.lineTo(w * .025, h * .4603);
        c.lineTo(w * .0371, h * .4723);
        c.lineTo(w * .1114, h * .4371);
        c.lineTo(w * .2871, h * .5312);
        c.lineTo(w * .1929, h * .6058);
        c.lineTo(w * .2271, h * .6705);
        c.lineTo(w * .17, h * .7147);
        c.lineTo(w * .0314, h * .6321);
        c.lineTo(0, h * .6246);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .48, h * .3121);
        c.lineTo(w * .5157, h * .3375);
        c.lineTo(w * .4314, h * .3982);
        c.lineTo(w * .3929, h * .3786);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .3086, h * .5179);
        c.lineTo(w * .53, h * .3518);
        c.lineTo(w * .5757, h * .3745);
        c.lineTo(w * .3479, h * .5411);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .5964, h * .3884);
        c.lineTo(w * .6736, h * .4277);
        c.lineTo(w * .445, h * .5991);
        c.lineTo(w * .3664, h * .5531);
        c.lineTo(w * .5057, h * .4545);
        c.lineTo(w * .5507, h * .4754);
        c.lineTo(w * .5571, h * .4723);
        c.lineTo(w * .5114, h * .4504);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .4793, h * .6161);
        c.lineTo(w * .6771, h * .4643);
        c.lineTo(w * .8086, h * .5326);
        c.lineTo(w * .7471, h * .5817);
        c.lineTo(w * .7214, h * .567);
        c.lineTo(w * .715, h * .571);
        c.lineTo(w * .7421, h * .5871);
        c.lineTo(w * .6014, h * .6933);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w, h * .4371);
        c.lineTo(w * .8443, h * .546);
        c.lineTo(w * .9071, h * .5701);
        c.lineTo(w, h * .5022);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .8407, h * .5504);
        c.lineTo(w * .8993, h * .5759);
        c.lineTo(w * .6757, h * .7416);
        c.lineTo(w * .6286, h * .7139);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w, h * .5321);
        c.lineTo(w * .6979, h * .7549);
        c.lineTo(w * .7457, h * .7781);
        c.lineTo(w * .9814, h * .6094);
        c.lineTo(w, h * .6067);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w, h * .6254);
        c.lineTo(w * .7664, h * .792);
        c.lineTo(w * .9586, h * .9062);
        c.lineTo(w, h * .8786);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .3093, h * .5464);
        c.lineTo(w * .4271, h * .6152);
        c.lineTo(w * .245, h * .7643);
        c.lineTo(w * .185, h * .7228);
        c.lineTo(w * .2493, h * .6728);
        c.lineTo(w * .2214, h * .6143);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(0, h * .65);
        c.lineTo(w * .2179, h * .7826);
        c.lineTo(w * .1136, h * .8424);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(0, h * .7272);
        c.lineTo(w * .0821, h * .859);
        c.lineTo(0, h * .9085);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .4529, h * .6366);
        c.lineTo(w * .575, h * .7143);
        c.lineTo(w * .39, h * .8621);
        c.lineTo(w * .2657, h * .7902);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(0, h * .9415);
        c.lineTo(w * .1036, h * .8821);
        c.lineTo(w * .2343, h * .959);
        c.lineTo(w * .1721, h);
        c.lineTo(0, h);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .2586, h * .7951);
        c.lineTo(w * .3829, h * .8674);
        c.lineTo(w * .2543, h * .9451);
        c.lineTo(w * .1279, h * .8692);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .2836, h * .9639);
        c.lineTo(w * .4207, h * .8772);
        c.lineTo(w * .605, h * .7321);
        c.lineTo(w * .6521, h * .7634);
        c.lineTo(w * .3486, h);
        c.lineTo(w * .3393, h);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .3879, h);
        c.lineTo(w * .6721, h * .7759);
        c.lineTo(w * .7171, h * .7982);
        c.lineTo(w * .4564, h);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .4986, h);
        c.lineTo(w * .7386, h * .8125);
        c.lineTo(w * .9307, h * .925);
        c.lineTo(w * .8264, h);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .8671, h);
        c.lineTo(w * .9464, h * .9491);
        c.lineTo(w, h * .975);
        c.lineTo(w, h);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .2295, h);
        c.lineTo(w * .2648, h * .9792);
        c.lineTo(w * .2981, h);
        c.close();
        c.fillAndStroke();
        w = wOld;
        h = hOld;
        c.translate(-w * .0625, -h * .15)
    }
    c.setStrokeWidth(1);
    c.setStrokeColor("#18211b");
    c.rect(w * .0625, h * .15, w * .875, h * .7);
    c.stroke();
    c.setStrokeWidth(1.5);
    c.setAlpha(.8);
    c.setStrokeColor("#dddddd");
    c.roundrect(0, 0, w, h, rSize, rSize);
    c.stroke();
    rSize = 22.5;
    c.begin();
    c.setStrokeColor("#666666");
    c.roundrect(5, 5, w - 10, h - 10, rSize, rSize);
    c.stroke();
    c.setAlpha(1);
    c.ellipse(w * .4875, h * .04125, w * .025, h * .0125);
    c.setStrokeWidth(2.5);
    c.setStrokeColor("#000000");
    c.setFillColor("#000099");
    c.fillAndStroke();
    c.begin();
    c.setStrokeWidth(1.5);
    c.setFillColor("#444444");
    c.setStrokeColor("#333333");
    rSize = 4;
    c.roundrect(w * .375, h * .075, w * .25, h * .01875, w * .02, h * .01);
    c.fillAndStroke();
    c.setGradient("#bbbbbb", "#000000", w * .4, h * .875, w * .2, h * .1, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.ellipse(w * .4, h * .875, w * .2, h * .1);
    c.fill();
    c.setAlpha(.5);
    c.ellipse(w * .404, h * .876, w * .19, h * .095);
    c.stroke();
    c.begin();
    c.setAlpha(.85);
    c.setFillColor("#000000");
    c.moveTo(w * .4025, h * .925);
    c.arcTo(w * .0975, h * .04625, 0, 0, 1, w * .5975, h * .925);
    c.arcTo(w * .2, h * .1, 0, 0, 1, w * .4025, h * .925);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.setAlpha(.7);
    c.setStrokeWidth(1.5);
    c.setStrokeColor("#dddddd");
    rSize = 4;
    c.roundrect(w * .4575, h * .905, w * .0875, h * .04375, h * .00625, h * .00625);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IPHONE, mxShapeMockupiPhone);
function mxShapeMockupiBgFlat(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiBgFlat, mxShape);
mxShapeMockupiBgFlat.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h)
}
;
mxShapeMockupiBgFlat.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IBG_FLAT, mxShapeMockupiBgFlat);
function mxShapeMockupiBgStriped(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiBgStriped, mxShape);
mxShapeMockupiBgStriped.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeMockupiBgStriped.prototype.background = function(c, x, y, w, h) {
    c.setStrokeWidth(1);
    c.begin();
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupiBgStriped.prototype.foreground = function(c, x, y, w, h) {
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "");
    var strokeColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_STROKECOLOR2, "");
    c.setStrokeColor(strokeColor2);
    var i = 5;
    c.begin();
    while (i < w) {
        c.moveTo(i, 0);
        c.lineTo(i, h);
        i = i + 5
    }
    c.stroke();
    c.setStrokeColor(strokeColor);
    c.begin();
    c.rect(0, 0, w, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IBG_STRIPED, mxShapeMockupiBgStriped);
function mxShapeMockupiBgMap(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiBgMap, mxShape);
mxShapeMockupiBgMap.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeMockupiBgMap.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupiBgMap.prototype.foreground = function(c, x, y, w, h) {
    var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, "");
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "");
    var strokeColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_STROKECOLOR2, "");
    c.setFillColor(fillColor2);
    c.setStrokeColor(strokeColor2);
    c.setStrokeWidth(.5);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w * .1171, 0);
    c.lineTo(w * .1136, h * .0438);
    c.lineTo(w * .0993, h * .054);
    c.lineTo(0, h * .0446);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .1993, 0);
    c.lineTo(w * .1914, h * .03884);
    c.lineTo(w * .1536, h * .0362);
    c.lineTo(w * .1586, 0);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .24, 0);
    c.lineTo(w * .2257, h * .054);
    c.lineTo(w * .2414, h * .0674);
    c.lineTo(w * .4707, h * .0835);
    c.lineTo(w * .5264, h * .0906);
    c.lineTo(w * .6429, h * .0929);
    c.arcTo(w * .0857, h * .0536, 0, 0, 0, w * .7193, h * .0621);
    c.arcTo(w * .48, h * .2143, 0, 0, 0, w * .7286, 0);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .8, 0);
    c.lineTo(w * .7886, h * .04554);
    c.arcTo(w * .0857, h * .0536, 0, 0, 0, w * .8164, h * .0875);
    c.arcTo(w * .1429, h * .0893, 0, 0, 0, w * .88, h * .1036);
    c.lineTo(w, h * .1112);
    c.lineTo(w, 0);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(0, h * .0933);
    c.lineTo(w * .08, h * .1036);
    c.lineTo(w * .1021, h * .1246);
    c.lineTo(w * .1007, h * .1768);
    c.lineTo(w * .0471, h * .2241);
    c.lineTo(0, h * .2527);
    c.close();
    c.fillAndStroke();
    c.ellipse(w * .1214, h * .0603, w * .0843, h * .0576);
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .1293, h * .1924);
    c.lineTo(w * .1729, h * .142);
    c.lineTo(w * .1407, h * .1411);
    c.lineTo(w * .14, h * .1777);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .4586, h * .1241);
    c.lineTo(w * .455, h * .1835);
    c.lineTo(w * .3893, h * .2246);
    c.lineTo(w * .2171, h * .1362);
    c.lineTo(w * .2171, h * .1308);
    c.lineTo(w * .2293, h * .1214);
    c.lineTo(w * .2857, h * .1174);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .5079, h * .1134);
    c.lineTo(w * .7307, h * .1223);
    c.lineTo(w * .7279, h * .1625);
    c.lineTo(w * .715, h * .1772);
    c.lineTo(w * .6929, h * .1688);
    c.lineTo(w * .625, h * .1795);
    c.lineTo(w * .4779, h * .2835);
    c.lineTo(w * .395, h * .2299);
    c.lineTo(w * .4657, h * .1826);
    c.lineTo(w * .4707, h * .1223);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w, h * .1362);
    c.lineTo(w * .7643, h * .1237);
    c.lineTo(w * .7543, h * .1562);
    c.lineTo(w * .7643, h * .1585);
    c.lineTo(w * .9186, h * .2366);
    c.lineTo(w, h * .1732);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .2079, h * .1545);
    c.lineTo(w * .3886, h * .2536);
    c.lineTo(w * .3414, h * .2933);
    c.lineTo(w * .1743, h * .1969);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .1579, h * .2134);
    c.lineTo(w * .3221, h * .3067);
    c.lineTo(w * .2957, h * .3237);
    c.lineTo(w * .1157, h * .2424);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .405, h * .2656);
    c.lineTo(w * .31, h * .3353);
    c.lineTo(w * .3693, h * .3661);
    c.lineTo(w * .4571, h * .2982);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .7121, h * .1848);
    c.lineTo(w * .6879, h * .1754);
    c.lineTo(w * .6329, h * .1844);
    c.lineTo(w * .61, h * .2018);
    c.lineTo(w * .6207, h * .2085);
    c.lineTo(w * .4986, h * .2982);
    c.lineTo(w * .535, h * .3237);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .5557, h * .3379);
    c.lineTo(w * .7464, h * .1826);
    c.lineTo(w * .8036, h * .2076);
    c.lineTo(w * .595, h * .3616);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .8293, h * .2188);
    c.lineTo(w * .8979, h * .2509);
    c.lineTo(w * .6936, h * .4125);
    c.lineTo(w * .6171, h * .3737);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w, h * .2138);
    c.lineTo(w * .6821, h * .4603);
    c.lineTo(w * .815, h * .5277);
    c.lineTo(w, h * .4);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(0, h * .317);
    c.lineTo(w * .0971, h * .2554);
    c.lineTo(w * .4121, h * .4143);
    c.lineTo(w * .3736, h * .4415);
    c.lineTo(w * .315, h * .4076);
    c.lineTo(w * .3093, h * .4116);
    c.lineTo(w * .3686, h * .4455);
    c.lineTo(w * .285, h * .5045);
    c.lineTo(w * .1114, h * .4134);
    c.lineTo(w * .025, h * .4603);
    c.lineTo(w * .0371, h * .4723);
    c.lineTo(w * .1114, h * .4371);
    c.lineTo(w * .2871, h * .5312);
    c.lineTo(w * .1929, h * .6058);
    c.lineTo(w * .2271, h * .6705);
    c.lineTo(w * .17, h * .7147);
    c.lineTo(w * .0314, h * .6321);
    c.lineTo(0, h * .6246);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .48, h * .3121);
    c.lineTo(w * .5157, h * .3375);
    c.lineTo(w * .4314, h * .3982);
    c.lineTo(w * .3929, h * .3786);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .3086, h * .5179);
    c.lineTo(w * .53, h * .3518);
    c.lineTo(w * .5757, h * .3745);
    c.lineTo(w * .3479, h * .5411);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .5964, h * .3884);
    c.lineTo(w * .6736, h * .4277);
    c.lineTo(w * .445, h * .5991);
    c.lineTo(w * .3664, h * .5531);
    c.lineTo(w * .5057, h * .4545);
    c.lineTo(w * .5507, h * .4754);
    c.lineTo(w * .5571, h * .4723);
    c.lineTo(w * .5114, h * .4504);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .4793, h * .6161);
    c.lineTo(w * .6771, h * .4643);
    c.lineTo(w * .8086, h * .5326);
    c.lineTo(w * .7471, h * .5817);
    c.lineTo(w * .7214, h * .567);
    c.lineTo(w * .715, h * .571);
    c.lineTo(w * .7421, h * .5871);
    c.lineTo(w * .6014, h * .6933);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w, h * .4371);
    c.lineTo(w * .8443, h * .546);
    c.lineTo(w * .9071, h * .5701);
    c.lineTo(w, h * .5022);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .8407, h * .5504);
    c.lineTo(w * .8993, h * .5759);
    c.lineTo(w * .6757, h * .7416);
    c.lineTo(w * .6286, h * .7139);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w, h * .5321);
    c.lineTo(w * .6979, h * .7549);
    c.lineTo(w * .7457, h * .7781);
    c.lineTo(w * .9814, h * .6094);
    c.lineTo(w, h * .6067);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w, h * .6254);
    c.lineTo(w * .7664, h * .792);
    c.lineTo(w * .9586, h * .9062);
    c.lineTo(w, h * .8786);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .3093, h * .5464);
    c.lineTo(w * .4271, h * .6152);
    c.lineTo(w * .245, h * .7643);
    c.lineTo(w * .185, h * .7228);
    c.lineTo(w * .2493, h * .6728);
    c.lineTo(w * .2214, h * .6143);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(0, h * .65);
    c.lineTo(w * .2179, h * .7826);
    c.lineTo(w * .1136, h * .8424);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(0, h * .7272);
    c.lineTo(w * .0821, h * .859);
    c.lineTo(0, h * .9085);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .4529, h * .6366);
    c.lineTo(w * .575, h * .7143);
    c.lineTo(w * .39, h * .8621);
    c.lineTo(w * .2657, h * .7902);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(0, h * .9415);
    c.lineTo(w * .1036, h * .8821);
    c.lineTo(w * .2343, h * .959);
    c.lineTo(w * .1721, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .2586, h * .7951);
    c.lineTo(w * .3829, h * .8674);
    c.lineTo(w * .2543, h * .9451);
    c.lineTo(w * .1279, h * .8692);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .2836, h * .9639);
    c.lineTo(w * .4207, h * .8772);
    c.lineTo(w * .605, h * .7321);
    c.lineTo(w * .6521, h * .7634);
    c.lineTo(w * .3486, h);
    c.lineTo(w * .3393, h);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .3879, h);
    c.lineTo(w * .6721, h * .7759);
    c.lineTo(w * .7171, h * .7982);
    c.lineTo(w * .4564, h);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .4986, h);
    c.lineTo(w * .7386, h * .8125);
    c.lineTo(w * .9307, h * .925);
    c.lineTo(w * .8264, h);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .8671, h);
    c.lineTo(w * .9464, h * .9491);
    c.lineTo(w, h * .975);
    c.lineTo(w, h);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .2295, h);
    c.lineTo(w * .2648, h * .9792);
    c.lineTo(w * .2981, h);
    c.close();
    c.fillAndStroke();
    c.setStrokeWidth(1);
    c.setStrokeColor(strokeColor);
    c.begin();
    c.rect(0, 0, w, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IBG_MAP, mxShapeMockupiBgMap);
function mxShapeMockupiButtonBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiButtonBar, mxShape);
mxShapeMockupiButtonBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    var textStrings = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, "+Button 1, Button 2, Button 3").toString().split(",");
    var fontColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR, "#666666");
    var selectedFontColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR2, "#ffffff");
    var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "17").toString();
    var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#666666");
    var separatorColor = mxUtils.getValue(this.style, mxMockupC.STYLE_STROKECOLOR2, "#c4c4c4");
    var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var buttonNum = textStrings.length;
    var maxButtonWidth = 0;
    var selectedButton = -1;
    var rSize = 2.5;
    var labelOffset = 2.5;
    for (var i = 0; i < buttonNum; i++) {
        var buttonText = textStrings[i];
        if (buttonText.charAt(0) === mxMockupC.SELECTED) {
            buttonText = textStrings[i].substring(1);
            selectedButton = i
        }
        var currWidth = mxUtils.getSizeForString(buttonText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
        if (currWidth > maxButtonWidth)
            maxButtonWidth = currWidth
    }
    var minButtonHeight = fontSize * 1.5;
    var minH = buttonNum * minButtonHeight;
    var trueH = Math.max(h, minH);
    var minW = 2 * labelOffset + maxButtonWidth;
    var trueW = Math.max(w, minW);
    c.translate(x, y);
    this.background(c, trueW, trueH, rSize, buttonNum, labelOffset, buttonNum * minButtonHeight, frameColor, separatorColor, bgColor, selectedButton, minButtonHeight);
    c.setShadow(false);
    this.foreground(c, trueW, trueH, rSize, buttonNum, labelOffset, buttonNum * minButtonHeight, frameColor, separatorColor, bgColor, selectedButton, minButtonHeight);
    var currWidth = 0;
    for (var i = 0; i < buttonNum; i++) {
        if (i === selectedButton)
            c.setFontColor(selectedFontColor);
        else
            c.setFontColor(fontColor);
        currWidth = currWidth + labelOffset;
        var currHeight = (i * minButtonHeight + minButtonHeight * .5) * trueH / minH;
        this.buttonText(c, trueW, currHeight, textStrings[i], fontSize, separatorColor)
    }
}
;
mxShapeMockupiButtonBar.prototype.background = function(c, w, h, rSize, buttonNum, labelOffset, minH, frameColor, separatorColor, bgColor, selectedButton, minButtonHeight) {
    c.begin();
    c.setStrokeWidth(1);
    c.setStrokeColor(frameColor);
    c.setFillColor(bgColor);
    c.moveTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, h - rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
    c.lineTo(rSize, h);
    c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
    c.close();
    c.fillAndStroke()
}
;
mxShapeMockupiButtonBar.prototype.foreground = function(c, w, h, rSize, buttonNum, labelOffset, minH, frameColor, separatorColor, bgColor, selectedButton, minButtonHeight) {
    var strokeWidth = mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, "1");
    c.setStrokeWidth(strokeWidth);
    c.setStrokeColor(separatorColor);
    c.begin();
    for (var i = 1; i < buttonNum; i++)
        if (i !== selectedButton && i !== selectedButton + 1) {
            var currHeight = i * minButtonHeight * h / minH;
            c.moveTo(0, currHeight);
            c.lineTo(w, currHeight)
        }
    c.stroke();
    c.setStrokeColor(mxConstants.NONE);
    if (selectedButton === 0) {
        c.begin();
        var buttonBottom = minButtonHeight * h / minH;
        c.setGradient("#5D7585", "#008cff", 0, 0, w, buttonBottom, mxConstants.DIRECTION_SOUTH, 1, 1);
        c.moveTo(0, rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
        c.lineTo(w - rSize, 0);
        c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
        c.lineTo(w, buttonBottom);
        c.lineTo(0, buttonBottom);
        c.close();
        c.fill()
    } else if (selectedButton === buttonNum - 1) {
        c.begin();
        var buttonTop = h - minButtonHeight * h / minH;
        c.setGradient("#5D7585", "#008cff", 0, buttonTop, w, h - buttonTop, mxConstants.DIRECTION_SOUTH, 1, 1);
        c.moveTo(0, buttonTop);
        c.lineTo(w, buttonTop);
        c.lineTo(w, h - rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
        c.lineTo(rSize, h);
        c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
        c.close();
        c.fill()
    } else if (selectedButton !== -1) {
        c.begin();
        var buttonTop = minButtonHeight * selectedButton * h / minH;
        var buttonBottom = minButtonHeight * (selectedButton + 1) * h / minH;
        c.setGradient("#5D7585", "#008cff", 0, buttonTop, w, buttonBottom - buttonTop, mxConstants.DIRECTION_SOUTH, 1, 1);
        c.moveTo(0, buttonTop);
        c.lineTo(w, buttonTop);
        c.lineTo(w, buttonBottom);
        c.lineTo(0, buttonBottom);
        c.close();
        c.fill()
    }
    c.begin();
    c.setStrokeColor(frameColor);
    c.setFillColor(bgColor);
    c.moveTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, h - rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
    c.lineTo(rSize, h);
    c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
    c.close();
    c.stroke()
}
;
mxShapeMockupiButtonBar.prototype.buttonText = function(c, w, h, textString, fontSize, separatorColor) {
    if (textString.charAt(0) === mxMockupC.SELECTED)
        textString = textString.substring(1);
    c.setFontSize(fontSize);
    c.text(10, h, 0, 0, textString, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    var mSize = fontSize * .5;
    c.setStrokeWidth(fontSize * .3);
    c.setStrokeColor(separatorColor);
    c.begin();
    c.moveTo(w - 20 - mSize, h - mSize);
    c.lineTo(w - 20, h);
    c.lineTo(w - 20 - mSize, h + mSize);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IBUTTON_BAR, mxShapeMockupiButtonBar);
function mxShapeMockupiAppBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiAppBar, mxShape);
mxShapeMockupiAppBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeMockupiAppBar.prototype.background = function(c, x, y, w, h) {
    c.setGradient("#eeeeee", "#999999", 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.rect(0, 0, w, h);
    c.fill()
}
;
mxShapeMockupiAppBar.prototype.foreground = function(c, x, y, w, h) {
    c.setFillColor("#0099ff");
    c.rect(5, h * .5 + 1.75, 1.5, 2.5);
    c.fill();
    c.rect(7, h * .5 + .75, 1.5, 3.5);
    c.fill();
    c.rect(9, h * .5 - .25, 1.5, 4.5);
    c.fill();
    c.rect(11, h * .5 - 1.25, 1.5, 5.5);
    c.fill();
    c.rect(13, h * .5 - 2.25, 1.5, 6.5);
    c.fill();
    c.rect(15, h * .5 - 3.25, 1.5, 7.5);
    c.fill();
    c.setFillColor("#999999");
    c.ellipse(w - 56.5, h * .5 - 4, 8, 8);
    c.fill();
    c.setStrokeColor("#cccccc");
    c.begin();
    c.moveTo(w - 52.5, h * .5 - 3);
    c.lineTo(w - 52.5, h * .5);
    c.lineTo(w - 54.5, h * .5);
    c.stroke();
    c.setStrokeWidth(.5);
    c.setStrokeColor("#333333");
    c.setFillColor("#990000");
    c.begin();
    c.moveTo(w - 45.5, h * .5);
    c.lineTo(w - 37.5, h * .5 - 5);
    c.lineTo(w - 41.5, h * .5 + 4);
    c.lineTo(w - 42, h * .5 + .5);
    c.close();
    c.fillAndStroke();
    c.setFillColor("#999999");
    c.setStrokeColor("#999999");
    c.begin();
    c.moveTo(w - 28.5, h * .5 + 3.5);
    c.arcTo(3.5, 3.5, 0, 1, 1, w - 26.5, h * .5 + 1);
    c.stroke();
    c.begin();
    c.moveTo(w - 27.25, h * .5 + .25);
    c.lineTo(w - 25.75, h * .5 + .25);
    c.lineTo(w - 26.5, h * .5 + 1.5);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w - 31, h * .5 - .5);
    c.arcTo(1, 1.5, 0, 0, 1, w - 29, h * .5 - .5);
    c.stroke();
    c.rect(w - 31.5, h * .5 - .5, 3, 2);
    c.fillAndStroke();
    c.setGradient("#eeeeee", "#444444", w - 20, h * .5 - 3, 16.5, 6, mxConstants.DIRECTION_NORTH, 1, 1);
    c.begin();
    c.moveTo(w - 20, h * .5 - 3);
    c.lineTo(w - 5, h * .5 - 3);
    c.lineTo(w - 5, h * .5 - 1);
    c.lineTo(w - 3.5, h * .5 - 1);
    c.lineTo(w - 3.5, h * .5 + 1);
    c.lineTo(w - 5, h * .5 + 1);
    c.lineTo(w - 5, h * .5 + 3);
    c.lineTo(w - 20, h * .5 + 3);
    c.close();
    c.fill();
    c.setGradient("#E2FFEB", "#008215", w - 20, h * .5 - 3, 10, 6, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.begin();
    c.moveTo(w - 20, h * .5 - 3);
    c.lineTo(w - 10, h * .5 - 3);
    c.lineTo(w - 10, h * .5 + 3);
    c.lineTo(w - 20, h * .5 + 3);
    c.close();
    c.fill();
    c.setStrokeColor("#666666");
    c.begin();
    c.moveTo(w - 20, h * .5 - 3);
    c.lineTo(w - 5, h * .5 - 3);
    c.lineTo(w - 5, h * .5 - 1);
    c.lineTo(w - 3.5, h * .5 - 1);
    c.lineTo(w - 3.5, h * .5 + 1);
    c.lineTo(w - 5, h * .5 + 1);
    c.lineTo(w - 5, h * .5 + 3);
    c.lineTo(w - 20, h * .5 + 3);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IAPP_BAR, mxShapeMockupiAppBar);
function mxShapeMockupiTopBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiTopBar, mxShape);
mxShapeMockupiTopBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeMockupiTopBar.prototype.background = function(c, x, y, w, h) {
    c.setAlpha(.5);
    c.setFillColor("#999999");
    c.rect(0, 0, w, h);
    c.fill()
}
;
mxShapeMockupiTopBar.prototype.foreground = function(c, x, y, w, h) {
    c.setFillColor("#cccccc");
    c.setStrokeColor("#cccccc");
    c.setFontColor("#cccccc");
    c.setFontSize(7.5);
    c.rect(5, h * .5 + 1.75, 1.5, 2.5);
    c.fill();
    c.rect(7, h * .5 + .75, 1.5, 3.5);
    c.fill();
    c.rect(9, h * .5 - .25, 1.5, 4.5);
    c.fill();
    c.rect(11, h * .5 - 1.25, 1.5, 5.5);
    c.fill();
    c.rect(13, h * .5 - 2.25, 1.5, 6.5);
    c.fill();
    c.rect(15, h * .5 - 3.25, 1.5, 7.5);
    c.fill();
    c.text(18, h * .5, 0, 0, "CARRIER", mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .5, 0, 0, "11:15AM", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.begin();
    c.moveTo(w - 19, h * .5 - 2);
    c.lineTo(w - 10, h * .5 - 2);
    c.lineTo(w - 10, h * .5 + 2);
    c.lineTo(w - 19, h * .5 + 2);
    c.close();
    c.fill();
    c.begin();
    c.moveTo(w - 20, h * .5 - 3);
    c.lineTo(w - 5, h * .5 - 3);
    c.lineTo(w - 5, h * .5 - 1);
    c.lineTo(w - 3.5, h * .5 - 1);
    c.lineTo(w - 3.5, h * .5 + 1);
    c.lineTo(w - 5, h * .5 + 1);
    c.lineTo(w - 5, h * .5 + 3);
    c.lineTo(w - 20, h * .5 + 3);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_ITOP_BAR, mxShapeMockupiTopBar);
function mxShapeMockupiTopBar2(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiTopBar2, mxShape);
mxShapeMockupiTopBar2.prototype.cst = {
    SHAPE_ITOP_BAR2: "mxgraph.ios.iTopBar2"
};
mxShapeMockupiTopBar2.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeMockupiTopBar2.prototype.background = function(c, x, y, w, h) {
    c.rect(0, 0, w, h);
    c.fill()
}
;
mxShapeMockupiTopBar2.prototype.foreground = function(c, x, y, w, h) {
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    c.setFillColor(strokeColor);
    c.setStrokeColor(strokeColor);
    c.rect(5, h * .5 + 1.75, 1.5, 2.5);
    c.fill();
    c.rect(7, h * .5 + .75, 1.5, 3.5);
    c.fill();
    c.rect(9, h * .5 - .25, 1.5, 4.5);
    c.fill();
    c.rect(11, h * .5 - 1.25, 1.5, 5.5);
    c.fill();
    c.rect(13, h * .5 - 2.25, 1.5, 6.5);
    c.fill();
    c.rect(15, h * .5 - 3.25, 1.5, 7.5);
    c.fill();
    c.begin();
    c.moveTo(w - 19, h * .5 - 2);
    c.lineTo(w - 10, h * .5 - 2);
    c.lineTo(w - 10, h * .5 + 2);
    c.lineTo(w - 19, h * .5 + 2);
    c.close();
    c.fill();
    c.begin();
    c.moveTo(w - 20, h * .5 - 3);
    c.lineTo(w - 5, h * .5 - 3);
    c.lineTo(w - 5, h * .5 - 1);
    c.lineTo(w - 3.5, h * .5 - 1);
    c.lineTo(w - 3.5, h * .5 + 1);
    c.lineTo(w - 5, h * .5 + 1);
    c.lineTo(w - 5, h * .5 + 3);
    c.lineTo(w - 20, h * .5 + 3);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupiTopBar2.prototype.cst.SHAPE_ITOP_BAR2, mxShapeMockupiTopBar2);
function mxShapeMockupiTopBarLocked(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiTopBarLocked, mxShape);
mxShapeMockupiTopBarLocked.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeMockupiTopBarLocked.prototype.background = function(c, x, y, w, h) {
    c.setFillColor("#000000");
    c.rect(0, 0, w, h);
    c.fill()
}
;
mxShapeMockupiTopBarLocked.prototype.foreground = function(c, x, y, w, h) {
    c.setFillColor("#cccccc");
    c.setStrokeColor("#cccccc");
    c.rect(5, h * .5 + 1.75, 1.5, 2.5);
    c.fill();
    c.rect(7, h * .5 + .75, 1.5, 3.5);
    c.fill();
    c.rect(9, h * .5 - .25, 1.5, 4.5);
    c.fill();
    c.rect(11, h * .5 - 1.25, 1.5, 5.5);
    c.fill();
    c.rect(13, h * .5 - 2.25, 1.5, 6.5);
    c.fill();
    c.rect(15, h * .5 - 3.25, 1.5, 7.5);
    c.fill();
    c.begin();
    c.moveTo(w * .5 - 2, h * .5 - 1);
    c.arcTo(2, 3, 0, 0, 1, w * .5 + 2, h * .5 - 1);
    c.stroke();
    c.rect(w * .5 - 3, h * .5 - 1, 6, 4);
    c.fillAndStroke();
    c.begin();
    c.moveTo(w - 19, h * .5 - 2);
    c.lineTo(w - 10, h * .5 - 2);
    c.lineTo(w - 10, h * .5 + 2);
    c.lineTo(w - 19, h * .5 + 2);
    c.close();
    c.fill();
    c.begin();
    c.moveTo(w - 20, h * .5 - 3);
    c.lineTo(w - 5, h * .5 - 3);
    c.lineTo(w - 5, h * .5 - 1);
    c.lineTo(w - 3.5, h * .5 - 1);
    c.lineTo(w - 3.5, h * .5 + 1);
    c.lineTo(w - 5, h * .5 + 1);
    c.lineTo(w - 5, h * .5 + 3);
    c.lineTo(w - 20, h * .5 + 3);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_ITOP_BAR_LOCKED, mxShapeMockupiTopBarLocked);
function mxShapeMockupiButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiButton, mxShape);
mxShapeMockupiButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    var mainText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, "Main Text");
    var fontColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR2, "#666666").toString();
    var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "8.5").toString();
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.mainText(c, x, y, w, h, mainText, fontSize, fontColor)
}
;
mxShapeMockupiButton.prototype.background = function(c, x, y, w, h) {
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "").toString();
    var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, "").toString();
    c.setGradient(fillColor, fillColor2, 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.roundrect(0, 0, w, h, 2.5, 2.5);
    c.fill()
}
;
mxShapeMockupiButton.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor) {
    c.begin();
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    c.text(w / 2, h / 2, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IBUTTON, mxShapeMockupiButton);
function mxShapeMockupiButtonBack(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiButtonBack, mxShape);
mxShapeMockupiButtonBack.prototype.paintVertexShape = function(c, x, y, w, h) {
    var mainText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, "Main Text");
    var fontColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR2, "#666666").toString();
    var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "17").toString();
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.mainText(c, x, y, w, h, mainText, fontSize, fontColor)
}
;
mxShapeMockupiButtonBack.prototype.background = function(c, x, y, w, h) {
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "").toString();
    var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, "").toString();
    c.setGradient(fillColor, fillColor2, 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
    rSize = 2.5;
    c.begin();
    c.moveTo(w, rSize);
    c.arcTo(rSize, rSize, 0, 0, 0, w - rSize, 0);
    c.lineTo(10, 0);
    c.lineTo(.87, h * .5 - .75);
    c.arcTo(rSize, rSize, 0, 0, 0, .87, h * .5 + .75);
    c.lineTo(10, h);
    c.lineTo(w - rSize, h);
    c.arcTo(rSize, rSize, 0, 0, 0, w, h - rSize);
    c.close();
    c.fill()
}
;
mxShapeMockupiButtonBack.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor) {
    c.begin();
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    c.text(w * .5 + 2.5, h * .5, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IBUTTON_BACK, mxShapeMockupiButtonBack);
function mxShapeMockupiButtonForward(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiButtonForward, mxShape);
mxShapeMockupiButtonForward.prototype.paintVertexShape = function(c, x, y, w, h) {
    var mainText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, "Main Text");
    var fontColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR2, "#666666").toString();
    var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "17").toString();
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.mainText(c, x, y, w, h, mainText, fontSize, fontColor)
}
;
mxShapeMockupiButtonForward.prototype.background = function(c, x, y, w, h) {
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "").toString();
    var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, "").toString();
    c.setGradient(fillColor, fillColor2, 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
    rSize = 2.5;
    c.begin();
    c.moveTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.lineTo(w - 10, 0);
    c.lineTo(w - .87, h * .5 - .75);
    c.arcTo(rSize, rSize, 0, 0, 1, w - .87, h * .5 + .75);
    c.lineTo(w - 10, h);
    c.lineTo(rSize, h);
    c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
    c.close();
    c.fill()
}
;
mxShapeMockupiButtonForward.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor) {
    c.begin();
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    c.text(w * .5 - 2.5, h * .5, 0, 0, text, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IBUTTON_FORWARD, mxShapeMockupiButtonForward);
function mxShapeMockupiPrevNextButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiPrevNextButton, mxShape);
mxShapeMockupiPrevNextButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeMockupiPrevNextButton.prototype.background = function(c, x, y, w, h) {
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "").toString();
    var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, "").toString();
    c.setGradient(fillColor, fillColor2, 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
    var rSize = 5;
    c.roundrect(0, 0, w, h, rSize, rSize);
    c.fill();
    c.begin();
    c.moveTo(w * .5, 0);
    c.lineTo(w * .5, h);
    c.stroke()
}
;
mxShapeMockupiPrevNextButton.prototype.foreground = function(c, x, y, w, h) {
    var fillColor3 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR3, "").toString();
    c.setFillColor(fillColor3);
    c.begin();
    c.moveTo(w * .25, h * .25);
    c.lineTo(w * .35, h * .75);
    c.lineTo(w * .15, h * .75);
    c.close();
    c.fill();
    c.begin();
    c.moveTo(w * .75, h * .75);
    c.lineTo(w * .85, h * .25);
    c.lineTo(w * .65, h * .25);
    c.close();
    c.fill()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IPREV_NEXT, mxShapeMockupiPrevNextButton);
function mxShapeMockupiTextInput(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiTextInput, mxShape);
mxShapeMockupiTextInput.prototype.paintVertexShape = function(c, x, y, w, h) {
    var mainText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, "Main Text");
    var fontColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR2, "#000000").toString();
    var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "8").toString();
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.mainText(c, x, y, w, h, mainText, fontSize, fontColor)
}
;
mxShapeMockupiTextInput.prototype.background = function(c, x, y, w, h) {
    c.roundrect(0, 0, w, h, 2.5, 2.5);
    c.fillAndStroke()
}
;
mxShapeMockupiTextInput.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor) {
    c.begin();
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    c.text(2, h * .5, 0, 0, text, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_ITEXT_INPUT, mxShapeMockupiTextInput);
function mxShapeMockupiRadioGroup(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiRadioGroup, mxShape);
mxShapeMockupiRadioGroup.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var fontColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR2, "#666666").toString();
    var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "8").toString();
    var optionText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, "Option 1").toString().split(",");
    var optionNum = optionText.length;
    var buttonSize = 5;
    var lineH = Math.max(fontSize * 1.5, buttonSize);
    var maxTextWidth = 0;
    var selected = -1;
    var labelOffset = 2.5;
    var minH = optionNum * lineH;
    var trueH = Math.max(h, minH);
    for (var i = 0; i < optionNum; i++) {
        var currText = optionText[i];
        if (currText.charAt(0) === mxMockupC.SELECTED) {
            currText = optionText[i].substring(1);
            selected = i
        }
        var currWidth = mxUtils.getSizeForString(currText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
        if (currWidth > maxTextWidth)
            maxTextWidth = currWidth
    }
    var minW = 2 * labelOffset + maxTextWidth + 2 * buttonSize;
    var trueW = Math.max(w, minW);
    c.roundrect(0, 0, trueW, trueH, 2.5, 2.5);
    c.fillAndStroke();
    c.setShadow(false);
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    for (var i = 0; i < optionNum; i++) {
        var currHeight = (i * lineH + lineH * .5) * trueH / minH;
        var currText = optionText[i];
        if (currText.charAt(0) === mxMockupC.SELECTED) {
            currText = optionText[i].substring(1);
            selected = i
        }
        c.text(buttonSize * 2 + labelOffset, currHeight, 0, 0, currText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
        var iconX = buttonSize * .5;
        var iconY = currHeight - buttonSize * .5;
        c.setFillColor("#dddddd");
        c.setStrokeColor("#000000");
        if (selected === i) {
            c.setGradient("#aaaaaa", "#666666", iconX, iconY, buttonSize, buttonSize, mxConstants.DIRECTION_SOUTH, 1, 1);
            c.ellipse(iconX, iconY, buttonSize, buttonSize);
            c.fillAndStroke();
            c.setFillColor("#333333");
            c.setStrokeColor("#333333");
            c.ellipse(iconX + buttonSize * .25, iconY + buttonSize * .25, buttonSize * .5, buttonSize * .5);
            c.fillAndStroke()
        } else {
            c.setGradient("#eeeeee", "#cccccc", iconX, iconY, buttonSize, buttonSize, mxConstants.DIRECTION_SOUTH, 1, 1);
            c.ellipse(iconX, iconY, buttonSize, buttonSize);
            c.fillAndStroke()
        }
    }
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IRADIO_GROUP, mxShapeMockupiRadioGroup);
function mxShapeMockupiCheckboxGroup(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiCheckboxGroup, mxShape);
mxShapeMockupiCheckboxGroup.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var fontColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR2, "#666666").toString();
    var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "8").toString();
    var optionText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, "Option 1").toString().split(",");
    var optionNum = optionText.length;
    var buttonSize = 5;
    var lineH = Math.max(fontSize * 1.5, buttonSize);
    var maxTextWidth = 0;
    var selected = -1;
    var labelOffset = 2.5;
    var minH = optionNum * lineH;
    var trueH = Math.max(h, minH);
    for (var i = 0; i < optionNum; i++) {
        var currText = optionText[i];
        if (currText.charAt(0) === mxMockupC.SELECTED) {
            currText = optionText[i].substring(1);
            selected = i
        }
        var currWidth = mxUtils.getSizeForString(currText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
        if (currWidth > maxTextWidth)
            maxTextWidth = currWidth
    }
    var minW = 2 * labelOffset + maxTextWidth + 2 * buttonSize;
    var trueW = Math.max(w, minW);
    c.roundrect(0, 0, trueW, trueH, 2.5, 2.5);
    c.fillAndStroke();
    c.setShadow(false);
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    for (var i = 0; i < optionNum; i++) {
        var currHeight = (i * lineH + lineH * .5) * trueH / minH;
        var currText = optionText[i];
        if (currText.charAt(0) === mxMockupC.SELECTED) {
            currText = optionText[i].substring(1);
            selected = i
        }
        c.text(buttonSize * 2 + labelOffset, currHeight, 0, 0, currText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
        var iconX = buttonSize * .5;
        var iconY = currHeight - buttonSize * .5;
        c.setFillColor("#dddddd");
        c.setStrokeColor("#000000");
        if (selected === i) {
            c.setGradient("#aaaaaa", "#666666", iconX, iconY, buttonSize, buttonSize, mxConstants.DIRECTION_SOUTH, 1, 1);
            c.rect(iconX, iconY, buttonSize, buttonSize);
            c.fillAndStroke();
            c.setStrokeColor("#333333");
            c.begin();
            c.moveTo(iconX + buttonSize * .25, iconY + buttonSize * .5);
            c.lineTo(iconX + buttonSize * .5, iconY + buttonSize * .75);
            c.lineTo(iconX + buttonSize * .75, iconY + buttonSize * .25);
            c.stroke()
        } else {
            c.setGradient("#eeeeee", "#cccccc", iconX, iconY, buttonSize, buttonSize, mxConstants.DIRECTION_SOUTH, 1, 1);
            c.rect(iconX, iconY, buttonSize, buttonSize);
            c.fillAndStroke()
        }
        selected = -1
    }
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_ICHECKBOX_GROUP, mxShapeMockupiCheckboxGroup);
function mxShapeMockupiComboBox(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiComboBox, mxShape);
mxShapeMockupiComboBox.prototype.paintVertexShape = function(c, x, y, w, h) {
    var mainText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, "Main Text");
    var fontColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR2, "#666666").toString();
    var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "8.5").toString();
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h);
    this.mainText(c, x, y, w, h, mainText, fontSize, fontColor)
}
;
mxShapeMockupiComboBox.prototype.background = function(c, x, y, w, h) {
    c.setFillColor("#ffffff");
    c.roundrect(0, 0, w, h, 2.5, 2.5);
    c.fillAndStroke()
}
;
mxShapeMockupiComboBox.prototype.foreground = function(c, x, y, w, h) {
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "").toString();
    var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, "").toString();
    c.setGradient(fillColor, fillColor2, w - 30, 0, 30, h, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.begin();
    c.moveTo(w - 15, 0);
    c.lineTo(w - 2.5, 0);
    c.arcTo(2.5, 2.5, 0, 0, 1, w, 2.5);
    c.lineTo(w, h - 2.5);
    c.arcTo(2.5, 2.5, 0, 0, 1, w - 2.5, h);
    c.lineTo(w - 15, h);
    c.close();
    c.fillAndStroke();
    c.setFillColor("#ffffff");
    c.begin();
    c.moveTo(w - 11, 5);
    c.lineTo(w - 7.5, 10);
    c.lineTo(w - 4, 5);
    c.fill()
}
;
mxShapeMockupiComboBox.prototype.mainText = function(c, x, y, w, h, text, fontSize, fontColor) {
    c.begin();
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    c.text(2.5, h * .5, 0, 0, text, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_ICOMBO_BOX, mxShapeMockupiComboBox);
function mxShapeMockupiOnOffButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiOnOffButton, mxShape);
mxShapeMockupiOnOffButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    w = Math.max(w, 2 * h);
    var state = mxUtils.getValue(this.style, mxMockupC.BUTTON_STATE, mxMockupC.STATE_ON);
    this.background(c, x, y, w, h, state);
    c.setShadow(false);
    this.foreground(c, x, y, w, h, state);
    this.mainText(c, x, y, w, h, state)
}
;
mxShapeMockupiOnOffButton.prototype.background = function(c, x, y, w, h, state) {
    if (state === mxMockupC.STATE_ON) {
        c.setGradient("#E2FFEB", "#008215", 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
        c.roundrect(0, 0, w, h, h * .5, h * .5);
        c.fillAndStroke()
    } else if (state === mxMockupC.STATE_OFF) {
        c.setGradient("#cc9999", "#881100", 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
        c.roundrect(0, 0, w, h, h * .5, h * .5);
        c.fillAndStroke()
    }
}
;
mxShapeMockupiOnOffButton.prototype.foreground = function(c, x, y, w, h, state) {
    if (state === mxMockupC.STATE_ON) {
        c.setGradient("#ffffff", "#888888", w - h, 0, h, h, mxConstants.DIRECTION_SOUTH, 1, 1);
        c.ellipse(w - h, 0, h, h);
        c.fillAndStroke()
    } else {
        c.setGradient("#ffffff", "#888888", 0, 0, h, h, mxConstants.DIRECTION_SOUTH, 1, 1);
        c.ellipse(0, 0, h, h);
        c.fillAndStroke()
    }
}
;
mxShapeMockupiOnOffButton.prototype.mainText = function(c, x, y, w, h, state) {
    var mainText = mxUtils.getValue(this.style, "mainText", null);
    c.setFontColor("#ffffff");
    c.setFontSize(8.5);
    if (mainText != "")
        if (state === mxMockupC.STATE_ON)
            c.text(w * .5 - h * .4, h * .5, 0, 0, mainText || "ON", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
        else if (state === mxMockupC.STATE_OFF)
            c.text(w * .5 + h * .4, h * .5, 0, 0, mainText || "OFF", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_ION_OFF_BUTTON, mxShapeMockupiOnOffButton);
function mxShapeMockupiAlertBox(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiAlertBox, mxShape);
mxShapeMockupiAlertBox.prototype.paintVertexShape = function(c, x, y, w, h) {
    w = Math.max(w, 15);
    h = Math.max(h, 15);
    c.translate(x, y);
    rSize = 7.5;
    this.background(c, x, y, w, h, rSize);
    c.setShadow(false);
    this.foreground(c, x, y, w, h, rSize)
}
;
mxShapeMockupiAlertBox.prototype.background = function(c, x, y, w, h, rSize) {
    c.setGradient("#497198", "#193168", 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.setAlpha(.8);
    c.setStrokeWidth(1);
    c.roundrect(0, 0, w, h, rSize, rSize);
    c.fillAndStroke()
}
;
mxShapeMockupiAlertBox.prototype.foreground = function(c, x, y, w, h, rSize) {
    var mainText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, "Main Text").toString().split(",");
    c.setStrokeColor("#497198");
    c.setGradient("#497198", "#c5cee1", 0, 0, w, 22.5, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.setAlpha(.5);
    c.begin();
    c.moveTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, 17.5);
    c.arcTo(w * 1.67, h * 2.5, 0, 0, 1, 0, 17.5);
    c.lineTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.close();
    c.fillAndStroke();
    c.setAlpha(.8);
    c.setStrokeColor("#ffffff");
    c.setStrokeWidth(1);
    c.roundrect(0, 0, w, h, rSize, rSize);
    c.stroke();
    c.setGradient("#497198", "#c5cee1", 5, h - 50, w - 20, 20, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.roundrect(5, h - 25, w - 10, 20, 2.5, 2.5);
    c.fillAndStroke();
    c.setAlpha(.9);
    c.setFontSize(9.5);
    c.setFontColor("#ffffff");
    c.text(w * .5, h * .15, 0, 0, mainText[0], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setFontSize(8);
    c.text(w * .5, h * .4, 0, 0, mainText[2], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .55, 0, 0, mainText[3], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setFontSize(8.5);
    c.text(w * .5, h - 15, 0, 0, mainText[1], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IALERT_BOX, mxShapeMockupiAlertBox);
function mxShapeMockupiDialogBox(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiDialogBox, mxShape);
mxShapeMockupiDialogBox.prototype.paintVertexShape = function(c, x, y, w, h) {
    w = Math.max(w, 15);
    h = Math.max(h, 15);
    c.translate(x, y);
    rSize = 7.5;
    this.background(c, x, y, w, h, rSize);
    c.setShadow(false);
    this.foreground(c, x, y, w, h, rSize)
}
;
mxShapeMockupiDialogBox.prototype.background = function(c, x, y, w, h, rSize) {
    c.setGradient("#497198", "#193168", 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.setAlpha(.8);
    c.setStrokeWidth(1);
    c.roundrect(0, 0, w, h, rSize, rSize);
    c.fillAndStroke()
}
;
mxShapeMockupiDialogBox.prototype.foreground = function(c, x, y, w, h, rSize) {
    var mainText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, "Main Text").toString().split(",");
    c.setStrokeColor("#497198");
    c.setGradient("#497198", "#c5cee1", 0, 0, w, 22.5, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.setAlpha(.5);
    c.begin();
    c.moveTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, 17.5);
    c.arcTo(w * 1.67, h * 2.5, 0, 0, 1, 0, 17.5);
    c.lineTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.close();
    c.fillAndStroke();
    c.setAlpha(.8);
    c.setStrokeColor("#ffffff");
    c.setStrokeWidth(1);
    c.roundrect(0, 0, w, h, rSize, rSize);
    c.stroke();
    c.setGradient("#497198", "#c5cee1", 5, h - 25, w * .5 - 10, 20, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.roundrect(5, h - 25, w * .5 - 10, 20, 2.5, 2.5);
    c.fillAndStroke();
    c.roundrect(w * .5 + 2.5, h - 25, w * .5 - 10, 20, 2.5, 2.5);
    c.fillAndStroke();
    c.setAlpha(.9);
    c.setFontSize(9.5);
    c.setFontColor("#ffffff");
    c.text(w * .5, h * .15, 0, 0, mainText[0], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setFontSize(8);
    c.text(w * .5, h * .4, 0, 0, mainText[3], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .55, 0, 0, mainText[4], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setFontSize(8.5);
    c.text(w * .25, h - 15, 0, 0, mainText[1], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .75, h - 15, 0, 0, mainText[2], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IDIALOG_BOX, mxShapeMockupiDialogBox);
function mxShapeMockupiLockButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiLockButton, mxShape);
mxShapeMockupiLockButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.setShadow(false);
    c.setAlpha(.7);
    c.setGradient("#4A4F56", "#70757B", 0, 0, w, h, mxConstants.DIRECTION_NORTH, 1, 1);
    c.rect(0, 0, w, h);
    c.fill();
    c.setAlpha(.8);
    c.setGradient("#18232D", "#1F2933", 10, 10, 154, 30, mxConstants.DIRECTION_NORTH, 1, 1);
    c.roundrect(10, h * .5 - 15, w - 20, 30, 7.5, 7.5);
    c.fill();
    c.setAlpha(1);
    c.setGradient("#E9F3FD", "#ADB7C1", 12.5, 12.5, 40, 25, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.roundrect(12.5, h * .5 - 12.5, 40, 25, 5, 5);
    c.fill();
    c.setAlpha(.8);
    c.setStrokeWidth(.5);
    c.setStrokeColor("#aabbbb");
    c.setGradient("#AEB7C1", "#667079", 20, 17.5, 25, 15, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.begin();
    c.moveTo(20, h * .5 - 3.5);
    c.lineTo(35, h * .5 - 3.5);
    c.lineTo(35, h * .5 - 7.5);
    c.lineTo(45, h * .5);
    c.lineTo(35, h * .5 + 7.5);
    c.lineTo(35, h * .5 + 3.5);
    c.lineTo(20, h * .5 + 3.5);
    c.close();
    c.fillAndStroke();
    var mainText = mxUtils.getValue(this.style, "mainText", null);
    if (mainText != "") {
        c.setFontSize(12.5);
        c.setFontColor("#cccccc");
        c.text(w / 2 + 20.5, h / 2, 0, 0, "slide to unlock", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
    }
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_ILOCK_BUTTON, mxShapeMockupiLockButton);
function mxShapeMockupiArrowIcon(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiArrowIcon, mxShape);
mxShapeMockupiArrowIcon.prototype.paintVertexShape = function(c, x, y, w, h) {
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "").toString();
    c.translate(x, y);
    this.background(c, x, y, w, h, strokeColor);
    c.setShadow(false);
    this.foreground(c, x, y, w, h, strokeColor)
}
;
mxShapeMockupiArrowIcon.prototype.background = function(c, x, y, w, h, strokeColor) {
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "").toString();
    var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, "").toString();
    c.setGradient(fillColor, fillColor2, 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.setStrokeWidth(1.5);
    c.setStrokeColor(strokeColor);
    c.ellipse(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupiArrowIcon.prototype.foreground = function(c, x, y, w, h, strokeColor) {
    c.setStrokeWidth(2.5);
    c.begin();
    c.moveTo(w * .4, h * .22);
    c.lineTo(w * .65, h * .5);
    c.lineTo(w * .4, h * .78);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IARROW_ICON, mxShapeMockupiArrowIcon);
function mxShapeMockupiDeleteIcon(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiDeleteIcon, mxShape);
mxShapeMockupiDeleteIcon.prototype.paintVertexShape = function(c, x, y, w, h) {
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "").toString();
    c.translate(x, y);
    this.background(c, x, y, w, h, strokeColor);
    c.setShadow(false);
    this.foreground(c, x, y, w, h, strokeColor)
}
;
mxShapeMockupiDeleteIcon.prototype.background = function(c, x, y, w, h, strokeColor) {
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "").toString();
    var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, "").toString();
    c.setGradient(fillColor, fillColor2, 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.setStrokeWidth(1.5);
    c.setStrokeColor(strokeColor);
    c.ellipse(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupiDeleteIcon.prototype.foreground = function(c, x, y, w, h, strokeColor) {
    c.setStrokeWidth(2.5);
    c.begin();
    c.moveTo(w * .25, h * .5);
    c.lineTo(w * .75, h * .5);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IDELETE_ICON, mxShapeMockupiDeleteIcon);
function mxShapeMockupiAddIcon(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiAddIcon, mxShape);
mxShapeMockupiAddIcon.prototype.paintVertexShape = function(c, x, y, w, h) {
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "").toString();
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "").toString();
    var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, "").toString();
    c.setGradient(fillColor, fillColor2, 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.setStrokeColor(strokeColor);
    c.translate(x, y);
    this.background(c, x, y, w, h, strokeColor);
    c.setShadow(false);
    this.foreground(c, x, y, w, h, strokeColor)
}
;
mxShapeMockupiAddIcon.prototype.background = function(c, x, y, w, h, strokeColor) {
    c.setStrokeWidth(1.5);
    c.ellipse(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupiAddIcon.prototype.foreground = function(c, x, y, w, h, strokeColor) {
    c.setStrokeWidth(2.5);
    c.begin();
    c.moveTo(w * .25, h * .5);
    c.lineTo(w * .75, h * .5);
    c.moveTo(w * .5, h * .25);
    c.lineTo(w * .5, h * .75);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IADD_ICON, mxShapeMockupiAddIcon);
function mxShapeMockupiInfoIcon(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiInfoIcon, mxShape);
mxShapeMockupiInfoIcon.prototype.paintVertexShape = function(c, x, y, w, h) {
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "").toString();
    c.translate(x, y);
    this.background(c, x, y, w, h, strokeColor);
    c.setShadow(false);
    this.foreground(c, x, y, w, h, strokeColor)
}
;
mxShapeMockupiInfoIcon.prototype.background = function(c, x, y, w, h, strokeColor) {
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "").toString();
    var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, "").toString();
    c.setGradient(fillColor, fillColor2, 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.setStrokeWidth(1.5);
    c.setStrokeColor(strokeColor);
    c.ellipse(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupiInfoIcon.prototype.foreground = function(c, x, y, w, h, strokeColor) {
    c.setStrokeWidth(2.5);
    c.begin();
    c.setFillColor("#ffffff");
    c.moveTo(w * .47, h * .334);
    c.arcTo(w * .1, h * .15, 60, 0, 1, w * .61, h * .42);
    c.lineTo(w * .51, h * .7);
    c.arcTo(w * .026, h * .03, 30, 0, 0, w * .54, h * .74);
    c.lineTo(w * .608, h * .684);
    c.arcTo(w * .02, h * .015, 0, 0, 1, w * .638, h * .706);
    c.arcTo(w * .45, h * .45, 0, 0, 1, w * .42, h * .865);
    c.arcTo(w * .1, h * .08, -15, 0, 1, w * .325, h * .77);
    c.lineTo(w * .358, h * .66);
    c.lineTo(w * .435, h * .46);
    c.arcTo(w * .023, h * .03, 0, 0, 0, w * .4, h * .43);
    c.lineTo(w * .338, h * .484);
    c.arcTo(w * .01, h * .015, 45, 0, 1, w * .31, h * .47);
    c.arcTo(w * .3, h * .3, 0, 0, 1, w * .47, h * .334);
    c.fill();
    c.begin();
    c.moveTo(w * .5438, h * .141);
    c.arcTo(w * .0776, h * .0898, 40, 0, 1, w * .6671, h * .2308);
    c.arcTo(w * .0776, h * .0898, 40, 0, 1, w * .5438, h * .141);
    c.close();
    c.fill()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IINFO_ICON, mxShapeMockupiInfoIcon);
function mxShapeMockupiSortFindIcon(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiSortFindIcon, mxShape);
mxShapeMockupiSortFindIcon.prototype.paintVertexShape = function(c, x, y, w, h) {
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "").toString();
    c.translate(x, y);
    this.background(c, x, y, w, h, strokeColor);
    c.setShadow(false);
    this.foreground(c, x, y, w, h, strokeColor)
}
;
mxShapeMockupiSortFindIcon.prototype.background = function(c, x, y, w, h, strokeColor) {
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "").toString();
    var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, "").toString();
    c.setGradient(fillColor, fillColor2, 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.setStrokeWidth(1.5);
    c.setStrokeColor(strokeColor);
    c.roundrect(0, 0, w, h, w * .1, h * .1);
    c.fillAndStroke()
}
;
mxShapeMockupiSortFindIcon.prototype.foreground = function(c, x, y, w, h, strokeColor) {
    c.setStrokeWidth(Math.min(h, w) / 20);
    c.begin();
    c.setFillColor("#ffffff");
    c.moveTo(w * .1, h * .25);
    c.lineTo(w * .9, h * .25);
    c.moveTo(w * .1, h * .4);
    c.lineTo(w * .9, h * .4);
    c.moveTo(w * .1, h * .55);
    c.lineTo(w * .6, h * .55);
    c.moveTo(w * .1, h * .7);
    c.lineTo(w * .5, h * .7);
    c.stroke();
    c.begin();
    c.ellipse(w * .6, h * .6, w * .2, h * .2);
    c.stroke();
    c.begin();
    c.moveTo(w * .77, h * .77);
    c.lineTo(w * .85, h * .85);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_ISORT_FIND_ICON, mxShapeMockupiSortFindIcon);
function mxShapeMockupiCheckIcon(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiCheckIcon, mxShape);
mxShapeMockupiCheckIcon.prototype.paintVertexShape = function(c, x, y, w, h) {
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "").toString();
    c.translate(x, y);
    this.background(c, x, y, w, h, strokeColor);
    c.setShadow(false);
    this.foreground(c, x, y, w, h, strokeColor)
}
;
mxShapeMockupiCheckIcon.prototype.background = function(c, x, y, w, h, strokeColor) {
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "").toString();
    var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, "").toString();
    c.setGradient(fillColor, fillColor2, 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.setStrokeWidth(1.5);
    c.setStrokeColor(strokeColor);
    c.ellipse(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupiCheckIcon.prototype.foreground = function(c, x, y, w, h, strokeColor) {
    c.setStrokeWidth(2.5);
    c.begin();
    c.moveTo(w * .25, h * .5);
    c.lineTo(w * .5, h * .65);
    c.lineTo(w * .75, h * .25);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_ICHECK_ICON, mxShapeMockupiCheckIcon);
function mxShapeMockupiKeybLetters(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiKeybLetters, mxShape);
mxShapeMockupiKeybLetters.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(true);
    this.foreground(c, x, y, w, h)
}
;
mxShapeMockupiKeybLetters.prototype.background = function(c, x, y, w, h) {
    c.setGradient("#8A97A7", "#425163", 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.rect(0, 0, w, h);
    c.fill()
}
;
mxShapeMockupiKeybLetters.prototype.foreground = function(c, x, y, w, h, strokeColor) {
    c.setGradient("#EEF3F9", "#DBE2E9", w * .0086, h * .03, w * .0776, h * .19, mxConstants.DIRECTION_SOUTH, 1, 1);
    rSizeX = w * .0144;
    rSizeY = h * .025;
    c.setFontSize(10.5);
    c.setFontColor("#000000");
    c.roundrect(w * .0086, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .0474, h * .125, 0, 0, "Q", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .1092, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .148, h * .125, 0, 0, "W", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .2098, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .2486, h * .125, 0, 0, "E", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .3103, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .3491, h * .125, 0, 0, "R", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .4109, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .4497, h * .125, 0, 0, "T", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .5115, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .5503, h * .125, 0, 0, "Y", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .6121, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .6509, h * .125, 0, 0, "U", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .7126, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .7514, h * .125, 0, 0, "I", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .8132, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .852, h * .125, 0, 0, "O", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .9138, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .9526, h * .125, 0, 0, "P", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .0632, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .102, h * .375, 0, 0, "A", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .1638, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .2026, h * .375, 0, 0, "S", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .2644, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .3032, h * .375, 0, 0, "D", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .3649, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .4037, h * .375, 0, 0, "F", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .4655, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .5043, h * .375, 0, 0, "G", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .5661, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .6049, h * .375, 0, 0, "H", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .6667, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .7055, h * .375, 0, 0, "J", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .7672, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .806, h * .375, 0, 0, "K", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .8678, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .9066, h * .375, 0, 0, "L", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .1638, h * .53, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .2026, h * .625, 0, 0, "Z", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .2644, h * .53, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .3032, h * .625, 0, 0, "X", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .3649, h * .53, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .4037, h * .625, 0, 0, "C", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .4655, h * .53, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .5043, h * .625, 0, 0, "V", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .5661, h * .53, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .6049, h * .625, 0, 0, "B", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .6667, h * .53, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .7055, h * .625, 0, 0, "N", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .7672, h * .53, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .806, h * .625, 0, 0, "M", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .2644, h * .78, w * .4799, h * .19, rSizeX, rSizeY);
    c.fill();
    c.setFontColor("#666666");
    c.text(w * .5043, h * .875, 0, 0, "space", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setFontColor("#ffffff");
    c.setGradient("#8B98A8", "#677488", w * .0115, h * .53, w * .1207, h * .19, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.roundrect(w * .0115, h * .53, w * .1207, h * .19, rSizeX, rSizeY);
    c.fill();
    c.setGradient("#8B98A8", "#677488", w * .8736, h * .53, w * .115, h * .19, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.roundrect(w * .8736, h * .53, w * .115, h * .19, rSizeX, rSizeY);
    c.fill();
    c.setGradient("#8B98A8", "#677488", w * .0115, h * .78, w * .2299, h * .19, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.roundrect(w * .0115, h * .78, w * .2299, h * .19, rSizeX, rSizeY);
    c.fill();
    c.setGradient("#8B98A8", "#677488", w * .7672, h * .78, w * .2213, h * .19, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.roundrect(w * .7672, h * .78, w * .2213, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .1264, h * .875, 0, 0, ".?123", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .8779, h * .875, 0, 0, "return", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setShadow(false);
    c.setLineJoin("round");
    c.setStrokeColor("#ffffff");
    c.setFillColor("#ffffff");
    c.setStrokeWidth(1.5);
    c.begin();
    c.moveTo(w * .0402, h * .635);
    c.lineTo(w * .0718, h * .58);
    c.lineTo(w * .1034, h * .635);
    c.lineTo(w * .0862, h * .635);
    c.lineTo(w * .0862, h * .67);
    c.lineTo(w * .0575, h * .67);
    c.lineTo(w * .0575, h * .635);
    c.close();
    c.stroke();
    c.begin();
    c.moveTo(w * .9109, h * .585);
    c.lineTo(w * .9655, h * .585);
    c.lineTo(w * .9655, h * .665);
    c.lineTo(w * .9109, h * .665);
    c.lineTo(w * .8879, h * .625);
    c.close();
    c.fillAndStroke();
    c.setStrokeColor("#677488");
    c.begin();
    c.moveTo(w * .9224, h * .605);
    c.lineTo(w * .9454, h * .645);
    c.moveTo(w * .9224, h * .645);
    c.lineTo(w * .9454, h * .605);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IKEYB_LETTERS, mxShapeMockupiKeybLetters);
function mxShapeMockupiKeybNumbers(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiKeybNumbers, mxShape);
mxShapeMockupiKeybNumbers.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(true);
    this.foreground(c, x, y, w, h)
}
;
mxShapeMockupiKeybNumbers.prototype.background = function(c, x, y, w, h) {
    c.setGradient("#8A97A7", "#425163", 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.rect(0, 0, w, h);
    c.fill()
}
;
mxShapeMockupiKeybNumbers.prototype.foreground = function(c, x, y, w, h, strokeColor) {
    c.setGradient("#EEF3F9", "#DBE2E9", w * .0086, h * .03, w * .0776, h * .19, mxConstants.DIRECTION_SOUTH, 1, 1);
    rSizeX = w * .0144;
    rSizeY = h * .025;
    c.setFontSize(10.5);
    c.setFontColor("#000000");
    c.roundrect(w * .0086, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .0474, h * .125, 0, 0, "1", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .1092, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .148, h * .125, 0, 0, "2", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .2098, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .2486, h * .125, 0, 0, "3", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .3103, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .3491, h * .125, 0, 0, "4", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .4109, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .4497, h * .125, 0, 0, "5", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .5115, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .5503, h * .125, 0, 0, "6", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .6121, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .6509, h * .125, 0, 0, "7", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .7126, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .7514, h * .125, 0, 0, "8", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .8132, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .852, h * .125, 0, 0, "9", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .9138, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .9526, h * .125, 0, 0, "0", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .0086, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .0474, h * .375, 0, 0, "-", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .1092, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .148, h * .375, 0, 0, "/", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .2098, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .2486, h * .375, 0, 0, ":", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .3103, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .3491, h * .375, 0, 0, ";", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .4109, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .4497, h * .375, 0, 0, "(", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .5115, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .5503, h * .375, 0, 0, ")", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .6121, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .6509, h * .375, 0, 0, "$", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .7126, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .7514, h * .375, 0, 0, "&", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .8132, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .852, h * .375, 0, 0, "@", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .9138, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .9526, h * .375, 0, 0, '"', mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .1638, h * .53, w * .1178, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .2227, h * .625, 0, 0, ".", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .3046, h * .53, w * .1178, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .3635, h * .625, 0, 0, ",", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .4454, h * .53, w * .1178, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .5043, h * .625, 0, 0, "?", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .5862, h * .53, w * .1178, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .6451, h * .625, 0, 0, "!", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .727, h * .53, w * .1178, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .7859, h * .625, 0, 0, "'", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .2644, h * .78, w * .4799, h * .19, rSizeX, rSizeY);
    c.fill();
    c.setFontColor("#666666");
    c.text(w * .5043, h * .875, 0, 0, "space", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setGradient("#8B98A8", "#677488", w * .0115, h * .53, w * .1207, h * .19, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.setFontColor("#ffffff");
    c.roundrect(w * .0115, h * .53, w * .1207, h * .19, rSizeX, rSizeY);
    c.fill();
    c.roundrect(w * .8736, h * .53, w * .115, h * .19, rSizeX, rSizeY);
    c.fill();
    c.roundrect(w * .0115, h * .78, w * .2299, h * .19, rSizeX, rSizeY);
    c.fill();
    c.roundrect(w * .7672, h * .78, w * .2213, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .0718, h * .625, 0, 0, "#+=", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .1264, h * .875, 0, 0, "ABC", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .8779, h * .875, 0, 0, "return", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setShadow(false);
    c.setLineJoin("round");
    c.setStrokeColor("#ffffff");
    c.setFillColor("#ffffff");
    c.setStrokeWidth(1.5);
    c.begin();
    c.moveTo(w * .9109, h * .585);
    c.lineTo(w * .9655, h * .585);
    c.lineTo(w * .9655, h * .665);
    c.lineTo(w * .9109, h * .665);
    c.lineTo(w * .8879, h * .625);
    c.close();
    c.fillAndStroke();
    c.setStrokeColor("#677488");
    c.begin();
    c.moveTo(w * .9224, h * .605);
    c.lineTo(w * .9454, h * .645);
    c.moveTo(w * .9224, h * .645);
    c.lineTo(w * .9454, h * .605);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IKEYB_NUMBERS, mxShapeMockupiKeybNumbers);
function mxShapeMockupiKeybSymbols(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiKeybSymbols, mxShape);
mxShapeMockupiKeybSymbols.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(true);
    this.foreground(c, x, y, w, h)
}
;
mxShapeMockupiKeybSymbols.prototype.background = function(c, x, y, w, h) {
    c.setGradient("#8A97A7", "#425163", 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.rect(0, 0, w, h);
    c.fill()
}
;
mxShapeMockupiKeybSymbols.prototype.foreground = function(c, x, y, w, h, strokeColor) {
    c.setGradient("#EEF3F9", "#DBE2E9", w * .0086, h * .03, w * .0776, h * .19, mxConstants.DIRECTION_SOUTH, 1, 1);
    rSizeX = w * .0144;
    rSizeY = h * .025;
    c.setFontSize(10.5);
    c.setFontColor("#000000");
    c.roundrect(w * .0086, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .0474, h * .125, 0, 0, "[", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .1092, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .148, h * .125, 0, 0, "]", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .2098, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .2486, h * .125, 0, 0, "{", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .3103, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .3491, h * .125, 0, 0, "}", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .4109, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .4497, h * .125, 0, 0, "#", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .5115, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .5503, h * .125, 0, 0, "%", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .6121, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .6509, h * .125, 0, 0, "^", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .7126, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .7514, h * .125, 0, 0, "*", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .8132, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .852, h * .125, 0, 0, "+", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .9138, h * .03, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .9526, h * .125, 0, 0, "=", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .0086, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .0474, h * .375, 0, 0, "_", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .1092, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .148, h * .375, 0, 0, "\\", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .2098, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .2486, h * .375, 0, 0, "|", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .3103, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .3491, h * .375, 0, 0, "~", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .4109, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .4497, h * .375, 0, 0, "<", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .5115, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .5503, h * .375, 0, 0, ">", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .6121, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .6509, h * .375, 0, 0, String.fromCharCode(128), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .7126, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .7514, h * .375, 0, 0, String.fromCharCode(parseInt("00A3", 16)), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .8132, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .852, h * .375, 0, 0, String.fromCharCode(parseInt("00A5", 16)), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .9138, h * .28, w * .0776, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .9526, h * .375, 0, 0, String.fromCharCode(parseInt("0095", 16)), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .1638, h * .53, w * .1178, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .2227, h * .625, 0, 0, ".", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .3046, h * .53, w * .1178, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .3635, h * .625, 0, 0, ",", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .4454, h * .53, w * .1178, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .5043, h * .625, 0, 0, "?", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .5862, h * .53, w * .1178, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .6451, h * .625, 0, 0, "!", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .727, h * .53, w * .1178, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .7859, h * .625, 0, 0, "'", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.roundrect(w * .2644, h * .78, w * .4799, h * .19, rSizeX, rSizeY);
    c.fill();
    c.setFontColor("#666666");
    c.text(w * .5043, h * .875, 0, 0, "space", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setGradient("#8B98A8", "#677488", w * .0115, h * .53, w * .1207, h * .19, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.setFontColor("#ffffff");
    c.roundrect(w * .0115, h * .53, w * .1207, h * .19, rSizeX, rSizeY);
    c.fill();
    c.roundrect(w * .8736, h * .53, w * .115, h * .19, rSizeX, rSizeY);
    c.fill();
    c.roundrect(w * .0115, h * .78, w * .2299, h * .19, rSizeX, rSizeY);
    c.fill();
    c.roundrect(w * .7672, h * .78, w * .2213, h * .19, rSizeX, rSizeY);
    c.fill();
    c.text(w * .0718, h * .625, 0, 0, "123", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .1264, h * .875, 0, 0, "ABC", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .8779, h * .875, 0, 0, "return", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setShadow(false);
    c.setLineJoin("round");
    c.setStrokeColor("#ffffff");
    c.setFillColor("#ffffff");
    c.setStrokeWidth(1.5);
    c.begin();
    c.moveTo(w * .9109, h * .585);
    c.lineTo(w * .9655, h * .585);
    c.lineTo(w * .9655, h * .665);
    c.lineTo(w * .9109, h * .665);
    c.lineTo(w * .8879, h * .625);
    c.close();
    c.fillAndStroke();
    c.setStrokeColor("#677488");
    c.begin();
    c.moveTo(w * .9224, h * .605);
    c.lineTo(w * .9454, h * .645);
    c.moveTo(w * .9224, h * .645);
    c.lineTo(w * .9454, h * .605);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IKEYB_SYMBOLS, mxShapeMockupiKeybSymbols);
function mxShapeMockupiDeleteApp(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiDeleteApp, mxShape);
mxShapeMockupiDeleteApp.prototype.paintVertexShape = function(c, x, y, w, h) {
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "").toString();
    c.translate(x, y);
    this.background(c, x, y, w, h, strokeColor);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeMockupiDeleteApp.prototype.background = function(c, x, y, w, h, strokeColor) {
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "").toString();
    var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, "").toString();
    c.setGradient(fillColor, fillColor2, 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.setStrokeWidth(1.5);
    c.setStrokeColor(strokeColor);
    c.ellipse(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupiDeleteApp.prototype.foreground = function(c, x, y, w, h) {
    c.setStrokeWidth(2.5);
    c.begin();
    c.moveTo(w * .3, h * .3);
    c.lineTo(w * .7, h * .7);
    c.moveTo(w * .3, h * .7);
    c.lineTo(w * .7, h * .3);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IDELETE_APP, mxShapeMockupiDeleteApp);
function mxShapeMockupiDirection(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiDirection, mxShape);
mxShapeMockupiDirection.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeMockupiDirection.prototype.background = function(c, x, y, w, h) {
    c.setStrokeWidth(.5);
    c.setStrokeColor("#008cff");
    c.ellipse(0, 0, w, h);
    c.stroke()
}
;
mxShapeMockupiDirection.prototype.foreground = function(c, x, y, w, h) {
    c.setAlpha(1);
    c.setGradient("#ffffff", "#ffffff", w * .29, h * .2, w * .42, h * .3, mxConstants.DIRECTION_NORTH, 1, 0);
    c.begin();
    c.moveTo(w * .29, h * .2);
    c.lineTo(w * .5, h * .5);
    c.lineTo(w * .71, h * .2);
    c.fillAndStroke();
    c.setStrokeColor("#006cdf");
    c.setGradient("#ffffff", "#007cef", w * .47, h * .47, w * .06, h * .06, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.setAlpha(1);
    c.ellipse(w * .47, h * .47, w * .06, h * .06);
    c.fillAndStroke();
    c.setFillColor("#ffffff");
    c.setAlpha(.8);
    c.ellipse(w * .4825, h * .4825, w * .015, h * .015);
    c.fill()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IDIRECTION, mxShapeMockupiDirection);
function mxShapeMockupiLocationBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiLocationBar, mxShape);
mxShapeMockupiLocationBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeMockupiLocationBar.prototype.background = function(c, x, y, w, h) {
    var barPos = mxUtils.getValue(this.style, mxMockupC.BAR_POS, "80");
    barPos = Math.min(barPos, 100);
    barPos = Math.max(barPos, 0);
    var pointerPos = mxUtils.getValue(this.style, mxMockupC.POINTER_POS, mxMockupC.POINTER_BOTTOM);
    var rSize = 2.5;
    var deadzone = rSize + 7.5;
    var virRange = w - 2 * deadzone;
    var truePos = deadzone + virRange * barPos / 100;
    c.setStrokeWidth(.5);
    c.setStrokeColor("#000000");
    c.setAlpha(.7);
    c.begin();
    if (pointerPos === mxMockupC.POINTER_BOTTOM) {
        c.setGradient("#000000", "#888888", 0, 0, w, h, mxConstants.DIRECTION_NORTH, 1, 1);
        c.moveTo(0, rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
        c.lineTo(w - rSize, 0);
        c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
        c.lineTo(w, h - rSize - 7.5);
        c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h - 7.5);
        c.lineTo(truePos + 7.5, h - 7.5);
        c.lineTo(truePos, h);
        c.lineTo(truePos - 7.5, h - 7.5);
        c.lineTo(rSize, h - 7.5);
        c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize - 7.5)
    } else if (pointerPos === mxMockupC.POINTER_TOP) {
        c.setGradient("#000000", "#888888", 0, 0, w, h, mxConstants.DIRECTION_NORTH, 1, 1);
        c.moveTo(0, rSize + 7.5);
        c.arcTo(rSize, rSize, 0, 0, 1, rSize, 7.5);
        c.lineTo(truePos - 7.5, 7.5);
        c.lineTo(truePos, 0);
        c.lineTo(truePos + 7.5, 7.5);
        c.lineTo(w - rSize, 7.5);
        c.arcTo(rSize, rSize, 0, 0, 1, w, rSize + 7.5);
        c.lineTo(w, h - rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
        c.lineTo(rSize, h);
        c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize)
    }
    c.close();
    c.fillAndStroke()
}
;
mxShapeMockupiLocationBar.prototype.foreground = function(c, x, y, w, h) {
    var pointerPos = mxUtils.getValue(this.style, mxMockupC.POINTER_POS, mxMockupC.POINTER_BOTTOM);
    var locText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, "Some Location");
    c.setAlpha(1);
    c.setFontColor("#ffffff");
    c.setFontSize(9.5);
    if (pointerPos === mxMockupC.POINTER_BOTTOM) {
        c.text(5, (h - 7.5) * .5, 0, 0, locText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
        c.translate(w - 20, (h - 7.5) * .5 - 7.5)
    } else {
        c.text(5, (h + 7.5) * .5, 0, 0, locText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
        c.translate(w - 20, (h + 7.5) * .5 - 7.5)
    }
    w = 15;
    h = 15;
    c.setGradient("#8BbEff", "#135Ec8", 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.setStrokeWidth(1.5);
    c.setStrokeColor("#ffffff");
    c.ellipse(0, 0, w, h);
    c.fillAndStroke();
    c.setStrokeWidth(2.5);
    c.begin();
    c.moveTo(w * .4, h * .22);
    c.lineTo(w * .65, h * .5);
    c.lineTo(w * .4, h * .78);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_ILOCATION_BAR, mxShapeMockupiLocationBar);
function mxShapeMockupiCallDialog(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiCallDialog, mxShape);
mxShapeMockupiCallDialog.prototype.paintVertexShape = function(c, x, y, w, h) {
    var rSize = 5;
    c.translate(x, y);
    this.background(c, x, y, w, h, rSize);
    c.setShadow(false);
    this.foreground(c, x, y, w, h, rSize)
}
;
mxShapeMockupiCallDialog.prototype.background = function(c, x, y, w, h, rSize) {
    c.setAlpha(.8);
    c.setStrokeColor("#888888");
    c.setStrokeWidth(1.5);
    c.setFillColor("#000000");
    c.roundrect(0, 0, w, h, rSize, rSize);
    c.fillAndStroke()
}
;
mxShapeMockupiCallDialog.prototype.foreground = function(c, x, y, w, h, rSize) {
    c.begin();
    c.moveTo(w * .33, 0);
    c.lineTo(w * .33, h);
    c.moveTo(w * .67, 0);
    c.lineTo(w * .67, h);
    c.moveTo(0, h * .5);
    c.lineTo(w, h * .5);
    c.stroke();
    c.setStrokeColor("#000000");
    c.setFillColor("#ffffff");
    c.setStrokeWidth(.5);
    c.roundrect(w * .1433, h * .104, w * .0417, h * .148, w * .02, h * .024);
    c.fill();
    c.begin();
    c.moveTo(w * .14, h * .188);
    c.lineTo(w * .14, h * .228);
    c.arcTo(w * .025, h * .03, 0, 0, 0, w * .19, h * .228);
    c.lineTo(w * .19, h * .188);
    c.lineTo(w * .2, h * .188);
    c.lineTo(w * .2, h * .228);
    c.arcTo(w * .0367, h * .044, 0, 0, 1, w * .17, h * .27);
    c.lineTo(w * .17, h * .296);
    c.lineTo(w * .195, h * .296);
    c.lineTo(w * .195, h * .308);
    c.lineTo(w * .1367, h * .308);
    c.lineTo(w * .1367, h * .296);
    c.lineTo(w * .16, h * .296);
    c.lineTo(w * .16, h * .27);
    c.arcTo(w * .0367, h * .044, 0, 0, 1, w * .13, h * .228);
    c.lineTo(w * .13, h * .188);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .1033, h * .108);
    c.lineTo(w * .24, h * .286);
    c.lineTo(w * .2317, h * .298);
    c.lineTo(w * .095, h * .12);
    c.close();
    c.fillAndStroke();
    c.rect(w * .44, h * .128, w * .033, h * .04);
    c.fill();
    c.rect(w * .485, h * .128, w * .033, h * .04);
    c.fill();
    c.rect(w * .53, h * .128, w * .033, h * .04);
    c.fill();
    c.rect(w * .44, h * .186, w * .033, h * .04);
    c.fill();
    c.rect(w * .485, h * .186, w * .033, h * .04);
    c.fill();
    c.rect(w * .53, h * .186, w * .033, h * .04);
    c.fill();
    c.rect(w * .44, h * .244, w * .033, h * .04);
    c.fill();
    c.rect(w * .485, h * .244, w * .033, h * .04);
    c.fill();
    c.rect(w * .53, h * .244, w * .033, h * .04);
    c.fill();
    c.begin();
    c.moveTo(w * .7567, h * .18);
    c.lineTo(w * .785, h * .18);
    c.lineTo(w * .825, h * .128);
    c.lineTo(w * .825, h * .28);
    c.lineTo(w * .79, h * .234);
    c.lineTo(w * .7567, h * .234);
    c.close();
    c.fill();
    c.setStrokeWidth(1.5);
    c.setStrokeColor("#ffffff");
    c.begin();
    c.moveTo(w * .8383, h * .16);
    c.arcTo(w * .0533, h * .064, 0, 0, 1, w * .8383, h * .252);
    c.moveTo(w * .8583, h * .134);
    c.arcTo(w * .0817, h * .098, 0, 0, 1, w * .8583, h * .276);
    c.moveTo(w * .8767, h * .11);
    c.arcTo(w * .1133, h * .136, 0, 0, 1, w * .8767, h * .304);
    c.stroke();
    c.begin();
    c.moveTo(w * .1467, h * .62);
    c.lineTo(w * .1833, h * .62);
    c.lineTo(w * .1833, h * .676);
    c.lineTo(w * .2267, h * .676);
    c.lineTo(w * .2267, h * .724);
    c.lineTo(w * .1833, h * .724);
    c.lineTo(w * .1833, h * .78);
    c.lineTo(w * .1467, h * .78);
    c.lineTo(w * .1467, h * .724);
    c.lineTo(w * .105, h * .724);
    c.lineTo(w * .105, h * .676);
    c.lineTo(w * .1467, h * .676);
    c.close();
    c.fill();
    c.rect(w * .4517, h * .624, w * .0333, h * .152);
    c.fill();
    c.rect(w * .5183, h * .624, w * .0333, h * .152);
    c.fill();
    c.begin();
    c.moveTo(w * .76, h * .752);
    c.arcTo(w * .1, h * .12, 0, 0, 1, w * .8033, h * .728);
    c.arcTo(w * .0167, h * .02, 0, 0, 0, w * .8167, h * .712);
    c.lineTo(w * .8175, h * .7);
    c.arcTo(w * .0267, h * .06, 0, 0, 1, w * .8067, h * .644);
    c.arcTo(w * .0287, h * .0344, 0, 0, 1, w * .8633, h * .644);
    c.arcTo(w * .0267, h * .06, 0, 0, 1, w * .855, h * .7);
    c.arcTo(w * .05, h * .724, 0, 0, 1, w * .8633, h * .724);
    c.arcTo(w * .1667, h * .75, 0, 0, 1, w * .9083, h * .75);
    c.lineTo(w * .9083, h * .78);
    c.lineTo(w * .76, h * .78);
    c.close();
    c.fill();
    c.setFontColor("#ffffff");
    c.setFontSize(8.5);
    c.text(w * .1667, h * .35, 0, 0, "mute", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .35, 0, 0, "keypad", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .8333, h * .35, 0, 0, "speaker", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .1667, h * .85, 0, 0, "add", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .85, 0, 0, "pause", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .8333, h * .85, 0, 0, "contacts", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setGradient("#808080", "#ffffff", 0, 0, w, h * .308, mxConstants.DIRECTION_NORTH, 1, 1);
    c.setAlpha(.4);
    c.begin();
    c.moveTo(0, h * .308);
    c.lineTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, h * .308);
    c.arcTo(w * 1.5, h * 1.8, 0, 0, 1, 0, h * .308);
    c.close();
    c.fill()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_ICALL_DIALOG, mxShapeMockupiCallDialog);
function mxShapeMockupiCallButtons(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiCallButtons, mxShape);
mxShapeMockupiCallButtons.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeMockupiCallButtons.prototype.background = function(c, x, y, w, h) {
    c.setStrokeWidth(.5);
    c.setStrokeColor("#008cff");
    c.setGradient("#0F1B2B", "#4F5B6B", 0, 0, w, h, mxConstants.DIRECTION_NORTH, 1, 1);
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeMockupiCallButtons.prototype.foreground = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(0, h * .1667);
    c.lineTo(w, h * .1667);
    c.moveTo(0, h * .3333);
    c.lineTo(w, h * .3333);
    c.moveTo(0, h * .5);
    c.lineTo(w, h * .5);
    c.moveTo(0, h * .6667);
    c.lineTo(w, h * .6667);
    c.moveTo(0, h * .8333);
    c.lineTo(w, h * .8333);
    c.moveTo(w * .3333, h * .1667);
    c.lineTo(w * .3333, h);
    c.moveTo(w * .6667, h * .1667);
    c.lineTo(w * .6667, h);
    c.stroke();
    c.setFontSize(15.5);
    c.setFontColor("#ffffff");
    c.setFontStyle(mxConstants.FONT_BOLD);
    c.text(w * .5, h * .0834, 0, 0, "(123) 456-7890", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .1667, h * .22, 0, 0, "1", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .22, 0, 0, "2", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .8333, h * .22, 0, 0, "3", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .1667, h * .3867, 0, 0, "3", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .3867, 0, 0, "4", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .8333, h * .3867, 0, 0, "5", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .1667, h * .5534, 0, 0, "6", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .5534, 0, 0, "7", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .8333, h * .5534, 0, 0, "8", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setFontSize(27.5);
    c.text(w * .1667, h * .76, 0, 0, "*", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setFontSize(15.5);
    c.text(w * .5, h * .72, 0, 0, "0", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .8333, h * .75, 0, 0, "#", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setGradient("#E2FFEB", "#008215", w * .3333, h * .8333, w * .3333, h * .1667, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.rect(w * .3333, h * .8333, w * .3333, h * .1667);
    c.fillAndStroke();
    c.text(w * .5, h * .9168, 0, 0, "Call", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setFontStyle(0);
    c.setFontSize(8);
    c.setFontColor("#bbbbbb");
    c.text(w * .5, h * .28, 0, 0, "ABC", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .8333, h * .28, 0, 0, "DEF", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .1667, h * .4467, 0, 0, "GHI", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .4467, 0, 0, "JKL", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .8333, h * .4467, 0, 0, "MNO", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .1667, h * .6134, 0, 0, "PQRS", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .6134, 0, 0, "TUV", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .8333, h * .6134, 0, 0, "WXYZ", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .78, 0, 0, "+", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setFillColor("#ffffff");
    c.begin();
    c.moveTo(w * .1028, h * .9464);
    c.arcTo(w * .0862, h * .0652, 0, 0, 1, w * .1402, h * .9333);
    c.arcTo(w * .0144, h * .0109, 0, 0, 0, w * .1517, h * .9246);
    c.lineTo(w * .1524, h * .9181);
    c.arcTo(w * .023, h * .0326, 0, 0, 1, w * .143, h * .8877);
    c.arcTo(w * .0247, h * .0187, 0, 0, 1, w * .1919, h * .8877);
    c.arcTo(w * .023, h * .0326, 0, 0, 1, w * .1847, h * .9181);
    c.arcTo(w * .0431, h * .0174, 0, 0, 0, w * .1919, h * .9311);
    c.arcTo(w * .1437, h * .1087, 0, 0, 1, w * .2307, h * .9453);
    c.lineTo(w * .2307, h * .9616);
    c.lineTo(w * .1028, h * .9616);
    c.close();
    c.fill();
    c.setStrokeColor("#ffffff");
    c.setStrokeWidth(2.5);
    c.setLineJoin("round");
    c.begin();
    c.moveTo(w * .79, h * .89);
    c.lineTo(w * .9, h * .89);
    c.lineTo(w * .9, h * .95);
    c.lineTo(w * .79, h * .95);
    c.lineTo(w * .76, h * .92);
    c.close();
    c.fillAndStroke();
    c.setStrokeColor("#0F1B2B");
    c.begin();
    c.moveTo(w * .82, h * .907);
    c.lineTo(w * .85, h * .933);
    c.moveTo(w * .82, h * .933);
    c.lineTo(w * .85, h * .907);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_ICALL_BUTTONS, mxShapeMockupiCallButtons);
function mxShapeMockupiOption(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiOption, mxShape);
mxShapeMockupiOption.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeMockupiOption.prototype.background = function(c, x, y, w, h) {
    var barPos = mxUtils.getValue(this.style, mxMockupC.BAR_POS, "80");
    barPos = Math.min(barPos, 100);
    barPos = Math.max(barPos, 0);
    var pointerPos = mxUtils.getValue(this.style, mxMockupC.POINTER_POS, mxMockupC.POINTER_BOTTOM);
    var rSize = 2.5;
    var deadzone = rSize + 7.5;
    var virRange = w - 2 * deadzone;
    var truePos = deadzone + virRange * barPos / 100;
    c.setStrokeWidth(.5);
    c.setStrokeColor("#000000");
    c.setAlpha(.9);
    c.begin();
    if (pointerPos === mxMockupC.POINTER_BOTTOM) {
        c.setGradient("#000000", "#888888", 0, 0, w, h, mxConstants.DIRECTION_NORTH, 1, 1);
        c.moveTo(0, rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
        c.lineTo(w - rSize, 0);
        c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
        c.lineTo(w, h - rSize - 7.5);
        c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h - 7.5);
        c.lineTo(truePos + 7.5, h - 7.5);
        c.lineTo(truePos, h);
        c.lineTo(truePos - 7.5, h - 7.5);
        c.lineTo(rSize, h - 7.5);
        c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize - 7.5)
    } else if (pointerPos === mxMockupC.POINTER_TOP) {
        c.setGradient("#000000", "#888888", 0, 0, w, h, mxConstants.DIRECTION_NORTH, 1, 1);
        c.moveTo(0, rSize + 7.5);
        c.arcTo(rSize, rSize, 0, 0, 1, rSize, 7.5);
        c.lineTo(truePos - 7.5, 7.5);
        c.lineTo(truePos, 0);
        c.lineTo(truePos + 7.5, 7.5);
        c.lineTo(w - rSize, 7.5);
        c.arcTo(rSize, rSize, 0, 0, 1, w, rSize + 7.5);
        c.lineTo(w, h - rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
        c.lineTo(rSize, h);
        c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize)
    }
    c.close();
    c.fillAndStroke()
}
;
mxShapeMockupiOption.prototype.foreground = function(c, x, y, w, h) {
    var locText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, "Some Location");
    var pointerPos = mxUtils.getValue(this.style, mxMockupC.POINTER_POS, mxMockupC.POINTER_BOTTOM);
    c.setAlpha(1);
    c.setFontColor("#ffffff");
    c.setFontSize(9.5);
    if (pointerPos === mxMockupC.POINTER_BOTTOM)
        c.text(w * .5, (h - 7.5) * .5, 0, 0, locText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    else
        c.text(w * .5, (h + 7.5) * .5, 0, 0, locText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IOPTION, mxShapeMockupiOption);
function mxShapeMockupiAlphaList(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiAlphaList, mxShape);
mxShapeMockupiAlphaList.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.setShadow(false);
    var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "8");
    c.setFontColor("#999999");
    c.setFontSize(fontSize);
    c.text(w * .5, h * .069, 0, 0, "A", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .1035, 0, 0, "B", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .138, 0, 0, "C", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .1725, 0, 0, "D", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .207, 0, 0, "E", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .2415, 0, 0, "F", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .276, 0, 0, "G", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .3105, 0, 0, "H", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .345, 0, 0, "I", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .3795, 0, 0, "J", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .414, 0, 0, "K", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .4485, 0, 0, "L", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .483, 0, 0, "M", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .5175, 0, 0, "N", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .552, 0, 0, "O", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .5865, 0, 0, "P", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .621, 0, 0, "Q", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .6555, 0, 0, "R", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .69, 0, 0, "S", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .7245, 0, 0, "T", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .759, 0, 0, "U", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .7935, 0, 0, "V", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .828, 0, 0, "W", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .8625, 0, 0, "X", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .897, 0, 0, "Y", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .9315, 0, 0, "Z", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.text(w * .5, h * .966, 0, 0, "#", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setStrokeColor("#999999");
    c.ellipse(w * .5 - 2.25, h * .0345 - 3.5, 4.5, 4.5);
    c.stroke();
    c.begin();
    c.moveTo(w * .5 - 4.25, h * .0345 + 3);
    c.lineTo(w * .5 - 1.75, h * .0345);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IALPHA_LIST, mxShapeMockupiAlphaList);
function mxShapeMockupiHorButtonBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiHorButtonBar, mxShape);
mxShapeMockupiHorButtonBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    var textStrings = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, "+Button 1, Button 2, Button 3").toString().split(",");
    var fontColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR, "#666666");
    var selectedFontColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR2, "#ffffff");
    var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "8.5").toString();
    var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#666666");
    var separatorColor = mxUtils.getValue(this.style, mxMockupC.STYLE_STROKECOLOR2, "#c4c4c4");
    var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var selectedFillColor = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, "#008cff");
    var buttonNum = textStrings.length;
    var buttonWidths = new Array(buttonNum);
    var buttonTotalWidth = 0;
    var selectedButton = -1;
    var rSize = 2.5;
    var labelOffset = 2.5;
    for (var i = 0; i < buttonNum; i++) {
        var buttonText = textStrings[i];
        if (buttonText.charAt(0) === mxMockupC.SELECTED) {
            buttonText = textStrings[i].substring(1);
            selectedButton = i
        }
        buttonWidths[i] = mxUtils.getSizeForString(buttonText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
        buttonTotalWidth += buttonWidths[i]
    }
    var trueH = Math.max(h, fontSize * 1.5, 10);
    var minW = 2 * labelOffset * buttonNum + buttonTotalWidth;
    var trueW = Math.max(w, minW);
    c.translate(x, y);
    this.background(c, trueW, trueH, rSize, buttonNum, buttonWidths, labelOffset, minW, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton);
    c.setShadow(false);
    var currWidth = 0;
    for (var i = 0; i < buttonNum; i++) {
        if (i === selectedButton)
            c.setFontColor(selectedFontColor);
        else
            c.setFontColor(fontColor);
        currWidth = currWidth + labelOffset;
        this.buttonText(c, currWidth, trueH, textStrings[i], buttonWidths[i], fontSize, minW, trueW);
        currWidth = currWidth + buttonWidths[i] + labelOffset
    }
}
;
mxShapeMockupiHorButtonBar.prototype.background = function(c, w, h, rSize, buttonNum, buttonWidths, labelOffset, minW, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton) {
    c.begin();
    c.setStrokeColor(frameColor);
    c.setFillColor(bgColor);
    c.moveTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, h - rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
    c.lineTo(rSize, h);
    c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
    c.close();
    c.fillAndStroke();
    c.setStrokeColor(separatorColor);
    c.begin();
    for (var i = 1; i < buttonNum; i++)
        if (i !== selectedButton && i !== selectedButton + 1) {
            var currWidth = 0;
            for (var j = 0; j < i; j++)
                currWidth += buttonWidths[j] + 2 * labelOffset;
            currWidth = currWidth * w / minW;
            c.moveTo(currWidth, 0);
            c.lineTo(currWidth, h)
        }
    c.stroke();
    var buttonLeft = 0;
    c.setStrokeColor(mxConstants.NONE);
    for (var i = 0; i < selectedButton; i++)
        buttonLeft += buttonWidths[i] + 2 * labelOffset;
    buttonLeft = buttonLeft * w / minW;
    var buttonRight = (buttonWidths[selectedButton] + 2 * labelOffset) * w / minW;
    buttonRight += buttonLeft;
    if (selectedButton === 0) {
        c.setGradient("#5D7585", "#008cff", 0, 0, buttonRight, h, mxConstants.DIRECTION_SOUTH, 1, 1);
        c.begin();
        c.moveTo(0, rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
        c.lineTo(buttonRight, 0);
        c.lineTo(buttonRight, h);
        c.lineTo(rSize, h);
        c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
        c.close();
        c.fill()
    } else if (selectedButton === buttonNum - 1) {
        c.setGradient("#5D7585", "#008cff", buttonLeft, 0, buttonRight - buttonLeft, h, mxConstants.DIRECTION_SOUTH, 1, 1);
        c.begin();
        c.moveTo(buttonLeft, 0);
        c.lineTo(buttonRight - rSize, 0);
        c.arcTo(rSize, rSize, 0, 0, 1, buttonRight, rSize);
        c.lineTo(buttonRight, h - rSize);
        c.arcTo(rSize, rSize, 0, 0, 1, buttonRight - rSize, h);
        c.lineTo(buttonLeft, h);
        c.close();
        c.fill()
    } else if (selectedButton !== -1) {
        c.setGradient("#5D7585", "#008cff", buttonLeft, 0, buttonRight - buttonLeft, h, mxConstants.DIRECTION_SOUTH, 1, 1);
        c.begin();
        c.moveTo(buttonLeft, 0);
        c.lineTo(buttonRight, 0);
        c.lineTo(buttonRight, h);
        c.lineTo(buttonLeft, h);
        c.close();
        c.fill()
    }
    c.setStrokeColor(frameColor);
    c.setFillColor(bgColor);
    c.begin();
    c.moveTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, h - rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
    c.lineTo(rSize, h);
    c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
    c.close();
    c.stroke()
}
;
mxShapeMockupiHorButtonBar.prototype.buttonText = function(c, w, h, textString, buttonWidth, fontSize, minW, trueW) {
    if (textString.charAt(0) === mxMockupC.SELECTED)
        textString = textString.substring(1);
    c.begin();
    c.setFontSize(fontSize);
    c.text((w + buttonWidth * .5) * trueW / minW, h * .5, 0, 0, textString, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IHOR_BUTTON_BAR, mxShapeMockupiHorButtonBar);
function mxShapeMockupiPin(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiPin, mxShape);
mxShapeMockupiPin.prototype.paintVertexShape = function(c, x, y, w, h) {
    var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, "#000000");
    var fillColor3 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR3, "#000000");
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    c.setShadow(false);
    c.translate(x, y);
    c.setStrokeWidth(1.5);
    c.setStrokeColor("#666666");
    c.begin();
    c.moveTo(w * .5, h * .4);
    c.lineTo(w * .5, h);
    c.stroke();
    c.setStrokeWidth(1);
    c.setStrokeColor(strokeColor);
    c.setGradient(fillColor2, fillColor3, 0, 0, w, h * .4, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.setAlpha(.9);
    c.ellipse(0, 0, w, h * .4);
    c.fillAndStroke();
    c.setFillColor("#ffffff");
    c.setAlpha(.5);
    c.ellipse(w * .2, h * .08, w * .3, h * .12);
    c.fill()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IPIN, mxShapeMockupiPin);
function mxShapeMockupiVideoControls(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiVideoControls, mxShape);
mxShapeMockupiVideoControls.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = 5;
    c.setStrokeWidth(1);
    c.setFillColor("#000000");
    c.setStrokeColor("#bbbbbb");
    c.setAlpha(.7);
    c.roundrect(0, 0, w, h, rSize, rSize);
    c.fillAndStroke();
    c.setShadow(false);
    this.foreground(c, w, h, rSize)
}
;
mxShapeMockupiVideoControls.prototype.foreground = function(c, w, h, rSize) {
    c.setGradient("#ffffff", "#ffffff", 0, 0, w, h * .5, mxConstants.DIRECTION_SOUTH, .8, .1);
    c.begin();
    c.moveTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, h * .5);
    c.lineTo(0, h * .5);
    c.close();
    c.fill();
    c.setAlpha(1);
    c.setFillColor("#ffffff");
    c.setStrokeColor("#ffffff");
    var iconX = w * .1;
    var iconY = h * .35;
    c.begin();
    c.moveTo(iconX - 7.5, iconY - 2.5);
    c.arcTo(6, 6, 0, 0, 1, iconX, iconY - 2.5);
    c.arcTo(6, 6, 0, 0, 1, iconX + 7.5, iconY - 2.5);
    c.lineTo(iconX + 7.5, iconY + 4);
    c.arcTo(6, 6, 0, 0, 0, iconX, iconY + 4);
    c.arcTo(6, 6, 0, 0, 0, iconX - 7.5, iconY + 4);
    c.close();
    c.stroke();
    c.begin();
    c.moveTo(iconX, iconY - 2.5);
    c.lineTo(iconX, iconY + 4);
    c.stroke();
    iconX = w * .3;
    c.rect(iconX - 7.5, iconY - 5, 1, 10);
    c.fill();
    c.begin();
    c.moveTo(iconX - 6.5, iconY);
    c.lineTo(iconX + .5, iconY - 5);
    c.lineTo(iconX + .5, iconY + 5);
    c.close();
    c.fill();
    c.begin();
    c.moveTo(iconX + .5, iconY);
    c.lineTo(iconX + 7.5, iconY - 5);
    c.lineTo(iconX + 7.5, iconY + 5);
    c.close();
    c.fill();
    iconX = w * .5;
    c.begin();
    c.moveTo(iconX - 6, iconY - 5);
    c.lineTo(iconX + 6, iconY);
    c.lineTo(iconX - 6, iconY + 5);
    c.close();
    c.fill();
    iconX = w * .7;
    c.begin();
    c.moveTo(iconX - 7.5, iconY - 5);
    c.lineTo(iconX - .5, iconY);
    c.lineTo(iconX - 7.5, iconY + 5);
    c.close();
    c.fill();
    c.begin();
    c.moveTo(iconX - .5, iconY - 5);
    c.lineTo(iconX + 6.5, iconY);
    c.lineTo(iconX - .5, iconY + 5);
    c.close();
    c.fill();
    c.rect(iconX + 6.5, iconY - 5, 1, 10);
    c.fill();
    iconX = w * .9;
    c.rect(iconX - 7.5, iconY - 4, 15, 8);
    c.stroke();
    c.setStrokeWidth(.5);
    c.begin();
    c.moveTo(iconX - 7.5, iconY - 4);
    c.lineTo(iconX, iconY + 1.5);
    c.lineTo(iconX + 7.5, iconY - 4);
    c.stroke();
    c.begin();
    c.moveTo(iconX - 7.5, iconY + 4);
    c.lineTo(iconX - 2, iconY);
    c.stroke();
    c.begin();
    c.moveTo(iconX + 7.5, iconY + 4);
    c.lineTo(iconX + 2, iconY);
    c.stroke();
    c.setGradient("#444444", "#ffffff", w * .1, h * .75 - 2.5, w * .8, 5, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.roundrect(w * .1, h * .75 - 2.5, w * .8, 5, 2.5, 2.5);
    c.fill();
    var barPos = mxUtils.getValue(this.style, mxMockupC.BAR_POS, "80");
    barPos = Math.min(barPos, 100);
    barPos = Math.max(barPos, 0);
    var deadzone = w * .1;
    var virRange = w - 2 * deadzone;
    var truePos = deadzone + virRange * barPos / 100;
    c.setGradient("#96D1FF", "#003377", w * .1, h * .75 - 5, truePos - w * .1, 10, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.begin();
    c.moveTo(truePos, h * .75 - 2.5);
    c.lineTo(truePos, h * .75 + 2.5);
    c.lineTo(w * .1 + 2.5, h * .75 + 2.5);
    c.arcTo(2.5, 2.5, 0, 0, 1, w * .1 + 2.5, h * .75 - 2.5);
    c.close();
    c.fill();
    c.setStrokeColor("#999999");
    c.setGradient("#444444", "#ffffff", truePos - 5, h * .75 - 5, 10, 10, mxConstants.DIRECTION_NORTH, 1, 1);
    c.ellipse(truePos - 5, h * .75 - 5, 10, 10);
    c.fillAndStroke();
    c.setStrokeColor("#dddddd");
    c.roundrect(0, 0, w, h, rSize, rSize);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IVIDEO_CONTROLS, mxShapeMockupiVideoControls);
Graph.handleFactory[mxMockupC.SHAPE_IVIDEO_CONTROLS] = function(state) {
    var handles = [Graph.createHandle(state, ["barPos"], function(bounds) {
        var barPos = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "barPos", 40))));
        return new mxPoint(bounds.x + bounds.width * .1 + barPos * bounds.width * .8 / 100,bounds.y + bounds.height * .75)
    }, function(bounds, pt) {
        this.state.style["barPos"] = Math.round(100 * Math.max(0, Math.min(100, (pt.x - bounds.width * .1 - bounds.x) * 100 / (bounds.width * .8)))) / 100
    })];
    return handles
}
;
function mxShapeMockupiURLBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiURLBar, mxShape);
mxShapeMockupiURLBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.setGradient("#cccccc", "#003377", 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.rect(0, 0, w, h);
    c.fill();
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxShapeMockupiURLBar.prototype.foreground = function(c, w, h) {
    c.setStrokeWidth(.5);
    c.setFillColor("#ffffff");
    c.setStrokeColor("#008cff");
    c.roundrect(w * .0287, h * .625 - 6.25, w * .7184, 12.5, 6.25, 6.25);
    c.fillAndStroke();
    c.setGradient("#cccccc", "#001144", w * .7816, h * .625 - 6.25, w * .1868, 12.5, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.setStrokeColor("#000000");
    c.roundrect(w * .7816, h * .625 - 6.25, w * .1868, 12.5, 2.5, 2.5);
    c.fillAndStroke();
    c.setFillColor("#bbbbbb");
    c.ellipse(w * .7471 - 11.5, h * .625 - 5, 10, 10);
    c.fill();
    c.setStrokeColor("#ffffff");
    c.setStrokeWidth(1.5);
    c.begin();
    c.moveTo(w * .7471 - 8.5, h * .625 - 2.5);
    c.lineTo(w * .7471 - 3.5, h * .625 + 2.5);
    c.moveTo(w * .7471 - 8.5, h * .625 + 2.5);
    c.lineTo(w * .7471 - 3.5, h * .625 - 2.5);
    c.stroke();
    var fieldText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, "").toString().split(",");
    c.setFontColor("#425664");
    c.setFontStyle(mxConstants.FONT_BOLD);
    c.setFontSize(8);
    c.text(w * .5, h * .2, 0, 0, fieldText[0], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setFontColor("#000000");
    c.text(w * .06, h * .625, 0, 0, fieldText[1], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setFontColor("#ffffff");
    c.text(w * .875, h * .625, 0, 0, fieldText[2], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IURL_BAR, mxShapeMockupiURLBar);
function mxShapeMockupiSlider(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiSlider, mxShape);
mxShapeMockupiSlider.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxShapeMockupiSlider.prototype.foreground = function(c, w, h) {
    c.setStrokeWidth(.5);
    c.setGradient("#444444", "#ffffff", 0, h * .5 - 2.5, w, 5, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.roundrect(0, h * .5 - 2.5, w, 5, 2.5, 2.5);
    c.fill();
    var barPos = mxUtils.getValue(this.style, mxMockupC.BAR_POS, "80");
    barPos = Math.min(barPos, 100);
    barPos = Math.max(barPos, 0);
    var deadzone = 0;
    var virRange = w - 2 * deadzone;
    var truePos = deadzone + virRange * barPos / 100;
    c.setGradient("#96D1FF", "#003377", 2.5, h * .5 - 2.5, truePos - 2.5, 5, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.begin();
    c.moveTo(truePos, h * .5 - 2.5);
    c.lineTo(truePos, h * .5 + 2.5);
    c.lineTo(2.5, h * .5 + 2.5);
    c.arcTo(2.5, 2.5, 0, 0, 1, 2.5, h * .5 - 2.5);
    c.close();
    c.fill();
    c.setStrokeColor("#999999");
    c.setGradient("#444444", "#ffffff", truePos - 5, h * .5 - 5, 10, 10, mxConstants.DIRECTION_NORTH, 1, 1);
    c.ellipse(truePos - 5, h * .5 - 5, 10, 10);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_ISLIDER, mxShapeMockupiSlider);
Graph.handleFactory[mxMockupC.SHAPE_ISLIDER] = function(state) {
    var handles = [Graph.createHandle(state, ["barPos"], function(bounds) {
        var barPos = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "barPos", .4))));
        return new mxPoint(bounds.x + barPos * bounds.width / 100,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["barPos"] = Math.round(100 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 100
    })];
    return handles
}
;
function mxShapeMockupiProgressBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiProgressBar, mxShape);
mxShapeMockupiProgressBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxShapeMockupiProgressBar.prototype.foreground = function(c, w, h) {
    c.setStrokeWidth(.5);
    c.setGradient("#444444", "#ffffff", 0, h * .5 - 2.5, w, 5, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.roundrect(0, h * .5 - 2.5, w, 5, 2.5, 2.5);
    c.fill();
    var barPos = mxUtils.getValue(this.style, mxMockupC.BAR_POS, "80");
    barPos = Math.min(barPos, 100);
    barPos = Math.max(barPos, 0);
    var deadzone = 0;
    var virRange = w - 2 * deadzone;
    var truePos = deadzone + virRange * barPos / 100;
    c.setGradient("#96D1FF", "#003377", 2.5, h * .5 - 2.5, truePos - 2.5, 5, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.begin();
    c.moveTo(truePos, h * .5 - 2.5);
    c.arcTo(2.5, 2.5, 0, 0, 1, truePos, h * .5 + 2.5);
    c.lineTo(2.5, h * .5 + 2.5);
    c.arcTo(2.5, 2.5, 0, 0, 1, 2.5, h * .5 - 2.5);
    c.close();
    c.fill()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IPROGRESS_BAR, mxShapeMockupiProgressBar);
Graph.handleFactory[mxMockupC.SHAPE_IPROGRESS_BAR] = function(state) {
    var handles = [Graph.createHandle(state, ["barPos"], function(bounds) {
        var barPos = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "barPos", .4))));
        return new mxPoint(bounds.x + barPos * bounds.width / 100,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["barPos"] = Math.round(100 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 100
    })];
    return handles
}
;
function mxShapeMockupiCloudProgressBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiCloudProgressBar, mxShape);
mxShapeMockupiCloudProgressBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxShapeMockupiCloudProgressBar.prototype.foreground = function(c, w, h) {
    c.setStrokeWidth(.5);
    c.setFillColor("#5C6E86");
    c.rect(0, h * .5 - 2.5, w, 5);
    c.fill();
    var barPos = mxUtils.getValue(this.style, mxMockupC.BAR_POS, "80");
    barPos = Math.min(barPos, 100);
    barPos = Math.max(barPos, 0);
    var deadzone = 0;
    var virRange = w - 2 * deadzone;
    var truePos = deadzone + virRange * barPos / 100;
    c.setFillColor("#8AD155");
    c.rect(0, h * .5 - 2.5, truePos, 5);
    c.fill()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_ICLOUD_PROGRESS_BAR, mxShapeMockupiCloudProgressBar);
Graph.handleFactory[mxMockupC.SHAPE_ICLOUD_PROGRESS_BAR] = function(state) {
    var handles = [Graph.createHandle(state, ["barPos"], function(bounds) {
        var barPos = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "barPos", .4))));
        return new mxPoint(bounds.x + barPos * bounds.width / 100,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["barPos"] = Math.round(100 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 100
    })];
    return handles
}
;
function mxShapeMockupiDownloadBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiDownloadBar, mxShape);
mxShapeMockupiDownloadBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.setGradient("#00ccff", "#0066cc", 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.rect(0, 0, w, h);
    c.fill();
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxShapeMockupiDownloadBar.prototype.foreground = function(c, w, h) {
    var fieldText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, "");
    c.setFontColor("#ffffff");
    c.setFontStyle(mxConstants.FONT_BOLD);
    c.setFontSize(8);
    c.text(w * .5, h * .2, 0, 0, fieldText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    var barPos = mxUtils.getValue(this.style, mxMockupC.BAR_POS, "80");
    barPos = Math.min(barPos, 100);
    barPos = Math.max(barPos, 0);
    var deadzone = w * .1;
    var virRange = w - 2 * deadzone;
    var truePos = deadzone + virRange * barPos / 100;
    c.setStrokeWidth(.5);
    c.setGradient("#96D1FF", "#003377", deadzone, h * .65 - 2.5, w - 2 * deadzone, 5, mxConstants.DIRECTION_NORTH, 1, 1);
    c.roundrect(deadzone, h * .65 - 2.5, w - 2 * deadzone, 5, 2.5, 2.5);
    c.fill();
    c.setGradient("#aaaaaa", "#ffffff", deadzone + 2.5, h * .65 - 2.5, truePos - deadzone - 2.5, 5, mxConstants.DIRECTION_NORTH, 1, 1);
    c.begin();
    c.moveTo(truePos, h * .65 - 2.5);
    c.arcTo(2.5, 2.5, 0, 0, 1, truePos, h * .65 + 2.5);
    c.lineTo(deadzone + 2.5, h * .65 + 2.5);
    c.arcTo(2.5, 2.5, 0, 0, 1, deadzone + 2.5, h * .65 - 2.5);
    c.close();
    c.fill()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IDOWNLOAD_BAR, mxShapeMockupiDownloadBar);
Graph.handleFactory[mxMockupC.SHAPE_IDOWNLOAD_BAR] = function(state) {
    var handles = [Graph.createHandle(state, ["barPos"], function(bounds) {
        var barPos = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "barPos", 40))));
        return new mxPoint(bounds.x + bounds.width * .1 + barPos * bounds.width * .8 / 100,bounds.y + bounds.height * .65)
    }, function(bounds, pt) {
        this.state.style["barPos"] = Math.round(100 * Math.max(0, Math.min(100, (pt.x - bounds.width * .1 - bounds.x) * 100 / (bounds.width * .8)))) / 100
    })];
    return handles
}
;
function mxShapeMockupiScreenNameBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiScreenNameBar, mxShape);
mxShapeMockupiScreenNameBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = 5;
    c.setStrokeWidth(.5);
    var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, "#00ff00");
    c.setFillColor(fillColor2);
    c.rect(0, 0, w, h);
    c.fill();
    c.setShadow(false);
    this.foreground(c, w, h, rSize)
}
;
mxShapeMockupiScreenNameBar.prototype.foreground = function(c, w, h, rSize) {
    var fillColor3 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR3, "#00ff00");
    c.setGradient(fillColor3, fillColor3, 0, 0, w, h * .5, mxConstants.DIRECTION_SOUTH, .8, .1);
    c.rect(0, 0, w, h * .5);
    c.fill();
    var fieldText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, "");
    var textColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR, "#00ff00");
    c.setFontColor(textColor);
    c.setFontSize(9.5);
    c.text(w * .5, h * .45, 0, 0, fieldText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_ISCREEN_NAME_BAR, mxShapeMockupiScreenNameBar);
function mxShapeMockupiIconGrid(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiIconGrid, mxShape);
mxShapeMockupiIconGrid.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var gridSize = mxUtils.getValue(this.style, mxMockupC.GRID_SIZE, "3,3").toString().split(",");
    this.background(c, w, h, gridSize);
    c.setShadow(false);
    this.foreground(c, w, h, gridSize)
}
;
mxShapeMockupiIconGrid.prototype.background = function(c, w, h, gridSize) {
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#00ff00");
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#00ff00");
    c.setStrokeColor(strokeColor);
    c.setFillColor(fillColor);
    var boxSizeX = w / (parseInt(gridSize[0], 10) + (gridSize[0] - 1) * .5);
    var boxSizeY = h / (parseInt(gridSize[1], 10) + (gridSize[1] - 1) * .5);
    for (var i = 0; i < gridSize[0]; i++)
        for (var j = 0; j < gridSize[1]; j++) {
            c.rect(boxSizeX * 1.5 * i, boxSizeY * 1.5 * j, boxSizeX, boxSizeY);
            c.fillAndStroke()
        }
}
;
mxShapeMockupiIconGrid.prototype.foreground = function(c, w, h, gridSize) {
    var boxSizeX = w / (parseInt(gridSize[0], 10) + (gridSize[0] - 1) * .5);
    var boxSizeY = h / (parseInt(gridSize[1], 10) + (gridSize[1] - 1) * .5);
    for (var i = 0; i < gridSize[0]; i++)
        for (var j = 0; j < gridSize[1]; j++) {
            c.begin();
            c.moveTo(boxSizeX * 1.5 * i, boxSizeY * 1.5 * j);
            c.lineTo(boxSizeX * 1.5 * i + boxSizeX, boxSizeY * 1.5 * j + boxSizeY);
            c.moveTo(boxSizeX * 1.5 * i + boxSizeX, boxSizeY * 1.5 * j);
            c.lineTo(boxSizeX * 1.5 * i, boxSizeY * 1.5 * j + boxSizeY);
            c.stroke()
        }
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IICON_GRID, mxShapeMockupiIconGrid);
function mxShapeMockupiCopy(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiCopy, mxShape);
mxShapeMockupiCopy.prototype.paintVertexShape = function(c, x, y, w, h) {
    var rSize = 5;
    c.translate(x, y);
    this.background(c, w, h, rSize);
    c.setShadow(false);
    this.foreground(c, w, h, rSize)
}
;
mxShapeMockupiCopy.prototype.background = function(c, w, h, rSize) {
    c.begin();
    c.moveTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, h - rSize - 7.5);
    c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h - 7.5);
    c.lineTo(w * .5 + 7.5, h - 7.5);
    c.lineTo(w * .5, h);
    c.lineTo(w * .5 - 7.5, h - 7.5);
    c.lineTo(rSize, h - 7.5);
    c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize - 7.5);
    c.close();
    c.fillAndStroke()
}
;
mxShapeMockupiCopy.prototype.foreground = function(c, w, h, rSize) {
    var fillColor3 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR3, "#00ff00");
    c.setGradient(fillColor3, fillColor3, 0, 0, w, h * .5, mxConstants.DIRECTION_SOUTH, .8, .1);
    c.begin();
    c.moveTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, (h - 7.5) * .5);
    c.lineTo(0, (h - 7.5) * .5);
    c.close();
    c.fill();
    var fieldText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, "");
    var textColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR, "#00ff00");
    c.setFontColor(textColor);
    c.setFontSize(8.5);
    c.text(w * .5, (h - 7.5) * .45, 0, 0, fieldText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_ICOPY, mxShapeMockupiCopy);
function mxShapeMockupiCopyArea(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiCopyArea, mxShape);
mxShapeMockupiCopyArea.prototype.paintVertexShape = function(c, x, y, w, h) {
    var rSize = 5;
    c.translate(x, y);
    this.background(c, w, h, rSize);
    c.setShadow(false);
    this.foreground(c, w, h, rSize)
}
;
mxShapeMockupiCopyArea.prototype.background = function(c, w, h, rSize) {
    c.begin();
    c.moveTo(w * .5 - 20, 0 + rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, w * .5 - 20 + rSize, 0);
    c.lineTo(w * .5 + 20 - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w * .5 + 20, rSize);
    c.lineTo(w * .5 + 20, 20 - rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, w * .5 + 20 - rSize, 20);
    c.lineTo(w * .5 + 7.5, 20);
    c.lineTo(w * .5, 27.5);
    c.lineTo(w * .5 - 7.5, 20);
    c.lineTo(w * .5 - 20 + rSize, 20);
    c.arcTo(rSize, rSize, 0, 0, 1, w * .5 - 20, 20 - rSize);
    c.close();
    c.fillAndStroke()
}
;
mxShapeMockupiCopyArea.prototype.foreground = function(c, w, h, rSize) {
    c.setAlpha(.3);
    c.setFillColor("#2266ff");
    c.rect(2.5, 27.5, w - 5, h - 30);
    c.fill();
    c.setAlpha(1);
    if (h > 27.5) {
        c.setStrokeColor("#ffffff");
        c.setGradient("#88ddff", "#2266ff", w * .5 - 2.5, 25, 5, 5, mxConstants.DIRECTION_SOUTH, 1, 1);
        c.ellipse(w * .5 - 2.5, 25, 5, 5);
        c.fillAndStroke();
        c.setGradient("#88ddff", "#2266ff", w * .5 - 2.5, h - 5, 5, 5, mxConstants.DIRECTION_SOUTH, 1, 1);
        c.ellipse(w * .5 - 2.5, h - 5, 5, 5);
        c.fillAndStroke();
        c.setGradient("#88ddff", "#2266ff", 0, h * .5 + 10, 5, 5, mxConstants.DIRECTION_SOUTH, 1, 1);
        c.ellipse(0, h * .5 + 10, 5, 5);
        c.fillAndStroke();
        c.setGradient("#88ddff", "#2266ff", w - 5, h * .5 + 10, 5, 5, mxConstants.DIRECTION_SOUTH, 1, 1);
        c.ellipse(w - 5, h * .5 + 10, 5, 5);
        c.fillAndStroke()
    }
    var fillColor2 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR2, "#00ff00");
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#00ff00");
    c.setFillColor(fillColor2);
    c.setStrokeColor(strokeColor);
    c.begin();
    c.moveTo(w * .5 - 20, 0 + rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, w * .5 - 20 + rSize, 0);
    c.lineTo(w * .5 + 20 - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w * .5 + 20, rSize);
    c.lineTo(w * .5 + 20, 20 - rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, w * .5 + 20 - rSize, 20);
    c.lineTo(w * .5 + 7.5, 20);
    c.lineTo(w * .5, 27.5);
    c.lineTo(w * .5 - 7.5, 20);
    c.lineTo(w * .5 - 20 + rSize, 20);
    c.arcTo(rSize, rSize, 0, 0, 1, w * .5 - 20, 20 - rSize);
    c.close();
    c.fillAndStroke();
    var fillColor3 = mxUtils.getValue(this.style, mxMockupC.STYLE_FILLCOLOR3, "#00ff00");
    c.setGradient(fillColor3, fillColor3, w * .5 - 20, 0, 40, 10, mxConstants.DIRECTION_SOUTH, .8, .1);
    c.begin();
    c.moveTo(w * .5 - 20, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, w * .5 - 20 + rSize, 0);
    c.lineTo(w * .5 + 20 - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w * .5 + 20, rSize);
    c.lineTo(w * .5 + 20, 10);
    c.lineTo(w * .5 - 20, 10);
    c.close();
    c.fill();
    var fieldText = mxUtils.getValue(this.style, mxMockupC.BUTTON_TEXT, "");
    var textColor = mxUtils.getValue(this.style, mxMockupC.STYLE_TEXTCOLOR, "#00ff00");
    c.setFontColor(textColor);
    c.setFontSize(8.5);
    c.text(w * .5, 8.75, 0, 0, fieldText, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_ICOPY_AREA, mxShapeMockupiCopyArea);
function mxShapeMockupiHomePageControl(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiHomePageControl, mxShape);
mxShapeMockupiHomePageControl.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#000000");
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    c.setStrokeColor(strokeColor);
    c.setFillColor(fillColor);
    var rSize = Math.min(h * .5, w * .05);
    c.ellipse(w * .35 - rSize, h * .5 - rSize, 2 * rSize, 2 * rSize);
    c.fill();
    c.ellipse(w * .65 - rSize, h * .5 - rSize, 2 * rSize, 2 * rSize);
    c.fill();
    c.ellipse(w - 2 * rSize, h * .5 - rSize, 2 * rSize, 2 * rSize);
    c.fill();
    c.ellipse(rSize * .2, h * .5 - rSize * .8, rSize * 1.2, rSize * 1.2);
    c.stroke();
    c.begin();
    c.moveTo(rSize * 1.15, h * .5 + rSize * .25);
    c.lineTo(rSize * 1.6, h * .5 + rSize * .8);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IHOME_PAGE_CONTROL, mxShapeMockupiHomePageControl);
function mxShapeMockupiPageControl(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiPageControl, mxShape);
mxShapeMockupiPageControl.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#000000");
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    var rSize = Math.min(h * .5, w * .05);
    c.setFillColor(strokeColor);
    c.ellipse(0, h * .5 - rSize, 2 * rSize, 2 * rSize);
    c.fill();
    c.setFillColor(fillColor);
    c.ellipse(w * .35 - rSize, h * .5 - rSize, 2 * rSize, 2 * rSize);
    c.fill();
    c.ellipse(w * .65 - rSize, h * .5 - rSize, 2 * rSize, 2 * rSize);
    c.fill();
    c.ellipse(w - 2 * rSize, h * .5 - rSize, 2 * rSize, 2 * rSize);
    c.fill()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IPAGE_CONTROL, mxShapeMockupiPageControl);
function mxShapeMockupiPad(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupiPad, mxShape);
mxShapeMockupiPad.prototype.paintVertexShape = function(c, x, y, w, h) {
    var rSize = 25;
    c.translate(x, y);
    this.background(c, x, y, w, h, rSize);
    c.setShadow(false);
    this.foreground(c, x, y, w, h, rSize)
}
;
mxShapeMockupiPad.prototype.background = function(c, x, y, w, h, rSize) {
    c.setFillColor("#000000");
    c.setStrokeColor("#000000");
    c.roundrect(0, 0, w, h, rSize, rSize);
    c.fillAndStroke()
}
;
mxShapeMockupiPad.prototype.foreground = function(c, x, y, w, h, rSize) {
    c.setStrokeWidth(1.5);
    c.setStrokeColor("#999999");
    c.begin();
    c.setStrokeColor("none");
    c.setFillColor("#808080");
    c.setGradient("#808080", "#000000", w * .325, 0, w * .675, h * .5, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.moveTo(w * .325, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, h * .5);
    c.lineTo(w * .7, h * .5);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.setFillColor("#1f2923");
    c.setStrokeColor("#18211b");
    c.setStrokeWidth(1);
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "");
    var bgStyle = mxUtils.getValue(this.style, mxMockupC.BG_STYLE, mxMockupC.BG_FLAT_GREEN);
    c.setStrokeWidth(1);
    if (bgStyle === mxMockupC.BG_FLAT_WHITE) {
        c.setFillColor("#ffffff");
        c.rect(w * .0928, h * .08, w * .8144, h * .816);
        c.fill()
    } else if (bgStyle === mxMockupC.BG_FLAT_GREEN) {
        c.setFillColor("#1f2923");
        c.rect(w * .0928, h * .08, w * .8144, h * .816);
        c.fill()
    } else if (bgStyle === mxMockupC.BG_FLAT_GRAY) {
        c.setFillColor("#dddddd");
        c.rect(w * .0928, h * .08, w * .8144, h * .816);
        c.fill()
    } else if (bgStyle === mxMockupC.BG_FLAT_CUSTOM) {
        c.setFillColor(fillColor);
        c.rect(w * .0928, h * .08, w * .8144, h * .816);
        c.fill()
    } else if (bgStyle === mxMockupC.BG_STRIPED) {
        var xOld = x;
        var yOld = y;
        var wOld = w;
        var hOld = h;
        c.translate(w * .0928, h * .08);
        w = w * .8144;
        h = h * .816;
        c.setFillColor("#5D7585");
        c.rect(0, 0, w, h);
        c.fillAndStroke();
        var strokeColor = "#18211b";
        var strokeColor2 = "#657E8F";
        c.setStrokeColor(strokeColor2);
        var i = 7;
        c.begin();
        while (i < w) {
            c.moveTo(i, 0);
            c.lineTo(i, h);
            i = i + 7
        }
        c.stroke();
        c.setStrokeColor(strokeColor);
        c.begin();
        c.rect(0, 0, w, h);
        c.stroke();
        w = wOld;
        h = hOld;
        c.translate(-w * .0928, -h * .08)
    } else if (bgStyle === mxMockupC.BG_MAP) {
        var xOld = x;
        var yOld = y;
        var wOld = w;
        var hOld = h;
        c.translate(w * .0928, h * .08);
        w = w * .8144;
        h = h * .816;
        c.setFillColor("#ffffff");
        c.rect(0, 0, w, h);
        c.fillAndStroke();
        var fillColor2 = "#96D1FF";
        var strokeColor = "#18211b";
        var strokeColor2 = "#008cff";
        c.setFillColor(fillColor2);
        c.setStrokeColor(strokeColor2);
        c.setStrokeWidth(.5);
        c.begin();
        c.moveTo(0, 0);
        c.lineTo(w * .1171, 0);
        c.lineTo(w * .1136, h * .0438);
        c.lineTo(w * .0993, h * .054);
        c.lineTo(0, h * .0446);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .1993, 0);
        c.lineTo(w * .1914, h * .03884);
        c.lineTo(w * .1536, h * .0362);
        c.lineTo(w * .1586, 0);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .24, 0);
        c.lineTo(w * .2257, h * .054);
        c.lineTo(w * .2414, h * .0674);
        c.lineTo(w * .4707, h * .0835);
        c.lineTo(w * .5264, h * .0906);
        c.lineTo(w * .6429, h * .0929);
        c.arcTo(w * .0857, h * .0536, 0, 0, 0, w * .7193, h * .0621);
        c.arcTo(w * .48, h * .2143, 0, 0, 0, w * .7286, 0);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .8, 0);
        c.lineTo(w * .7886, h * .04554);
        c.arcTo(w * .0857, h * .0536, 0, 0, 0, w * .8164, h * .0875);
        c.arcTo(w * .1429, h * .0893, 0, 0, 0, w * .88, h * .1036);
        c.lineTo(w, h * .1112);
        c.lineTo(w, 0);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(0, h * .0933);
        c.lineTo(w * .08, h * .1036);
        c.lineTo(w * .1021, h * .1246);
        c.lineTo(w * .1007, h * .1768);
        c.lineTo(w * .0471, h * .2241);
        c.lineTo(0, h * .2527);
        c.close();
        c.fillAndStroke();
        c.ellipse(w * .1214, h * .0603, w * .0843, h * .0576);
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .1293, h * .1924);
        c.lineTo(w * .1729, h * .142);
        c.lineTo(w * .1407, h * .1411);
        c.lineTo(w * .14, h * .1777);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .4586, h * .1241);
        c.lineTo(w * .455, h * .1835);
        c.lineTo(w * .3893, h * .2246);
        c.lineTo(w * .2171, h * .1362);
        c.lineTo(w * .2171, h * .1308);
        c.lineTo(w * .2293, h * .1214);
        c.lineTo(w * .2857, h * .1174);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .5079, h * .1134);
        c.lineTo(w * .7307, h * .1223);
        c.lineTo(w * .7279, h * .1625);
        c.lineTo(w * .715, h * .1772);
        c.lineTo(w * .6929, h * .1688);
        c.lineTo(w * .625, h * .1795);
        c.lineTo(w * .4779, h * .2835);
        c.lineTo(w * .395, h * .2299);
        c.lineTo(w * .4657, h * .1826);
        c.lineTo(w * .4707, h * .1223);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w, h * .1362);
        c.lineTo(w * .7643, h * .1237);
        c.lineTo(w * .7543, h * .1562);
        c.lineTo(w * .7643, h * .1585);
        c.lineTo(w * .9186, h * .2366);
        c.lineTo(w, h * .1732);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .2079, h * .1545);
        c.lineTo(w * .3886, h * .2536);
        c.lineTo(w * .3414, h * .2933);
        c.lineTo(w * .1743, h * .1969);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .1579, h * .2134);
        c.lineTo(w * .3221, h * .3067);
        c.lineTo(w * .2957, h * .3237);
        c.lineTo(w * .1157, h * .2424);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .405, h * .2656);
        c.lineTo(w * .31, h * .3353);
        c.lineTo(w * .3693, h * .3661);
        c.lineTo(w * .4571, h * .2982);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .7121, h * .1848);
        c.lineTo(w * .6879, h * .1754);
        c.lineTo(w * .6329, h * .1844);
        c.lineTo(w * .61, h * .2018);
        c.lineTo(w * .6207, h * .2085);
        c.lineTo(w * .4986, h * .2982);
        c.lineTo(w * .535, h * .3237);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .5557, h * .3379);
        c.lineTo(w * .7464, h * .1826);
        c.lineTo(w * .8036, h * .2076);
        c.lineTo(w * .595, h * .3616);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .8293, h * .2188);
        c.lineTo(w * .8979, h * .2509);
        c.lineTo(w * .6936, h * .4125);
        c.lineTo(w * .6171, h * .3737);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w, h * .2138);
        c.lineTo(w * .6821, h * .4603);
        c.lineTo(w * .815, h * .5277);
        c.lineTo(w, h * .4);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(0, h * .317);
        c.lineTo(w * .0971, h * .2554);
        c.lineTo(w * .4121, h * .4143);
        c.lineTo(w * .3736, h * .4415);
        c.lineTo(w * .315, h * .4076);
        c.lineTo(w * .3093, h * .4116);
        c.lineTo(w * .3686, h * .4455);
        c.lineTo(w * .285, h * .5045);
        c.lineTo(w * .1114, h * .4134);
        c.lineTo(w * .025, h * .4603);
        c.lineTo(w * .0371, h * .4723);
        c.lineTo(w * .1114, h * .4371);
        c.lineTo(w * .2871, h * .5312);
        c.lineTo(w * .1929, h * .6058);
        c.lineTo(w * .2271, h * .6705);
        c.lineTo(w * .17, h * .7147);
        c.lineTo(w * .0314, h * .6321);
        c.lineTo(0, h * .6246);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .48, h * .3121);
        c.lineTo(w * .5157, h * .3375);
        c.lineTo(w * .4314, h * .3982);
        c.lineTo(w * .3929, h * .3786);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .3086, h * .5179);
        c.lineTo(w * .53, h * .3518);
        c.lineTo(w * .5757, h * .3745);
        c.lineTo(w * .3479, h * .5411);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .5964, h * .3884);
        c.lineTo(w * .6736, h * .4277);
        c.lineTo(w * .445, h * .5991);
        c.lineTo(w * .3664, h * .5531);
        c.lineTo(w * .5057, h * .4545);
        c.lineTo(w * .5507, h * .4754);
        c.lineTo(w * .5571, h * .4723);
        c.lineTo(w * .5114, h * .4504);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .4793, h * .6161);
        c.lineTo(w * .6771, h * .4643);
        c.lineTo(w * .8086, h * .5326);
        c.lineTo(w * .7471, h * .5817);
        c.lineTo(w * .7214, h * .567);
        c.lineTo(w * .715, h * .571);
        c.lineTo(w * .7421, h * .5871);
        c.lineTo(w * .6014, h * .6933);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w, h * .4371);
        c.lineTo(w * .8443, h * .546);
        c.lineTo(w * .9071, h * .5701);
        c.lineTo(w, h * .5022);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .8407, h * .5504);
        c.lineTo(w * .8993, h * .5759);
        c.lineTo(w * .6757, h * .7416);
        c.lineTo(w * .6286, h * .7139);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w, h * .5321);
        c.lineTo(w * .6979, h * .7549);
        c.lineTo(w * .7457, h * .7781);
        c.lineTo(w * .9814, h * .6094);
        c.lineTo(w, h * .6067);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w, h * .6254);
        c.lineTo(w * .7664, h * .792);
        c.lineTo(w * .9586, h * .9062);
        c.lineTo(w, h * .8786);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .3093, h * .5464);
        c.lineTo(w * .4271, h * .6152);
        c.lineTo(w * .245, h * .7643);
        c.lineTo(w * .185, h * .7228);
        c.lineTo(w * .2493, h * .6728);
        c.lineTo(w * .2214, h * .6143);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(0, h * .65);
        c.lineTo(w * .2179, h * .7826);
        c.lineTo(w * .1136, h * .8424);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(0, h * .7272);
        c.lineTo(w * .0821, h * .859);
        c.lineTo(0, h * .9085);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .4529, h * .6366);
        c.lineTo(w * .575, h * .7143);
        c.lineTo(w * .39, h * .8621);
        c.lineTo(w * .2657, h * .7902);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(0, h * .9415);
        c.lineTo(w * .1036, h * .8821);
        c.lineTo(w * .2343, h * .959);
        c.lineTo(w * .1721, h);
        c.lineTo(0, h);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .2586, h * .7951);
        c.lineTo(w * .3829, h * .8674);
        c.lineTo(w * .2543, h * .9451);
        c.lineTo(w * .1279, h * .8692);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .2836, h * .9639);
        c.lineTo(w * .4207, h * .8772);
        c.lineTo(w * .605, h * .7321);
        c.lineTo(w * .6521, h * .7634);
        c.lineTo(w * .3486, h);
        c.lineTo(w * .3393, h);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .3879, h);
        c.lineTo(w * .6721, h * .7759);
        c.lineTo(w * .7171, h * .7982);
        c.lineTo(w * .4564, h);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .4986, h);
        c.lineTo(w * .7386, h * .8125);
        c.lineTo(w * .9307, h * .925);
        c.lineTo(w * .8264, h);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .8671, h);
        c.lineTo(w * .9464, h * .9491);
        c.lineTo(w, h * .975);
        c.lineTo(w, h);
        c.close();
        c.fillAndStroke();
        c.begin();
        c.moveTo(w * .2295, h);
        c.lineTo(w * .2648, h * .9792);
        c.lineTo(w * .2981, h);
        c.close();
        c.fillAndStroke();
        w = wOld;
        h = hOld;
        c.translate(-w * .0928, -h * .08)
    }
    c.setStrokeWidth(1);
    c.setStrokeColor("#18211b");
    c.rect(w * .0928, h * .08, w * .8144, h * .816);
    c.stroke();
    c.setStrokeWidth(1.5);
    c.setAlpha(.8);
    c.setStrokeColor("#dddddd");
    c.begin();
    c.moveTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, h - rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
    c.lineTo(rSize, h);
    c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
    c.close();
    c.stroke();
    rSize = 22.5;
    c.begin();
    c.setStrokeColor("#666666");
    c.begin();
    c.moveTo(2.5, 2.5 + rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, 2.5 + rSize, 2.5);
    c.lineTo(w - rSize - 5, 2.5);
    c.arcTo(rSize, rSize, 0, 0, 1, w - 2.5, rSize + 2.5);
    c.lineTo(w - 2.5, h - rSize - 2.5);
    c.arcTo(rSize, rSize, 0, 0, 1, w - rSize - 2.5, h - 2.5);
    c.lineTo(rSize + 2.5, h - 2.5);
    c.arcTo(rSize, rSize, 0, 0, 1, 2.5, h - rSize - 2.5);
    c.close();
    c.stroke();
    c.setAlpha(1);
    c.ellipse(w * .4948, h * .0444, w * .0103, h * .008);
    c.setStrokeWidth(2.5);
    c.setStrokeColor("#000000");
    c.setFillColor("#000099");
    c.fillAndStroke();
    c.setGradient("#bbbbbb", "#000000", w * .4588, h * .912, w * .0825, h * .064, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.ellipse(w * .4588, h * .912, w * .0825, h * .064);
    c.fill();
    c.setAlpha(.5);
    c.ellipse(w * .4588, h * .912, w * .0825, h * .064);
    c.stroke();
    c.begin();
    c.setAlpha(.85);
    c.setFillColor("#000000");
    c.moveTo(w * .4598, h * .944);
    c.arcTo(w * .0402, h * .0296, 0, 0, 1, w * .5402, h * .944);
    c.arcTo(w * .0825, h * .064, 0, 0, 1, w * .4598, h * .944);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.setAlpha(.7);
    c.setStrokeWidth(1.5);
    c.setStrokeColor("#dddddd");
    rSize = 4;
    c.roundrect(w * .4814, h * .9296, w * .0371, h * .0288, h * .00515, h * .004);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxMockupC.SHAPE_IPAD, mxShapeMockupiPad);
function mxShapeMockupRRect(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupRRect, mxShape);
mxShapeMockupRRect.prototype.cst = {
    RRECT: "mxgraph.ios.rrect",
    R_SIZE: "rSize"
};
mxShapeMockupRRect.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupRRect.prototype.cst.R_SIZE, "10"));
    c.roundrect(0, 0, w, h, rSize);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupRRect.prototype.cst.RRECT, mxShapeMockupRRect);
function mxShapeIosTopButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeIosTopButton, mxShape);
mxShapeIosTopButton.prototype.cst = {
    TOP_BUTTON: "mxgraph.ios.topButton",
    R_SIZE: "rSize"
};
mxShapeIosTopButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeIosTopButton.prototype.cst.R_SIZE, "10"));
    c.begin();
    c.moveTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeIosTopButton.prototype.cst.TOP_BUTTON, mxShapeIosTopButton);
function mxShapeIosBottomButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeIosBottomButton, mxShape);
mxShapeIosBottomButton.prototype.cst = {
    BOTTOM_BUTTON: "mxgraph.ios.bottomButton",
    R_SIZE: "rSize"
};
mxShapeIosBottomButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeIosBottomButton.prototype.cst.R_SIZE, "10"));
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h - rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
    c.lineTo(rSize, h);
    c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeIosBottomButton.prototype.cst.BOTTOM_BUTTON, mxShapeIosBottomButton);
function mxShapeIosAnchor(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds
}
mxUtils.extend(mxShapeIosAnchor, mxShape);
mxShapeIosAnchor.prototype.cst = {
    ANCHOR: "mxgraph.ios.anchor"
};
mxShapeIosAnchor.prototype.paintVertexShape = function(c, x, y, w, h) {}
;
mxCellRenderer.registerShape(mxShapeIosAnchor.prototype.cst.ANCHOR, mxShapeIosAnchor);
function mxShapeIosCheckbox(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeIosCheckbox, mxShape);
mxShapeIosCheckbox.prototype.cst = {
    CHECKBOX: "mxgraph.ios.checkbox"
};
mxShapeIosCheckbox.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.rect(0, 0, w, h);
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .8, h * .2);
    c.lineTo(w * .4, h * .8);
    c.lineTo(w * .25, h * .6);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeIosCheckbox.prototype.cst.CHECKBOX, mxShapeIosCheckbox);
function mxShapeMockupFancyRRect(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeMockupFancyRRect, mxShape);
mxShapeMockupFancyRRect.prototype.cst = {
    FANCY_RRECT: "mxgraph.ios.fancyRRect",
    R_SIZE: "rSize"
};
mxShapeMockupFancyRRect.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeMockupFancyRRect.prototype.cst.R_SIZE, "10"));
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    c.roundrect(0, 0, w, h, rSize);
    c.fillAndStroke();
    c.setShadow(false);
    c.setStrokeColor(fillColor);
    c.setGradient(fillColor, "#ffffff", 0, 0, w, 22.5, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.setAlpha(.3);
    c.begin();
    c.moveTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, 17.5);
    c.arcTo(w * 1.67, h * 2.5, 0, 0, 1, 0, 17.5);
    c.lineTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.close();
    c.fillAndStroke();
    c.setAlpha(.8);
    c.setStrokeColor(strokeColor);
    c.setStrokeWidth(1);
    c.roundrect(0, 0, w, h, rSize, rSize);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeMockupFancyRRect.prototype.cst.FANCY_RRECT, mxShapeMockupFancyRRect);
function mxShapeAws3dArrowNE(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dArrowNE, mxShape);
mxShapeAws3dArrowNE.prototype.cst = {
    ARROW_NE: "mxgraph.aws3d.arrowNE"
};
mxShapeAws3dArrowNE.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.moveTo(w - 17, 8);
    c.lineTo(w - 21, 5.5);
    c.lineTo(w, 0);
    c.lineTo(w - 9.7, 12.2);
    c.lineTo(w - 13.9, 9.8);
    c.lineTo(9.7, h - 3.5);
    c.arcTo(6, 3, 0, 0, 1, 9, h - .4);
    c.arcTo(5.2, 3, 0, 0, 1, 1, h - 1.4);
    c.arcTo(6, 2.8, 0, 0, 1, 3, h - 5.4);
    c.arcTo(5, 3, 0, 0, 1, 6.7, h - 5.2);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dArrowNE.prototype.cst.ARROW_NE, mxShapeAws3dArrowNE);
function mxShapeAws3dArrowSE(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dArrowSE, mxShape);
mxShapeAws3dArrowSE.prototype.cst = {
    ARROW_SE: "mxgraph.aws3d.arrowSE"
};
mxShapeAws3dArrowSE.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.moveTo(w - 17, h - 8);
    c.lineTo(w - 21, h - 5.5);
    c.lineTo(w, h);
    c.lineTo(w - 9.7, h - 12.2);
    c.lineTo(w - 13.9, h - 9.8);
    c.lineTo(9.7, 3.5);
    c.arcTo(6, 3, 0, 0, 0, 9, .4);
    c.arcTo(5.2, 3, 0, 0, 0, 1, 1.4);
    c.arcTo(6, 2.8, 0, 0, 0, 3, 5.4);
    c.arcTo(5, 3, 0, 0, 0, 6.7, 5.2);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dArrowSE.prototype.cst.ARROW_SE, mxShapeAws3dArrowSE);
function mxShapeAws3dArrowSW(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dArrowSW, mxShape);
mxShapeAws3dArrowSW.prototype.cst = {
    ARROW_SW: "mxgraph.aws3d.arrowSW"
};
mxShapeAws3dArrowSW.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.moveTo(17, h - 8);
    c.lineTo(21, h - 5.5);
    c.lineTo(0, h);
    c.lineTo(9.7, h - 12.2);
    c.lineTo(13.9, h - 9.8);
    c.lineTo(w - 9.7, 3.5);
    c.arcTo(6, 3, 0, 0, 1, w - 9, .4);
    c.arcTo(5.2, 3, 0, 0, 1, w - 1, 1.4);
    c.arcTo(6, 2.8, 0, 0, 1, w - 3, 5.4);
    c.arcTo(5, 3, 0, 0, 1, w - 6.7, 5.2);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dArrowSW.prototype.cst.ARROW_SW, mxShapeAws3dArrowSW);
function mxShapeAws3dArrowNW(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dArrowNW, mxShape);
mxShapeAws3dArrowNW.prototype.cst = {
    ARROW_NW: "mxgraph.aws3d.arrowNW"
};
mxShapeAws3dArrowNW.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.moveTo(17, 8);
    c.lineTo(21, 5.5);
    c.lineTo(0, 0);
    c.lineTo(9.7, 12.2);
    c.lineTo(13.9, 9.8);
    c.lineTo(w - 9.7, h - 3.5);
    c.arcTo(6, 3, 0, 0, 0, w - 9, h - .4);
    c.arcTo(5.2, 3, 0, 0, 0, w - 1, h - 1.4);
    c.arcTo(6, 2.8, 0, 0, 0, w - 3, h - 5.4);
    c.arcTo(5, 3, 0, 0, 0, w - 6.7, h - 5.2);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dArrowNW.prototype.cst.ARROW_NW, mxShapeAws3dArrowNW);
function mxShapeAws3dArrowlessNE(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dArrowlessNE, mxShape);
mxShapeAws3dArrowlessNE.prototype.cst = {
    ARROWLESS_NE: "mxgraph.aws3d.arrowlessNE"
};
mxShapeAws3dArrowlessNE.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.moveTo(w - 3.1, 0);
    c.lineTo(w, 1.8);
    c.lineTo(9.7, h - 3.5);
    c.arcTo(6, 3, 0, 0, 1, 9, h - .4);
    c.arcTo(5.2, 3, 0, 0, 1, 1, h - 1.4);
    c.arcTo(6, 2.8, 0, 0, 1, 3, h - 5.4);
    c.arcTo(5, 3, 0, 0, 1, 6.7, h - 5.2);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dArrowlessNE.prototype.cst.ARROWLESS_NE, mxShapeAws3dArrowlessNE);
function mxShapeAws3dDashedEdgeDouble(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dDashedEdgeDouble, mxShape);
mxShapeAws3dDashedEdgeDouble.prototype.cst = {
    DASHED_EDGE_DOUBLE: "mxgraph.aws3d.dashedEdgeDouble"
};
mxShapeAws3dDashedEdgeDouble.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.setFillColor("#2D6195");
    c.save();
    c.setStrokeColor("none");
    c.begin();
    c.moveTo(21, 5.5);
    c.lineTo(0, 0);
    c.lineTo(9.7, 12.2);
    c.fillAndStroke();
    c.begin();
    c.moveTo(w - 21, h - 5.5);
    c.lineTo(w, h);
    c.lineTo(w - 9.7, h - 12.2);
    c.fillAndStroke();
    c.restore();
    c.setStrokeColor("#2D6195");
    c.setStrokeWidth("4");
    c.setDashed("true");
    c.setLineCap("round");
    c.begin();
    c.moveTo(7.675, 4.425);
    c.lineTo(w - 7.675, h - 4.425);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dDashedEdgeDouble.prototype.cst.DASHED_EDGE_DOUBLE, mxShapeAws3dDashedEdgeDouble);
function mxShapeAws3dDashedArrowlessEdge(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dDashedArrowlessEdge, mxShape);
mxShapeAws3dDashedArrowlessEdge.prototype.cst = {
    DASHED_ARROWLESS_EDGE: "mxgraph.aws3d.dashedArrowlessEdge"
};
mxShapeAws3dDashedArrowlessEdge.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.setStrokeColor("#2D6195");
    c.setStrokeWidth("4");
    c.setDashed("true");
    c.setLineCap("round");
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dDashedArrowlessEdge.prototype.cst.DASHED_ARROWLESS_EDGE, mxShapeAws3dDashedArrowlessEdge);
function mxShapeAws3dDashedEdge(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dDashedEdge, mxShape);
mxShapeAws3dDashedEdge.prototype.cst = {
    DASHED_EDGE: "mxgraph.aws3d.dashedEdge"
};
mxShapeAws3dDashedEdge.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.setFillColor("#2D6195");
    c.save();
    c.setStrokeColor("none");
    c.begin();
    c.moveTo(w - 21, 5.5);
    c.lineTo(w, 0);
    c.lineTo(w - 9.7, 12.2);
    c.fillAndStroke();
    c.restore();
    c.setStrokeColor("#2D6195");
    c.setStrokeWidth("4");
    c.setDashed("true");
    c.setLineCap("round");
    c.begin();
    c.moveTo(w - 7.675, 4.425);
    c.lineTo(0, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dDashedEdge.prototype.cst.DASHED_EDGE, mxShapeAws3dDashedEdge);
function mxShapeAws3dFlatEdge(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dFlatEdge, mxShape);
mxShapeAws3dFlatEdge.prototype.cst = {
    FLAT_EDGE: "mxgraph.aws3d.flatEdge"
};
mxShapeAws3dFlatEdge.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.setFillColor("#F4B934");
    c.setStrokeColor("none");
    c.begin();
    c.moveTo(w - 46, 8.8);
    c.lineTo(w - 61.2, 0);
    c.lineTo(w, 0);
    c.lineTo(w, 35.5);
    c.lineTo(w - 15.4, 26.5);
    c.lineTo(30.7, h);
    c.lineTo(0, h - 17.7);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dFlatEdge.prototype.cst.FLAT_EDGE, mxShapeAws3dFlatEdge);
function mxShapeAws3dFlatDoubleEdge(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dFlatDoubleEdge, mxShape);
mxShapeAws3dFlatDoubleEdge.prototype.cst = {
    FLAT_DOUBLE_EDGE: "mxgraph.aws3d.flatDoubleEdge"
};
mxShapeAws3dFlatDoubleEdge.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.setFillColor("#F4B934");
    c.setStrokeColor("none");
    c.begin();
    c.moveTo(15.3, 61.9);
    c.lineTo(30.8, 53.2);
    c.lineTo(15.4, 44.2);
    c.lineTo(0, 53.2);
    c.lineTo(15.4, 8.8);
    c.lineTo(92.1, 0);
    c.lineTo(76.5, 8.8);
    c.lineTo(92.1, 17.7);
    c.lineTo(107.4, 8.8);
    c.lineTo(w - 15.3, h - 61.9);
    c.lineTo(w - 30.8, h - 53.2);
    c.lineTo(w - 15.4, h - 44.2);
    c.lineTo(w, h - 53.2);
    c.lineTo(w - 15.4, h - 8.8);
    c.lineTo(w - 92.1, h);
    c.lineTo(w - 76.5, h - 8.8);
    c.lineTo(w - 92.1, h - 17.7);
    c.lineTo(w - 107.4, h - 8.8);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dFlatDoubleEdge.prototype.cst.FLAT_DOUBLE_EDGE, mxShapeAws3dFlatDoubleEdge);
function mxShapeAws3dAMI(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dAMI, mxShape);
mxShapeAws3dAMI.prototype.cst = {
    AMI: "mxgraph.aws3d.ami",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dAMI.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var isShadow = parseFloat(mxUtils.getValue(this.state.style, "shadow", "0"));
    var strokeWidth1 = strokeWidth * w / 92;
    var strokeWidth2 = strokeWidth * h / 60;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    c.setStrokeWidth(strokeWidth);
    c.setShadow(false);
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    if (isShadow == 1)
        c.setShadow(true);
    c.begin();
    c.moveTo(0, h * .6483);
    c.lineTo(w * .0684, h * .4133);
    c.lineTo(w * .5326, 0);
    c.lineTo(w * .6685, 0);
    c.lineTo(w * .9359, h * .2367);
    c.lineTo(w, h * .465);
    c.lineTo(w * .4, h);
    c.close();
    c.fillAndStroke();
    c.restore();
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dAMI.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(0, h * .65);
    c.lineTo(w * .0652, h * .5);
    c.lineTo(w * .3326, h * .7667);
    c.lineTo(w * .4663, h * .7667);
    c.lineTo(w * .4, h);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .4, h);
    c.lineTo(w * .4641, h * .77);
    c.lineTo(w * .9326, h * .355);
    c.lineTo(w * .9347, h * .24);
    c.lineTo(w, h * .4667);
    c.close();
    c.fill();
    c.restore();
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .65);
    c.lineTo(w * .0652, h * .5);
    c.lineTo(w * .3326, h * .7667);
    c.lineTo(w * .4663, h * .7667);
    c.lineTo(w * .4, h);
    c.close();
    c.stroke();
    c.begin();
    c.moveTo(w * .4, h);
    c.lineTo(w * .4641, h * .77);
    c.lineTo(w * .9326, h * .355);
    c.lineTo(w * .9347, h * .24);
    c.lineTo(w, h * .4667);
    c.close();
    c.stroke();
    c.begin();
    c.moveTo(w * .0652, h * .42);
    c.lineTo(w * .0652, h * .5);
    c.moveTo(w * .3337, h * .7667);
    c.lineTo(w * .4, h);
    c.moveTo(w * .9348, h * .355);
    c.lineTo(w, h * .4733);
    c.stroke();
    c.setLineJoin("miter");
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .1935, h * .42);
    c.lineTo(w * .5543, h * .0967);
    c.lineTo(w * .6652, h * .1967);
    c.lineTo(w * .3, h * .5133);
    c.close();
    c.moveTo(w * .2967, h * .4633);
    c.lineTo(w * .3837, h * .3883);
    c.lineTo(w * .3326, h * .3417);
    c.lineTo(w * .2467, h * .42);
    c.close();
    c.moveTo(w * .362, h * .32);
    c.lineTo(w * .412, h * .3633);
    c.lineTo(w * .5054, h * .2867);
    c.lineTo(w * .4522, h * .24);
    c.close();
    c.moveTo(w * .5293, h * .26);
    c.lineTo(w * .6109, h * .1933);
    c.lineTo(w * .5511, h * .145);
    c.lineTo(w * .4739, h * .2133);
    c.close();
    c.moveTo(w * .3528, h * .557);
    c.lineTo(w * .7137, h * .2337);
    c.lineTo(w * .8246, h * .3337);
    c.lineTo(w * .4593, h * .6503);
    c.close();
    c.moveTo(w * .4561, h * .6003);
    c.lineTo(w * .543, h * .5253);
    c.lineTo(w * .492, h * .4787);
    c.lineTo(w * .4061, h * .557);
    c.close();
    c.moveTo(w * .5213, h * .457);
    c.lineTo(w * .5713, h * .5003);
    c.lineTo(w * .6648, h * .4237);
    c.lineTo(w * .6115, h * .377);
    c.close();
    c.moveTo(w * .6887, h * .397);
    c.lineTo(w * .7702, h * .3303);
    c.lineTo(w * .7104, h * .282);
    c.lineTo(w * .6333, h * .3503);
    c.close();
    c.fill();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .6483);
    c.lineTo(w * .0684, h * .4133);
    c.lineTo(w * .5326, 0);
    c.lineTo(w * .6685, 0);
    c.lineTo(w * .9359, h * .2367);
    c.lineTo(w, h * .465);
    c.lineTo(w * .4, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dAMI.prototype.cst.AMI, mxShapeAws3dAMI);
function mxShapeAws3dSnapshot(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dSnapshot, mxShape);
mxShapeAws3dSnapshot.prototype.cst = {
    SNAPSHOT: "mxgraph.aws3d.snapshot",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dSnapshot.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 92;
    var strokeWidth2 = strokeWidth * h / 60;
    var isShadow = parseFloat(mxUtils.getValue(this.state.style, "shadow", "0"));
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    c.setStrokeWidth(strokeWidth);
    c.setShadow(false);
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    if (isShadow == 1)
        c.setShadow(true);
    c.begin();
    c.moveTo(w, h * .6483);
    c.lineTo(w * .9316, h * .4133);
    c.lineTo(w * .4674, 0);
    c.lineTo(w * .3315, 0);
    c.lineTo(w * .0641, h * .2367);
    c.lineTo(0, h * .465);
    c.lineTo(w * .6, h);
    c.close();
    c.fillAndStroke();
    c.restore();
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dSnapshot.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w, h * .65);
    c.lineTo(w * .9348, h * .52);
    c.lineTo(w * .6674, h * .7667);
    c.lineTo(w * .5337, h * .7667);
    c.lineTo(w * .6, h);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(w * .6, h);
    c.lineTo(w * .5359, h * .77);
    c.lineTo(w * .0674, h * .355);
    c.lineTo(w * .0653, h * .24);
    c.lineTo(0, h * .4667);
    c.close();
    c.fill();
    c.restore();
    c.setLineJoin("round");
    c.begin();
    c.moveTo(w, h * .65);
    c.lineTo(w * .9348, h * .52);
    c.lineTo(w * .6674, h * .7667);
    c.lineTo(w * .5337, h * .7667);
    c.lineTo(w * .6, h);
    c.close();
    c.stroke();
    c.begin();
    c.moveTo(w * .6, h);
    c.lineTo(w * .5359, h * .77);
    c.lineTo(w * .0674, h * .355);
    c.lineTo(w * .0653, h * .24);
    c.lineTo(0, h * .4667);
    c.close();
    c.stroke();
    c.begin();
    c.moveTo(w * .9348, h * .42);
    c.lineTo(w * .9348, h * .52);
    c.moveTo(w * .6663, h * .7667);
    c.lineTo(w * .6, h);
    c.moveTo(w * .0652, h * .355);
    c.lineTo(0, h * .4733);
    c.stroke();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(w, h * .6483);
    c.lineTo(w * .9316, h * .4133);
    c.lineTo(w * .4674, 0);
    c.lineTo(w * .3315, 0);
    c.lineTo(w * .0641, h * .2367);
    c.lineTo(0, h * .465);
    c.lineTo(w * .6, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dSnapshot.prototype.cst.SNAPSHOT, mxShapeAws3dSnapshot);
function mxShapeAws3dApplication(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dApplication, mxShape);
mxShapeAws3dApplication.prototype.cst = {
    APPLICATION: "mxgraph.aws3d.application",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dApplication.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 62;
    var strokeWidth2 = strokeWidth * h / 68.8;
    var isShadow = parseFloat(mxUtils.getValue(this.state.style, "shadow", "0"));
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    c.setShadow(false);
    c.setStrokeWidth(strokeWidth);
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    if (isShadow == 1)
        c.setShadow(true);
    c.begin();
    c.moveTo(0, h * .2544);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h * .2544);
    c.lineTo(w, h * .7485);
    c.lineTo(w * .5, h);
    c.lineTo(0, h * .7485);
    c.close();
    c.fillAndStroke();
    c.restore();
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dApplication.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(0, h * .2544);
    c.lineTo(w * .5, h * .5015);
    c.lineTo(w * .5, h);
    c.lineTo(0, h * .7485);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .5, h * .5015);
    c.lineTo(w, h * .2544);
    c.lineTo(w, h * .7485);
    c.lineTo(w * .5, h);
    c.close();
    c.fill();
    c.restore();
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .2544);
    c.lineTo(w * .5, h * .5015);
    c.lineTo(w * .5, h);
    c.lineTo(0, h * .7485);
    c.close();
    c.stroke();
    c.begin();
    c.moveTo(w * .5, h * .5015);
    c.lineTo(w, h * .2544);
    c.lineTo(w, h * .7485);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke();
    c.setLineJoin("miter");
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .6694, h * .0872);
    c.lineTo(w * .7629, h * .1337);
    c.lineTo(w * .2661, h * .3882);
    c.lineTo(w * .2661, h * .5407);
    c.lineTo(w * .1742, h * .4953);
    c.lineTo(w * .1742, h * .3459);
    c.close();
    c.moveTo(w * .8629, h * .1846);
    c.lineTo(w * .379, h * .4331);
    c.lineTo(w * .379, h * .5945);
    c.lineTo(w * .2855, h * .5494);
    c.lineTo(w * .2855, h * .3953);
    c.lineTo(w * .7839, h * .1439);
    c.close();
    c.fill();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .2544);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h * .2544);
    c.lineTo(w, h * .7485);
    c.lineTo(w * .5, h);
    c.lineTo(0, h * .7485);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dApplication.prototype.cst.APPLICATION, mxShapeAws3dApplication);
function mxShapeAws3dApplicationServer(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dApplicationServer, mxShape);
mxShapeAws3dApplicationServer.prototype.cst = {
    APPLICATION_SERVER: "mxgraph.aws3d.application_server",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dApplicationServer.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 123;
    var strokeWidth2 = strokeWidth * h / 124;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    this.background(c, 0, 0, w, h, strokeWidth);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h, strokeWidth)
}
;
mxShapeAws3dApplicationServer.prototype.background = function(c, x, y, w, h, strokeWidth) {
    c.setStrokeWidth(strokeWidth);
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .7236);
    c.lineTo(0, h * .2863);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h * .2863);
    c.lineTo(w, h * .7236);
    c.lineTo(w * .5, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeAws3dApplicationServer.prototype.foreground = function(c, x, y, w, h, strokeWidth) {
    c.restore();
    c.setShadow(false);
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dApplicationServer.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(0, h * .2863);
    c.lineTo(w * .5, h * .5726);
    c.lineTo(w * .5, h);
    c.lineTo(0, h * .7177);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w, h * .2863);
    c.lineTo(w * .5, h * .5726);
    c.lineTo(w * .5, h);
    c.lineTo(w, h * .7177);
    c.close();
    c.fill();
    c.restore();
    c.setShadow(false);
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .2863);
    c.lineTo(w * .5, h * .5726);
    c.lineTo(w * .5, h);
    c.lineTo(0, h * .7177);
    c.close();
    c.stroke();
    c.begin();
    c.moveTo(w, h * .2863);
    c.lineTo(w * .5, h * .5726);
    c.lineTo(w * .5, h);
    c.lineTo(w, h * .7177);
    c.close();
    c.stroke();
    c.setLineJoin("miter");
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .374, h * .4435);
    c.arcTo(w * .0325, h * .0202, 0, 0, 1, w * .374, h * .4153);
    c.lineTo(w * .4797, h * .3548);
    c.arcTo(w * .0325, h * .0161, 0, 0, 1, w * .5203, h * .3548);
    c.lineTo(w * .626, h * .4153);
    c.arcTo(w * .0325, h * .0202, 0, 0, 1, w * .626, h * .4411);
    c.lineTo(w * .5203, h * .5016);
    c.arcTo(w * .0325, h * .0161, 0, 0, 1, w * .4797, h * .5016);
    c.close();
    c.fill();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .7236);
    c.lineTo(0, h * .2863);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h * .2863);
    c.lineTo(w, h * .7236);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dApplicationServer.prototype.cst.APPLICATION_SERVER, mxShapeAws3dApplicationServer);
function mxShapeAws3dCloudFront(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dCloudFront, mxShape);
mxShapeAws3dCloudFront.prototype.cst = {
    CLOUDFRONT: "mxgraph.aws3d.cloudfront",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dCloudFront.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 103.8;
    var strokeWidth2 = strokeWidth * h / 169.8;
    var isShadow = parseFloat(mxUtils.getValue(this.state.style, "shadow", "0"));
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    c.setShadow(false);
    c.setStrokeWidth(strokeWidth);
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    if (isShadow == 1)
        c.setShadow(true);
    c.begin();
    c.moveTo(0, h * .7915);
    c.lineTo(0, h * .7491);
    c.lineTo(w * .0588, h * .7279);
    c.lineTo(w * .0588, h * .1036);
    c.lineTo(w * .3526, 0);
    c.lineTo(w * .9422, h * .2073);
    c.lineTo(w * .9422, h * .8316);
    c.lineTo(w, h * .8539);
    c.lineTo(w, h * .894);
    c.lineTo(w * .7013, h);
    c.lineTo(w * .5877, h);
    c.close();
    c.fillAndStroke();
    c.restore();
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dCloudFront.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(w * .0588, h * .106);
    c.lineTo(w * .6474, h * .3121);
    c.lineTo(w * .6474, h * .9352);
    c.lineTo(w * .7052, h);
    c.lineTo(w * .5915, h);
    c.lineTo(0, h * .7915);
    c.lineTo(0, h * .7491);
    c.lineTo(w * .0588, h * .7279);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .6474, h * .3121);
    c.lineTo(w * .9422, h * .2073);
    c.lineTo(w * .9422, h * .8363);
    c.lineTo(w, h * .8539);
    c.lineTo(w, h * .894);
    c.lineTo(w * .7013, h);
    c.lineTo(w * .6474, h * .9305);
    c.close();
    c.fill();
    c.restore();
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .7915);
    c.lineTo(w * .0559, h * .7291);
    c.lineTo(w * .6474, h * .9364);
    c.lineTo(w * .5896, h);
    c.moveTo(w * .6493, h * .9364);
    c.lineTo(w * .9412, h * .8333);
    c.lineTo(w, h * .894);
    c.stroke();
    c.begin();
    c.moveTo(w * .0588, h * .106);
    c.lineTo(w * .6474, h * .3121);
    c.lineTo(w * .6474, h * .9352);
    c.lineTo(w * .7052, h);
    c.lineTo(w * .5915, h);
    c.lineTo(0, h * .7915);
    c.lineTo(0, h * .7491);
    c.lineTo(w * .0588, h * .7279);
    c.close();
    c.stroke();
    c.begin();
    c.moveTo(w * .6474, h * .3121);
    c.lineTo(w * .9422, h * .2073);
    c.lineTo(w * .9422, h * .8363);
    c.lineTo(w, h * .8539);
    c.lineTo(w, h * .894);
    c.lineTo(w * .7013, h);
    c.lineTo(w * .6474, h * .9305);
    c.close();
    c.stroke();
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .3333, h * .6643);
    c.arcTo(w * .3372, h * .2061, 0, 0, 1, w * .2351, h * .6042);
    c.arcTo(w * .4528, h * .2768, 0, 0, 1, w * .1724, h * .523);
    c.lineTo(w * .2428, h * .5677);
    c.lineTo(w * .2427, h * .5895);
    c.lineTo(w * .2765, h * .5995);
    c.close();
    c.moveTo(w * .1599, h * .4935);
    c.arcTo(w * .3372, h * .2061, 0, 0, 1, w * .1522, h * .4146);
    c.arcTo(w * .1156, h * .0883, 0, 0, 1, w * .2071, h * .3486);
    c.lineTo(w * .2013, h * .4187);
    c.lineTo(w * .1859, h * .4146);
    c.lineTo(w * .1859, h * .4464);
    c.lineTo(w * .1907, h * .4493);
    c.close();
    c.moveTo(w * .2235, h * .3445);
    c.arcTo(w * .1927, h * .1767, 0, 0, 1, w * .368, h * .361);
    c.arcTo(w * .3854, h * .2356, 0, 0, 1, w * .468, h * .4299);
    c.lineTo(w * .368, h * .4034);
    c.lineTo(w * .368, h * .394);
    c.lineTo(w * .3256, h * .3799);
    c.lineTo(w * .3256, h * .3887);
    c.close();
    c.moveTo(w * .4855, h * .4499);
    c.arcTo(w * .3854, h * .2356, 0, 0, 1, w * .5337, h * .5395);
    c.arcTo(w * .3854, h * .2356, 0, 0, 1, w * .5328, h * .6302);
    c.lineTo(w * .4952, h * .5589);
    c.lineTo(w * .5019, h * .5595);
    c.lineTo(w * .5019, h * .5265);
    c.lineTo(w * .4855, h * .5194);
    c.close();
    c.moveTo(w * .5241, h * .6455);
    c.arcTo(w * .0963, h * .0589, 0, 0, 1, w * .4663, h * .682);
    c.arcTo(w * .1445, h * .0883, 0, 0, 1, w * .3642, h * .6761);
    c.lineTo(w * .4239, h * .6525);
    c.lineTo(w * .4566, h * .6643);
    c.lineTo(w * .4566, h * .6413);
    c.close();
    c.moveTo(w * .3507, h * .6667);
    c.lineTo(w * .2871, h * .5919);
    c.lineTo(w * .4123, h * .6366);
    c.close();
    c.moveTo(w * .2563, h * .5595);
    c.lineTo(w * .1753, h * .5088);
    c.lineTo(w * .2052, h * .4594);
    c.close();
    c.moveTo(w * .2139, h * .4229);
    c.lineTo(w * .2197, h * .3528);
    c.lineTo(w * .3256, h * .4028);
    c.lineTo(w * .2283, h * .4252);
    c.close();
    c.moveTo(w * .2264, h * .4417);
    c.lineTo(w * .3218, h * .4146);
    c.lineTo(w * .3353, h * .4181);
    c.lineTo(w * .3353, h * .4971);
    c.lineTo(w * .3208, h * .4912);
    c.lineTo(w * .3208, h * .4965);
    c.lineTo(w * .2264, h * .4482);
    c.close();
    c.moveTo(w * .2697, h * .5618);
    c.lineTo(w * .2245, h * .4635);
    c.lineTo(w * .2331, h * .4588);
    c.lineTo(w * .3256, h * .5112);
    c.lineTo(w * .3237, h * .5241);
    c.close();
    c.moveTo(w * .2852, h * .576);
    c.lineTo(w * .2852, h * .5654);
    c.lineTo(w * .3391, h * .53);
    c.lineTo(w * .3516, h * .5347);
    c.lineTo(w * .4133, h * .6213);
    c.close();
    c.moveTo(w * .368, h * .5141);
    c.lineTo(w * .368, h * .5088);
    c.lineTo(w * .3526, h * .5029);
    c.lineTo(w * .3526, h * .4234);
    c.lineTo(w * .3622, h * .4276);
    c.lineTo(w * .4547, h * .5177);
    c.lineTo(w * .4557, h * .5277);
    c.close();
    c.moveTo(w * .3671, h * .417);
    c.lineTo(w * .4692, h * .4411);
    c.lineTo(w * .4721, h * .52);
    c.close();
    c.moveTo(w * .368, h * .5253);
    c.lineTo(w * .4566, h * .5359);
    c.lineTo(w * .4566, h * .5453);
    c.lineTo(w * .4663, h * .5465);
    c.lineTo(w * .4335, h * .6201);
    c.lineTo(w * .422, h * .616);
    c.lineTo(w * .368, h * .5389);
    c.close();
    c.moveTo(w * .4798, h * .5583);
    c.lineTo(w * .5183, h * .629);
    c.lineTo(w * .4557, h * .6313);
    c.lineTo(w * .4557, h * .6237);
    c.lineTo(w * .447, h * .6225);
    c.close();
    c.fill();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .7915);
    c.lineTo(0, h * .7491);
    c.lineTo(w * .0588, h * .7279);
    c.lineTo(w * .0588, h * .1036);
    c.lineTo(w * .3526, 0);
    c.lineTo(w * .9422, h * .2073);
    c.lineTo(w * .9422, h * .8316);
    c.lineTo(w, h * .8539);
    c.lineTo(w, h * .894);
    c.lineTo(w * .7013, h);
    c.lineTo(w * .5877, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dCloudFront.prototype.cst.CLOUDFRONT, mxShapeAws3dCloudFront);
function mxShapeAws3dDataCenter(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dDataCenter, mxShape);
mxShapeAws3dDataCenter.prototype.cst = {
    DATA_CENTER: "mxgraph.aws3d.dataCenter",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dDataCenter.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 123;
    var strokeWidth2 = strokeWidth * h / 142;
    var isShadow = parseFloat(mxUtils.getValue(this.state.style, "shadow", "0"));
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    c.setShadow(false);
    c.setStrokeWidth(strokeWidth);
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    if (isShadow == 1)
        c.setShadow(true);
    c.begin();
    c.moveTo(0, h * .7465);
    c.lineTo(0, h * .25);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h * .25);
    c.lineTo(w, h * .7465);
    c.lineTo(w * .5, h);
    c.close();
    c.fillAndStroke();
    c.restore();
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dDataCenter.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(0, h * .7465);
    c.lineTo(0, h * .25);
    c.lineTo(w * .5, h * .5);
    c.lineTo(w * .5, h);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w, h * .7465);
    c.lineTo(w, h * .25);
    c.lineTo(w * .5, h * .5);
    c.lineTo(w * .5, h);
    c.close();
    c.fill();
    c.restore();
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .7465);
    c.lineTo(0, h * .25);
    c.lineTo(w * .5, h * .5);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke();
    c.begin();
    c.moveTo(w, h * .7465);
    c.lineTo(w, h * .25);
    c.lineTo(w * .5, h * .5);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke();
    c.setLineCap("round");
    c.setStrokeWidth(3 * strokeWidth);
    c.begin();
    c.moveTo(w * .0894, h * .3838);
    c.lineTo(w * .4187, h * .5493);
    c.moveTo(w * .0894, h * .4331);
    c.lineTo(w * .4187, h * .5986);
    c.moveTo(w * .0894, h * .4824);
    c.lineTo(w * .4187, h * .6479);
    c.moveTo(w * .5854, h * .5493);
    c.lineTo(w * .9146, h * .3838);
    c.moveTo(w * .5854, h * .5986);
    c.lineTo(w * .9146, h * .4331);
    c.moveTo(w * .5854, h * .6479);
    c.lineTo(w * .9146, h * .4824);
    c.stroke();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .7465);
    c.lineTo(0, h * .25);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h * .25);
    c.lineTo(w, h * .7465);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dDataCenter.prototype.cst.DATA_CENTER, mxShapeAws3dDataCenter);
function mxShapeAws3dDataServer(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dDataServer, mxShape);
mxShapeAws3dDataServer.prototype.cst = {
    DATA_SERVER: "mxgraph.aws3d.dataServer",
    SHADINC_COLORS: "shadingCols"
};
mxShapeAws3dDataServer.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 123;
    var strokeWidth2 = strokeWidth * h / 106;
    var isShadow = parseFloat(mxUtils.getValue(this.state.style, "shadow", "0"));
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    c.setShadow(false);
    c.setStrokeWidth(strokeWidth);
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    if (isShadow == 1)
        c.setShadow(true);
    c.begin();
    c.moveTo(0, h * .6651);
    c.lineTo(0, h * .3349);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h * .3349);
    c.lineTo(w, h * .6651);
    c.lineTo(w * .5, h);
    c.close();
    c.fillAndStroke();
    c.restore();
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dDataServer.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(0, h * .6651);
    c.lineTo(0, h * .3349);
    c.lineTo(w * .5, h * .6698);
    c.lineTo(w * .5, h);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w, h * .6651);
    c.lineTo(w, h * .3349);
    c.lineTo(w * .5, h * .6698);
    c.lineTo(w * .5, h);
    c.close();
    c.fill();
    c.restore();
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .6651);
    c.lineTo(0, h * .3349);
    c.lineTo(w * .5, h * .6698);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke();
    c.begin();
    c.moveTo(w, h * .6651);
    c.lineTo(w, h * .3349);
    c.lineTo(w * .5, h * .6698);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke();
    c.setLineCap("round");
    c.setStrokeWidth(3 * strokeWidth);
    c.begin();
    c.moveTo(w * .0878, h * .4858);
    c.lineTo(w * .4187, h * .7094);
    c.moveTo(w * .587, h * .7094);
    c.lineTo(w * .9187, h * .4858);
    c.stroke();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .6651);
    c.lineTo(0, h * .3349);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h * .3349);
    c.lineTo(w, h * .6651);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dDataServer.prototype.cst.DATA_SERVER, mxShapeAws3dDataServer);
function mxShapeAws3dElasticLoadBalancing(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dElasticLoadBalancing, mxShape);
mxShapeAws3dElasticLoadBalancing.prototype.cst = {
    ELASTIC_LOAD_BALANCING: "mxgraph.aws3d.elasticLoadBalancing",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dElasticLoadBalancing.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 92;
    var strokeWidth2 = strokeWidth * h / 88.17;
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    var isShadow = parseFloat(mxUtils.getValue(this.state.style, "shadow", "0"));
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    c.setShadow(false);
    c.setStrokeWidth(strokeWidth);
    c.save();
    c.save();
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    if (isShadow == 1)
        c.setShadow(true);
    c.begin();
    c.moveTo(0, h * .7996);
    c.lineTo(0, h * .1985);
    c.lineTo(w * .3315, 0);
    c.lineTo(w * .6685, 0);
    c.lineTo(w, h * .1985);
    c.lineTo(w, h * .7996);
    c.lineTo(w * .6685, h);
    c.lineTo(w * .3315, h);
    c.close();
    c.fillAndStroke();
    c.restore();
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dElasticLoadBalancing.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(0, h * .4026);
    c.lineTo(w * .3315, h * .6011);
    c.lineTo(w * .6685, h * .6011);
    c.lineTo(w * .6685, h);
    c.lineTo(w * .3315, h);
    c.lineTo(0, h * .7996);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .6685, h * .6011);
    c.lineTo(w, h * .4026);
    c.lineTo(w, h * .7996);
    c.lineTo(w * .6685, h);
    c.close();
    c.fill();
    c.restore();
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .4026);
    c.lineTo(w * .3315, h * .6011);
    c.lineTo(w * .6685, h * .6011);
    c.lineTo(w * .6685, h);
    c.lineTo(w * .3315, h);
    c.lineTo(0, h * .7996);
    c.close();
    c.stroke();
    c.begin();
    c.moveTo(w * .6685, h * .6011);
    c.lineTo(w, h * .4026);
    c.lineTo(w, h * .7996);
    c.lineTo(w * .6685, h);
    c.close();
    c.moveTo(w * .3315, h * .6011);
    c.lineTo(w * .3315, h);
    c.stroke();
    c.restore();
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .337, h * .1395);
    c.arcTo(w * .3043, h * .1928, 0, 0, 1, w * .5, h * .1191);
    c.arcTo(w * .3043, h * .1928, 0, 0, 1, w * .6739, h * .1645);
    c.arcTo(w * .3261, h * .2155, 0, 0, 1, w * .8152, h * .3176);
    c.arcTo(w * .3261, h * .1701, 0, 0, 1, w * .75, h * .4367);
    c.arcTo(w * .3261, h * .3403, 0, 0, 1, w * .6033, h * .4854);
    c.arcTo(w * .3261, h * .2268, 0, 0, 1, w * .4348, h * .4741);
    c.arcTo(w * .3261, h * .2268, 0, 0, 1, w * .2848, h * .4094);
    c.arcTo(w * .3261, h * .2268, 0, 0, 1, w * .2065, h * .3062);
    c.arcTo(w * .3261, h * .1701, 0, 0, 1, w * .2446, h * .1928);
    c.arcTo(w * .2717, h * .1701, 0, 0, 1, w * .337, h * .1395);
    c.fill();
    c.restore();
    c.begin();
    c.moveTo(w * .2826, h * .372);
    c.lineTo(w * .362, h * .3232);
    c.lineTo(w * .4054, h * .3482);
    c.lineTo(w * .4457, h * .2654);
    c.lineTo(w * .4185, h * .2643);
    c.lineTo(w * .4728, h * .2132);
    c.lineTo(w * .4348, h * .1928);
    c.lineTo(w * .5141, h * .144);
    c.lineTo(w * .5837, h * .1883);
    c.lineTo(w * .5043, h * .2348);
    c.lineTo(w * .4848, h * .2223);
    c.lineTo(w * .4967, h * .2688);
    c.lineTo(w * .463, h * .2665);
    c.lineTo(w * .4304, h * .3346);
    c.lineTo(w * .4946, h * .2949);
    c.lineTo(w * .4761, h * .2858);
    c.lineTo(w * .5511, h * .2631);
    c.lineTo(w * .5261, h * .2472);
    c.lineTo(w * .6043, h * .1996);
    c.lineTo(w * .6761, h * .2404);
    c.lineTo(w * .5978, h * .2892);
    c.lineTo(w * .5652, h * .2699);
    c.lineTo(w * .5293, h * .3198);
    c.lineTo(w * .5087, h * .3051);
    c.lineTo(w * .4543, h * .3391);
    c.lineTo(w * .563, h * .3221);
    c.lineTo(w * .5598, h * .3017);
    c.lineTo(w * .6326, h * .3096);
    c.lineTo(w * .6163, h * .2994);
    c.lineTo(w * .6957, h * .2529);
    c.lineTo(w * .7674, h * .2938);
    c.lineTo(w * .687, h * .3425);
    c.lineTo(w * .6489, h * .321);
    c.lineTo(w * .5707, h * .3539);
    c.lineTo(w * .5674, h * .3369);
    c.lineTo(w * .4293, h * .3618);
    c.lineTo(w * .4641, h * .3834);
    c.lineTo(w * .3859, h * .4299);
    c.close();
    c.fill();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .7996);
    c.lineTo(0, h * .1985);
    c.lineTo(w * .3315, 0);
    c.lineTo(w * .6685, 0);
    c.lineTo(w, h * .1985);
    c.lineTo(w, h * .7996);
    c.lineTo(w * .6685, h);
    c.lineTo(w * .3315, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dElasticLoadBalancing.prototype.cst.ELASTIC_LOAD_BALANCING, mxShapeAws3dElasticLoadBalancing);
function mxShapeAws3dInstance(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dInstance, mxShape);
mxShapeAws3dInstance.prototype.cst = {
    INSTANCE: "mxgraph.aws3d.instance",
    SHADIG_COLORS: "shadingCols"
};
mxShapeAws3dInstance.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 123;
    var strokeWidth2 = strokeWidth * h / 97;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    this.background(c, 0, 0, w, h, strokeWidth);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h, strokeWidth)
}
;
mxShapeAws3dInstance.prototype.background = function(c, x, y, w, h, strokeWidth) {
    c.setStrokeWidth(strokeWidth);
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .634);
    c.lineTo(0, h * .2732);
    c.lineTo(w * .374, 0);
    c.lineTo(w * .622, 0);
    c.lineTo(w, h * .2732);
    c.lineTo(w, h * .634);
    c.lineTo(w * .5, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeAws3dInstance.prototype.foreground = function(c, x, y, w, h, strokeWidth) {
    c.restore();
    c.setShadow(false);
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dInstance.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(0, h * .2732);
    c.lineTo(w * .5, h * .6392);
    c.lineTo(w * .5, h);
    c.lineTo(0, h * .634);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .5, h * .6392);
    c.lineTo(w, h * .2732);
    c.lineTo(w, h * .6392);
    c.lineTo(w * .5, h);
    c.close();
    c.fill();
    c.restore();
    c.setShadow(false);
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .2732);
    c.lineTo(w * .5, h * .6392);
    c.lineTo(w * .5, h);
    c.lineTo(0, h * .634);
    c.close();
    c.stroke();
    c.begin();
    c.moveTo(w * .5, h * .6392);
    c.lineTo(w, h * .2732);
    c.lineTo(w, h * .6392);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke();
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .374, h * .4742);
    c.arcTo(w * .0325, h * .0258, 0, 0, 1, w * .374, h * .4381);
    c.lineTo(w * .4797, h * .3608);
    c.arcTo(w * .0325, h * .0206, 0, 0, 1, w * .5203, h * .3608);
    c.lineTo(w * .626, h * .4381);
    c.arcTo(w * .0325, h * .0258, 0, 0, 1, w * .626, h * .4711);
    c.lineTo(w * .5203, h * .5485);
    c.arcTo(w * .0325, h * .0206, 0, 0, 1, w * .4797, h * .5485);
    c.close();
    c.fill();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .634);
    c.lineTo(0, h * .2732);
    c.lineTo(w * .374, 0);
    c.lineTo(w * .622, 0);
    c.lineTo(w, h * .2732);
    c.lineTo(w, h * .634);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dInstance.prototype.cst.INSTANCE, mxShapeAws3dInstance);
function mxShapeAws3dInternetGateway(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dInternetGateway, mxShape);
mxShapeAws3dInternetGateway.prototype.cst = {
    INTERNET_GATEWAY: "mxgraph.aws3d.internetGateway",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dInternetGateway.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 116.7;
    var strokeWidth2 = strokeWidth * h / 102.8;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    this.background(c, 0, 0, w, h, strokeWidth);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h, strokeWidth)
}
;
mxShapeAws3dInternetGateway.prototype.background = function(c, x, y, w, h, strokeWidth) {
    c.setStrokeWidth(strokeWidth);
    c.save();
    c.save();
    c.save();
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(w * .4199, h * .5447);
    c.lineTo(w * .4199, h * .035);
    c.lineTo(w * .8946, 0);
    c.lineTo(w, h * .0691);
    c.lineTo(w, h * .4134);
    c.lineTo(w * .6812, h * .7247);
    c.close();
    c.fillAndStroke();
    c.restore();
    c.save();
    c.setShadow(false);
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dInternetGateway.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(w * .4199, h * .5447);
    c.lineTo(w * .4199, h * .035);
    c.lineTo(w * .6838, h * .2072);
    c.lineTo(w * .6838, h * .7247);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .6838, h * .2072);
    c.lineTo(w, h * .0691);
    c.lineTo(w, h * .4134);
    c.lineTo(w * .6838, h * .7247);
    c.close();
    c.fill();
    c.restore();
    c.setShadow(false);
    c.begin();
    c.moveTo(w * .4199, h * .5447);
    c.lineTo(w * .4199, h * .035);
    c.lineTo(w * .6838, h * .2072);
    c.lineTo(w * .6838, h * .7247);
    c.close();
    c.stroke();
    c.restore();
    c.setLineJoin("round");
    c.setShadow(false);
    c.begin();
    c.moveTo(w * .6838, h * .2072);
    c.lineTo(w, h * .0691);
    c.lineTo(w, h * .4134);
    c.lineTo(w * .6838, h * .7247);
    c.close();
    c.stroke();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.begin();
    c.moveTo(w * .4199, h * .5447);
    c.lineTo(w * .4199, h * .035);
    c.lineTo(w * .8946, 0);
    c.lineTo(w, h * .0691);
    c.lineTo(w, h * .4134);
    c.lineTo(w * .6812, h * .7247);
    c.close();
    c.stroke();
    c.restore();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .929);
    c.lineTo(0, h * .5866);
    c.lineTo(w * .3171, h * .1031);
    c.lineTo(w * .5784, h * .2753);
    c.lineTo(w * .5784, h * .7928);
    c.lineTo(w * .1054, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeAws3dInternetGateway.prototype.foreground = function(c, x, y, w, h, strokeWidth) {
    c.restore();
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setShadow(false);
    c.setLineJoin("round");
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dInternetGateway.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(0, h * .929);
    c.lineTo(0, h * .5866);
    c.lineTo(w * .1054, h * .6537);
    c.lineTo(w * .1054, h);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .1054, h);
    c.lineTo(w * .1054, h * .6537);
    c.lineTo(w * .5784, h * .2753);
    c.lineTo(w * .5784, h * .7928);
    c.close();
    c.fill();
    c.restore();
    c.setShadow(false);
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .929);
    c.lineTo(0, h * .5866);
    c.lineTo(w * .1054, h * .6537);
    c.lineTo(w * .1054, h);
    c.close();
    c.stroke();
    c.begin();
    c.moveTo(w * .1054, h);
    c.lineTo(w * .1054, h * .6537);
    c.lineTo(w * .5784, h * .2753);
    c.lineTo(w * .5784, h * .7928);
    c.close();
    c.stroke();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .929);
    c.lineTo(0, h * .5866);
    c.lineTo(w * .3171, h * .1031);
    c.lineTo(w * .5784, h * .2753);
    c.lineTo(w * .5784, h * .7928);
    c.lineTo(w * .1054, h);
    c.close();
    c.stroke();
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .7849, h * .5039);
    c.arcTo(w * .0343, h * .0632, 0, 0, 1, w * .7481, h * .4796);
    c.arcTo(w * .0857, h * .0973, 0, 0, 1, w * .7661, h * .3911);
    c.arcTo(w * .06, h * .0681, 0, 0, 1, w * .7712, h * .3356);
    c.arcTo(w * .0257, h * .0292, 0, 0, 1, w * .7952, h * .32);
    c.arcTo(w * .1285, h * .1459, 0, 0, 1, w * .8166, h * .2461);
    c.arcTo(w * .06, h * .0973, 0, 0, 1, w * .8595, h * .2238);
    c.arcTo(w * .0514, h * .0973, 0, 0, 1, w * .8937, h * .2743);
    c.arcTo(w * .0428, h * .0778, 0, 0, 1, w * .9323, h * .3093);
    c.arcTo(w * .0686, h * .0778, 0, 0, 1, w * .928, h * .3716);
    c.arcTo(w * .0857, h * .0973, 0, 0, 1, w * .8972, h * .4125);
    c.close();
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeAws3dInternetGateway.prototype.cst.INTERNET_GATEWAY, mxShapeAws3dInternetGateway);
function mxShapeAws3dOracleDataCenter(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dOracleDataCenter, mxShape);
mxShapeAws3dOracleDataCenter.prototype.cst = {
    ORACLE_DATA_CENTER: "mxgraph.aws3d.oracleDataCenter"
};
mxShapeAws3dOracleDataCenter.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 123;
    var strokeWidth2 = strokeWidth * h / 142;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    c.setStrokeWidth(strokeWidth);
    this.background(c, 0, 0, w, h, strokeWidth);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h, strokeWidth)
}
;
mxShapeAws3dOracleDataCenter.prototype.background = function(c, x, y, w, h, strokeWidth) {
    c.save();
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .7464);
    c.lineTo(0, h * .25);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h * .25);
    c.lineTo(w, h * .7464);
    c.lineTo(w * .5, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeAws3dOracleDataCenter.prototype.foreground = function(c, x, y, w, h, strokeWidth) {
    c.restore();
    c.setShadow(false);
    c.setFillColor("#000000");
    c.setAlpha("0.1");
    c.begin();
    c.moveTo(0, h * .7464);
    c.lineTo(0, h * .25);
    c.lineTo(w * .5, h * .5);
    c.lineTo(w * .5, h);
    c.close();
    c.fill();
    c.setAlpha("0.3");
    c.begin();
    c.moveTo(w * .5, h * .5);
    c.lineTo(w, h * .25);
    c.lineTo(w, h * .7464);
    c.lineTo(w * .5, h);
    c.close();
    c.fill();
    c.restore();
    c.setShadow(false);
    c.setLineJoin("round");
    c.setFillColor("#ff0000");
    c.begin();
    c.moveTo(0, h * .5866);
    c.lineTo(w * .5, h * .8359);
    c.lineTo(w, h * .5866);
    c.lineTo(w, h * .6986);
    c.lineTo(w * .5, h * .9486);
    c.lineTo(0, h * .6986);
    c.fill();
    c.setStrokeWidth(.5 * strokeWidth);
    c.setStrokeColor("#ffffff");
    c.setFillColor("#ffffff");
    c.begin();
    c.moveTo(0, h * .5866);
    c.lineTo(w * .5, h * .8359);
    c.lineTo(w, h * .5866);
    c.moveTo(w, h * .6986);
    c.lineTo(w * .5, h * .9486);
    c.lineTo(0, h * .6986);
    c.stroke();
    c.begin();
    c.moveTo(w * .0813, h * .7113);
    c.arcTo(w * .0569, h * .0493, 0, 0, 1, w * .065, h * .6831);
    c.arcTo(w * .065, h * .0563, 0, 0, 1, w * .065, h * .6613);
    c.arcTo(w * .0163, h * .0141, 0, 0, 1, w * .0797, h * .6549);
    c.lineTo(w * .122, h * .6754);
    c.arcTo(w * .065, h * .0563, 0, 0, 1, w * .1358, h * .6937);
    c.arcTo(w * .065, h * .0563, 0, 0, 1, w * .139, h * .7232);
    c.arcTo(w * .0179, h * .0155, 0, 0, 1, w * .1187, h * .7296);
    c.close();
    c.moveTo(w * .1163, h * .7183);
    c.arcTo(w * .0089, h * .0077, 0, 0, 0, w * .1285, h * .7148);
    c.arcTo(w * .0407, h * .0352, 0, 0, 0, w * .1293, h * .7021);
    c.arcTo(w * .0407, h * .0352, 0, 0, 0, w * .1179, h * .6831);
    c.lineTo(w * .087, h * .6676);
    c.arcTo(w * .0081, h * .007, 0, 0, 0, w * .0764, h * .6697);
    c.arcTo(w * .0325, h * .0352, 0, 0, 0, w * .078, h * .6937);
    c.arcTo(w * .0407, h * .0352, 0, 0, 0, w * .087, h * .7035);
    c.close();
    c.moveTo(w * .1439, h * .743);
    c.lineTo(w * .1439, h * .6866);
    c.lineTo(w * .1846, h * .707);
    c.arcTo(w * .0407, h * .0352, 0, 0, 1, w * .1967, h * .7183);
    c.arcTo(w * .0407, h * .0352, 0, 0, 1, w * .2, h * .738);
    c.arcTo(w * .0138, h * .0155, 0, 0, 1, w * .1813, h * .743);
    c.lineTo(w * .1992, h * .769);
    c.lineTo(w * .187, h * .7641);
    c.lineTo(w * .1577, h * .7218);
    c.lineTo(w * .1854, h * .7345);
    c.arcTo(w * .0041, h * .0035, 0, 0, 0, w * .1911, h * .7317);
    c.arcTo(w * .0163, h * .0141, 0, 0, 0, w * .1894, h * .7225);
    c.arcTo(w * .0325, h * .0282, 0, 0, 0, w * .1821, h * .7155);
    c.lineTo(w * .1528, h * .7007);
    c.lineTo(w * .1528, h * .7472);
    c.close();
    c.moveTo(w * .2008, h * .7711);
    c.lineTo(w * .2293, h * .7338);
    c.arcTo(w * .0065, h * .0056, 0, 0, 1, w * .2382, h * .7324);
    c.arcTo(w * .0407, h * .0352, 0, 0, 1, w * .2431, h * .7415);
    c.lineTo(w * .2699, h * .8035);
    c.lineTo(w * .2602, h * .8007);
    c.lineTo(w * .252, h * .7859);
    c.lineTo(w * .2293, h * .7754);
    c.lineTo(w * .2244, h * .7634);
    c.lineTo(w * .248, h * .7739);
    c.lineTo(w * .235, h * .7444);
    c.lineTo(w * .2122, h * .7768);
    c.close();
    c.moveTo(w * .3244, h * .8225);
    c.lineTo(w * .3171, h * .8289);
    c.lineTo(w * .2854, h * .8127);
    c.arcTo(w * .0407, h * .0352, 0, 0, 1, w * .2724, h * .7986);
    c.arcTo(w * .0569, h * .0493, 0, 0, 1, w * .265, h * .7746);
    c.arcTo(w * .0407, h * .0352, 0, 0, 1, w * .2683, h * .762);
    c.arcTo(w * .0163, h * .0141, 0, 0, 1, w * .2829, h * .757);
    c.lineTo(w * .3228, h * .7761);
    c.lineTo(w * .3179, h * .7831);
    c.lineTo(w * .2878, h * .7683);
    c.arcTo(w * .0081, h * .007, 0, 0, 0, w * .2789, h * .7697);
    c.arcTo(w * .0244, h * .0211, 0, 0, 0, w * .2748, h * .7831);
    c.arcTo(w * .0407, h * .0352, 0, 0, 0, w * .2878, h * .8042);
    c.close();
    c.moveTo(w * .3276, h * .7789);
    c.lineTo(w * .3366, h * .7831);
    c.lineTo(w * .3366, h * .8289);
    c.lineTo(w * .3805, h * .8507);
    c.lineTo(w * .3748, h * .857);
    c.lineTo(w * .3317, h * .8359);
    c.arcTo(w * .0163, h * .0141, 0, 0, 1, w * .3276, h * .8275);
    c.close();
    c.moveTo(w * .435, h * .8775);
    c.lineTo(w * .4325, h * .8866);
    c.lineTo(w * .3959, h * .8683);
    c.arcTo(w * .0407, h * .0352, 0, 0, 1, w * .3862, h * .8563);
    c.arcTo(w * .0528, h * .0458, 0, 0, 1, w * .3805, h * .8183);
    c.arcTo(w * .0163, h * .0141, 0, 0, 1, w * .3951, h * .8134);
    c.lineTo(w * .435, h * .8324);
    c.lineTo(w * .4285, h * .838);
    c.lineTo(w * .4008, h * .8246);
    c.arcTo(w * .0098, h * .0085, 0, 0, 0, w * .3878, h * .831);
    c.lineTo(w * .4333, h * .8542);
    c.lineTo(w * .426, h * .8606);
    c.lineTo(w * .3878, h * .8415);
    c.arcTo(w * .0325, h * .0282, 0, 0, 0, w * .3976, h * .8585);
    c.close();
    c.moveTo(w * .6171, h * .8063);
    c.arcTo(w * .0163, h * .0141, 0, 0, 1, w * .6366, h * .8092);
    c.arcTo(w * .0325, h * .0282, 0, 0, 1, w * .639, h * .8303);
    c.arcTo(w * .065, h * .0563, 0, 0, 1, w * .6211, h * .8592);
    c.lineTo(w * .5894, h * .8761);
    c.arcTo(w * .0203, h * .0176, 0, 0, 1, w * .565, h * .8732);
    c.arcTo(w * .0407, h * .0352, 0, 0, 1, w * .5659, h * .8458);
    c.arcTo(w * .0488, h * .0422, 0, 0, 1, w * .5805, h * .8246);
    c.close();
    c.moveTo(w * .5886, h * .8296);
    c.arcTo(w * .0325, h * .0282, 0, 0, 0, w * .5748, h * .8472);
    c.arcTo(w * .0325, h * .0282, 0, 0, 0, w * .574, h * .862);
    c.arcTo(w * .0098, h * .0085, 0, 0, 0, w * .587, h * .8676);
    c.lineTo(w * .6163, h * .8528);
    c.arcTo(w * .0407, h * .0352, 0, 0, 0, w * .6285, h * .8359);
    c.arcTo(w * .0244, h * .0211, 0, 0, 0, w * .6293, h * .8225);
    c.arcTo(w * .0098, h * .0085, 0, 0, 0, w * .6163, h * .8155);
    c.close();
    c.moveTo(w * .64, h * .85);
    c.lineTo(w * .64, h * .793);
    c.lineTo(w * .6854, h * .7718);
    c.arcTo(w * .0106, h * .0092, 0, 0, 1, w * .7008, h * .7782);
    c.arcTo(w * .0407, h * .0352, 0, 0, 1, w * .6959, h * .8);
    c.arcTo(w * .0407, h * .0352, 0, 0, 1, w * .6805, h * .8127);
    c.lineTo(w * .6992, h * .8218);
    c.lineTo(w * .6854, h * .8282);
    c.lineTo(w * .6569, h * .8141);
    c.lineTo(w * .6805, h * .8021);
    c.arcTo(w * .0203, h * .0176, 0, 0, 0, w * .6894, h * .7923);
    c.arcTo(w * .0244, h * .0211, 0, 0, 0, w * .6894, h * .7845);
    c.arcTo(w * .0041, h * .0035, 0, 0, 0, w * .6837, h * .7831);
    c.lineTo(w * .6528, h * .7979);
    c.lineTo(w * .6528, h * .8437);
    c.close();
    c.moveTo(w * .7, h * .8204);
    c.lineTo(w * .7301, h * .7507);
    c.arcTo(w * .0098, h * .0085, 0, 0, 1, w * .7358, h * .7444);
    c.arcTo(w * .0098, h * .0085, 0, 0, 1, w * .7415, h * .7486);
    c.lineTo(w * .7699, h * .7852);
    c.lineTo(w * .7602, h * .7908);
    c.lineTo(w * .7537, h * .7838);
    c.lineTo(w * .7276, h * .7958);
    c.lineTo(w * .7228, h * .788);
    c.lineTo(w * .748, h * .7768);
    c.lineTo(w * .7358, h * .7585);
    c.lineTo(w * .7114, h * .8155);
    c.close();
    c.moveTo(w * .8244, h * .7486);
    c.lineTo(w * .8171, h * .762);
    c.lineTo(w * .7894, h * .7761);
    c.arcTo(w * .0244, h * .0211, 0, 0, 1, w * .7683, h * .7746);
    c.arcTo(w * .0407, h * .0352, 0, 0, 1, w * .7667, h * .7507);
    c.arcTo(w * .0488, h * .0423, 0, 0, 1, w * .7937, h * .7162);
    c.lineTo(w * .822, h * .7035);
    c.lineTo(w * .8171, h * .7155);
    c.lineTo(w * .7902, h * .7296);
    c.arcTo(w * .0325, h * .0282, 0, 0, 0, w * .778, h * .743);
    c.arcTo(w * .0407, h * .0352, 0, 0, 0, w * .7756, h * .7606);
    c.arcTo(w * .0077, h * .0067, 0, 0, 0, w * .787, h * .767);
    c.close();
    c.moveTo(w * .8366, h * .6949);
    c.lineTo(w * .8366, h * .7423);
    c.lineTo(w * .878, h * .7231);
    c.lineTo(w * .874, h * .7338);
    c.lineTo(w * .8333, h * .7535);
    c.arcTo(w * .0041, h * .0035, 0, 0, 1, w * .8268, h * .75);
    c.lineTo(w * .8268, h * .7007);
    c.close();
    c.moveTo(w * .9342, h * .6472);
    c.lineTo(w * .9293, h * .6599);
    c.lineTo(w * .9033, h * .6725);
    c.arcTo(w * .0325, h * .0282, 0, 0, 0, w * .8927, h * .6817);
    c.arcTo(w * .0406, h * .0352, 0, 0, 0, w * .887, h * .6937);
    c.lineTo(w * .9309, h * .6725);
    c.lineTo(w * .9268, h * .6845);
    c.lineTo(w * .887, h * .7035);
    c.arcTo(w * .0089, h * .0077, 0, 0, 0, w * .8992, h * .7106);
    c.lineTo(w * .935, h * .693);
    c.lineTo(w * .9285, h * .7063);
    c.lineTo(w * .9008, h * .7197);
    c.arcTo(w * .0163, h * .0141, 0, 0, 1, w * .8829, h * .7204);
    c.arcTo(w * .0407, h * .0352, 0, 0, 1, w * .8764, h * .7028);
    c.arcTo(w * .065, h * .0563, 0, 0, 1, w * .8959, h * .6669);
    c.fill();
    c.restore();
    c.setShadow(false);
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .7464);
    c.lineTo(0, h * .25);
    c.lineTo(w * .5, h * .5);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke();
    c.begin();
    c.moveTo(w * .5, h * .5);
    c.lineTo(w, h * .25);
    c.lineTo(w, h * .7464);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .7464);
    c.lineTo(0, h * .25);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h * .25);
    c.lineTo(w, h * .7464);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke();
    c.restore();
    c.setShadow(false);
    c.setStrokeWidth(3 * strokeWidth);
    c.setLineCap("round");
    c.begin();
    c.moveTo(w * .0894, h * .3838);
    c.lineTo(w * .4187, h * .5493);
    c.moveTo(w * .0894, h * .4331);
    c.lineTo(w * .4187, h * .5986);
    c.moveTo(w * .0894, h * .4824);
    c.lineTo(w * .4187, h * .6479);
    c.moveTo(w * .5854, h * .5492);
    c.lineTo(w * .9146, h * .3838);
    c.moveTo(w * .5854, h * .5986);
    c.lineTo(w * .9146, h * .4331);
    c.moveTo(w * .5854, h * .6479);
    c.lineTo(w * .9146, h * .4824);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dOracleDataCenter.prototype.cst.ORACLE_DATA_CENTER, mxShapeAws3dOracleDataCenter);
function mxShapeAws3dOracleDatabaseServer(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dOracleDatabaseServer, mxShape);
mxShapeAws3dOracleDatabaseServer.prototype.cst = {
    ORACLE_DB_SERVER: "mxgraph.aws3d.oracleDbServer"
};
mxShapeAws3dOracleDatabaseServer.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 123;
    var strokeWidth2 = strokeWidth * h / 142;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    c.setStrokeWidth(strokeWidth);
    this.background(c, 0, 0, w, h, strokeWidth);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h, strokeWidth)
}
;
mxShapeAws3dOracleDatabaseServer.prototype.background = function(c, x, y, w, h, strokeWidth) {
    c.save();
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .7331);
    c.lineTo(0, h * .3346);
    c.lineTo(w * .126, h * .1316);
    c.lineTo(w * .374, 0);
    c.lineTo(w * .626, 0);
    c.lineTo(w * .874, h * .1316);
    c.lineTo(w, h * .3346);
    c.lineTo(w, h * .7331);
    c.lineTo(w * .5, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeAws3dOracleDatabaseServer.prototype.foreground = function(c, x, y, w, h, strokeWidth) {
    c.restore();
    c.setShadow(false);
    c.setFillColor("#000000");
    c.setAlpha("0.1");
    c.begin();
    c.moveTo(w * .126, h * .1316);
    c.lineTo(w * .126, h * .267);
    c.lineTo(w * .378, h * .4023);
    c.lineTo(w * .5, h * .6015);
    c.lineTo(w * .5, h);
    c.lineTo(0, h * .7331);
    c.lineTo(0, h * .3346);
    c.close();
    c.moveTo(w * .874, h * .267);
    c.lineTo(w * .874, h * .1316);
    c.lineTo(w, h * .3308);
    c.fill();
    c.setAlpha("0.3");
    c.begin();
    c.moveTo(w * .5, h);
    c.lineTo(w * .5, h * .6015);
    c.lineTo(w * .622, h * .4023);
    c.lineTo(w * .874, h * .267);
    c.lineTo(w, h * .3308);
    c.lineTo(w, h * .7331);
    c.close();
    c.fill();
    c.restore();
    c.setShadow(false);
    c.setLineJoin("round");
    c.setFillColor("#ff0000");
    c.begin();
    c.moveTo(0, h * .5586);
    c.lineTo(w * .5, h * .8248);
    c.lineTo(w, h * .5586);
    c.lineTo(w, h * .6782);
    c.lineTo(w * .5, h * .9453);
    c.lineTo(0, h * .6782);
    c.fill();
    c.setStrokeWidth(.5 * strokeWidth);
    c.setStrokeColor("#ffffff");
    c.setFillColor("#ffffff");
    c.begin();
    c.moveTo(0, h * .5586);
    c.lineTo(w * .5, h * .8248);
    c.lineTo(w, h * .5586);
    c.moveTo(w, h * .6782);
    c.lineTo(w * .5, h * .9453);
    c.lineTo(0, h * .6782);
    c.stroke();
    c.begin();
    c.moveTo(w * .0813, h * .6918);
    c.arcTo(w * .0569, h * .0526, 0, 0, 1, w * .065, h * .6616);
    c.arcTo(w * .065, h * .0601, 0, 0, 1, w * .065, h * .6384);
    c.arcTo(w * .0163, h * .0151, 0, 0, 1, w * .0797, h * .6315);
    c.lineTo(w * .122, h * .6534);
    c.arcTo(w * .065, h * .0601, 0, 0, 1, w * .1358, h * .673);
    c.arcTo(w * .065, h * .0601, 0, 0, 1, w * .139, h * .7045);
    c.arcTo(w * .0179, h * .0165, 0, 0, 1, w * .1187, h * .7113);
    c.close();
    c.moveTo(w * .1163, h * .6992);
    c.arcTo(w * .0089, h * .0082, 0, 0, 0, w * .1285, h * .6955);
    c.arcTo(w * .0407, h * .0376, 0, 0, 0, w * .1293, h * .6819);
    c.arcTo(w * .0407, h * .0376, 0, 0, 0, w * .1179, h * .6616);
    c.lineTo(w * .087, h * .6451);
    c.arcTo(w * .0081, h * .0075, 0, 0, 0, w * .0764, h * .6473);
    c.arcTo(w * .0325, h * .0376, 0, 0, 0, w * .078, h * .673);
    c.arcTo(w * .0407, h * .0376, 0, 0, 0, w * .087, h * .6834);
    c.close();
    c.moveTo(w * .1439, h * .7256);
    c.lineTo(w * .1439, h * .6654);
    c.lineTo(w * .1846, h * .6872);
    c.arcTo(w * .0407, h * .0376, 0, 0, 1, w * .1967, h * .6992);
    c.arcTo(w * .0407, h * .0376, 0, 0, 1, w * .2, h * .7203);
    c.arcTo(w * .0138, h * .0165, 0, 0, 1, w * .1813, h * .7256);
    c.lineTo(w * .1992, h * .7534);
    c.lineTo(w * .187, h * .7481);
    c.lineTo(w * .1577, h * .7029);
    c.lineTo(w * .1854, h * .7165);
    c.arcTo(w * .0041, h * .0037, 0, 0, 0, w * .1911, h * .7135);
    c.arcTo(w * .0163, h * .0151, 0, 0, 0, w * .1894, h * .7037);
    c.arcTo(w * .0325, h * .0301, 0, 0, 0, w * .1821, h * .6962);
    c.lineTo(w * .1528, h * .6804);
    c.lineTo(w * .1528, h * .7301);
    c.close();
    c.moveTo(w * .2008, h * .7556);
    c.lineTo(w * .2293, h * .7158);
    c.arcTo(w * .0065, h * .006, 0, 0, 1, w * .2382, h * .7143);
    c.arcTo(w * .0407, h * .0376, 0, 0, 1, w * .2431, h * .724);
    c.lineTo(w * .2699, h * .7902);
    c.lineTo(w * .2602, h * .7872);
    c.lineTo(w * .252, h * .7714);
    c.lineTo(w * .2293, h * .7602);
    c.lineTo(w * .2244, h * .7474);
    c.lineTo(w * .248, h * .7586);
    c.lineTo(w * .235, h * .7271);
    c.lineTo(w * .2122, h * .7617);
    c.close();
    c.moveTo(w * .3244, h * .8105);
    c.lineTo(w * .3171, h * .8173);
    c.lineTo(w * .2854, h * .8);
    c.arcTo(w * .0407, h * .0376, 0, 0, 1, w * .2724, h * .785);
    c.arcTo(w * .0569, h * .0526, 0, 0, 1, w * .265, h * .7593);
    c.arcTo(w * .0407, h * .0376, 0, 0, 1, w * .2683, h * .7459);
    c.arcTo(w * .0163, h * .0151, 0, 0, 1, w * .2829, h * .7405);
    c.lineTo(w * .3228, h * .7609);
    c.lineTo(w * .3179, h * .7684);
    c.lineTo(w * .2878, h * .7526);
    c.arcTo(w * .0081, h * .0075, 0, 0, 0, w * .2789, h * .7541);
    c.arcTo(w * .0244, h * .0225, 0, 0, 0, w * .2748, h * .7684);
    c.arcTo(w * .0407, h * .0376, 0, 0, 0, w * .2878, h * .7909);
    c.close();
    c.moveTo(w * .3276, h * .7639);
    c.lineTo(w * .3366, h * .7684);
    c.lineTo(w * .3366, h * .8173);
    c.lineTo(w * .3805, h * .8406);
    c.lineTo(w * .3748, h * .8473);
    c.lineTo(w * .3317, h * .8248);
    c.arcTo(w * .0163, h * .0151, 0, 0, 1, w * .3276, h * .8158);
    c.close();
    c.moveTo(w * .435, h * .8692);
    c.lineTo(w * .4325, h * .8789);
    c.lineTo(w * .3959, h * .8594);
    c.arcTo(w * .0407, h * .0376, 0, 0, 1, w * .3862, h * .8466);
    c.arcTo(w * .0528, h * .0489, 0, 0, 1, w * .3805, h * .806);
    c.arcTo(w * .0163, h * .0151, 0, 0, 1, w * .3951, h * .8008);
    c.lineTo(w * .435, h * .821);
    c.lineTo(w * .4285, h * .827);
    c.lineTo(w * .4008, h * .8127);
    c.arcTo(w * .0098, h * .0091, 0, 0, 0, w * .3878, h * .8196);
    c.lineTo(w * .4333, h * .8443);
    c.lineTo(w * .426, h * .8512);
    c.lineTo(w * .3878, h * .8308);
    c.arcTo(w * .0325, h * .0301, 0, 0, 0, w * .3976, h * .8489);
    c.close();
    c.moveTo(w * .6171, h * .7932);
    c.arcTo(w * .0163, h * .0151, 0, 0, 1, w * .6366, h * .7963);
    c.arcTo(w * .0325, h * .0301, 0, 0, 1, w * .639, h * .8188);
    c.arcTo(w * .065, h * .0601, 0, 0, 1, w * .6211, h * .8497);
    c.lineTo(w * .5894, h * .8677);
    c.arcTo(w * .0203, h * .0188, 0, 0, 1, w * .565, h * .8646);
    c.arcTo(w * .0407, h * .0376, 0, 0, 1, w * .5659, h * .8354);
    c.arcTo(w * .0488, h * .0451, 0, 0, 1, w * .5805, h * .8127);
    c.close();
    c.moveTo(w * .5886, h * .8181);
    c.arcTo(w * .0325, h * .0301, 0, 0, 0, w * .5748, h * .8368);
    c.arcTo(w * .0325, h * .0301, 0, 0, 0, w * .574, h * .8527);
    c.arcTo(w * .0098, h * .0091, 0, 0, 0, w * .587, h * .8586);
    c.lineTo(w * .6163, h * .8428);
    c.arcTo(w * .0407, h * .0376, 0, 0, 0, w * .6285, h * .8248);
    c.arcTo(w * .0244, h * .0225, 0, 0, 0, w * .6293, h * .8105);
    c.arcTo(w * .0098, h * .0091, 0, 0, 0, w * .6163, h * .803);
    c.close();
    c.moveTo(w * .64, h * .8398);
    c.lineTo(w * .64, h * .779);
    c.lineTo(w * .6854, h * .7563);
    c.arcTo(w * .0106, h * .0098, 0, 0, 1, w * .7008, h * .7632);
    c.arcTo(w * .0407, h * .0376, 0, 0, 1, w * .6959, h * .7865);
    c.arcTo(w * .0407, h * .0376, 0, 0, 1, w * .6805, h * .8);
    c.lineTo(w * .6992, h * .8097);
    c.lineTo(w * .6854, h * .8166);
    c.lineTo(w * .6569, h * .8015);
    c.lineTo(w * .6805, h * .7887);
    c.arcTo(w * .0203, h * .0188, 0, 0, 0, w * .6894, h * .7782);
    c.arcTo(w * .0244, h * .0225, 0, 0, 0, w * .6894, h * .7699);
    c.arcTo(w * .0041, h * .0037, 0, 0, 0, w * .6837, h * .7684);
    c.lineTo(w * .6528, h * .7842);
    c.lineTo(w * .6528, h * .8331);
    c.close();
    c.moveTo(w * .7, h * .8082);
    c.lineTo(w * .7301, h * .7338);
    c.arcTo(w * .0098, h * .0091, 0, 0, 1, w * .7358, h * .7271);
    c.arcTo(w * .0098, h * .0091, 0, 0, 1, w * .7415, h * .7316);
    c.lineTo(w * .7699, h * .7707);
    c.lineTo(w * .7602, h * .7766);
    c.lineTo(w * .7537, h * .7692);
    c.lineTo(w * .7276, h * .782);
    c.lineTo(w * .7228, h * .7736);
    c.lineTo(w * .748, h * .7617);
    c.lineTo(w * .7358, h * .7421);
    c.lineTo(w * .7114, h * .803);
    c.close();
    c.moveTo(w * .8244, h * .7316);
    c.lineTo(w * .8171, h * .7459);
    c.lineTo(w * .7894, h * .7609);
    c.arcTo(w * .0244, h * .0225, 0, 0, 1, w * .7683, h * .7593);
    c.arcTo(w * .0407, h * .0376, 0, 0, 1, w * .7667, h * .7338);
    c.arcTo(w * .0488, h * .0452, 0, 0, 1, w * .7937, h * .697);
    c.lineTo(w * .822, h * .6834);
    c.lineTo(w * .8171, h * .6962);
    c.lineTo(w * .7902, h * .7113);
    c.arcTo(w * .0325, h * .0301, 0, 0, 0, w * .778, h * .7256);
    c.arcTo(w * .0407, h * .0376, 0, 0, 0, w * .7756, h * .7444);
    c.arcTo(w * .0077, h * .0072, 0, 0, 0, w * .787, h * .7512);
    c.close();
    c.moveTo(w * .8366, h * .6742);
    c.lineTo(w * .8366, h * .7248);
    c.lineTo(w * .878, h * .7043);
    c.lineTo(w * .874, h * .7158);
    c.lineTo(w * .8333, h * .7368);
    c.arcTo(w * .0041, h * .0037, 0, 0, 1, w * .8268, h * .7324);
    c.lineTo(w * .8268, h * .6804);
    c.close();
    c.moveTo(w * .9342, h * .6233);
    c.lineTo(w * .9293, h * .6369);
    c.lineTo(w * .9033, h * .6503);
    c.arcTo(w * .0325, h * .0301, 0, 0, 0, w * .8927, h * .6601);
    c.arcTo(w * .0406, h * .0376, 0, 0, 0, w * .887, h * .6729);
    c.lineTo(w * .9309, h * .6503);
    c.lineTo(w * .9268, h * .6631);
    c.lineTo(w * .887, h * .6834);
    c.arcTo(w * .0089, h * .0082, 0, 0, 0, w * .8992, h * .691);
    c.lineTo(w * .935, h * .6722);
    c.lineTo(w * .9285, h * .6864);
    c.lineTo(w * .9008, h * .7007);
    c.arcTo(w * .0163, h * .0151, 0, 0, 1, w * .8829, h * .7015);
    c.arcTo(w * .0407, h * .0376, 0, 0, 1, w * .8764, h * .6827);
    c.arcTo(w * .065, h * .0601, 0, 0, 1, w * .8959, h * .6443);
    c.fill();
    c.restore();
    c.setShadow(false);
    c.setLineJoin("round");
    c.begin();
    c.moveTo(w * .126, h * .1316);
    c.lineTo(w * .126, h * .267);
    c.lineTo(w * .378, h * .4023);
    c.lineTo(w * .5, h * .6015);
    c.lineTo(w * .622, h * .4023);
    c.lineTo(w * .874, h * .267);
    c.lineTo(w * .874, h * .1316);
    c.moveTo(0, h * .3346);
    c.lineTo(w * .126, h * .267);
    c.moveTo(w * .5, h * .6015);
    c.lineTo(w * .5, h);
    c.moveTo(w, h * .3346);
    c.lineTo(w * .87, h * .267);
    c.moveTo(w * .378, h * .4023);
    c.lineTo(w * .622, h * .4023);
    c.stroke();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.begin();
    c.moveTo(0, h * .7331);
    c.lineTo(0, h * .3346);
    c.lineTo(w * .126, h * .1316);
    c.lineTo(w * .374, 0);
    c.lineTo(w * .626, 0);
    c.lineTo(w * .874, h * .1316);
    c.lineTo(w, h * .3346);
    c.lineTo(w, h * .7331);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dOracleDatabaseServer.prototype.cst.ORACLE_DB_SERVER, mxShapeAws3dOracleDatabaseServer);
function mxShapeAws3dRdsMaster(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dRdsMaster, mxShape);
mxShapeAws3dRdsMaster.prototype.cst = {
    RDS_MASTER: "mxgraph.aws3d.rdsMaster",
    SHADIG_COLORS: "shadingCols"
};
mxShapeAws3dRdsMaster.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 123;
    var strokeWidth2 = strokeWidth * h / 133;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    c.setStrokeWidth(strokeWidth);
    this.background(c, 0, 0, w, h, strokeWidth);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h, strokeWidth)
}
;
mxShapeAws3dRdsMaster.prototype.background = function(c, x, y, w, h, strokeWidth) {
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .7331);
    c.lineTo(0, h * .3346);
    c.lineTo(w * .126, h * .1316);
    c.lineTo(w * .374, 0);
    c.lineTo(w * .626, 0);
    c.lineTo(w * .874, h * .1316);
    c.lineTo(w, h * .3346);
    c.lineTo(w, h * .7331);
    c.lineTo(w * .5, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeAws3dRdsMaster.prototype.foreground = function(c, x, y, w, h, strokeWidth) {
    c.restore();
    c.setShadow(false);
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dRdsMaster.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(w * .126, h * .1316);
    c.lineTo(w * .126, h * .267);
    c.lineTo(w * .378, h * .4023);
    c.lineTo(w * .5, h * .6015);
    c.lineTo(w * .5, h);
    c.lineTo(0, h * .7331);
    c.lineTo(0, h * .3346);
    c.close();
    c.moveTo(w * .874, h * .267);
    c.lineTo(w * .874, h * .1316);
    c.lineTo(w, h * .3308);
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .5, h);
    c.lineTo(w * .5, h * .6015);
    c.lineTo(w * .622, h * .4023);
    c.lineTo(w * .874, h * .267);
    c.lineTo(w, h * .3308);
    c.lineTo(w, h * .7331);
    c.close();
    c.fill();
    c.restore();
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setFillColor(strokeColor);
    c.setShadow(false);
    c.begin();
    c.moveTo(w * .1878, h * .1932);
    c.lineTo(w * .4854, h * .0414);
    c.lineTo(w * .5886, h * .094);
    c.lineTo(w * .4455, h * .2308);
    c.lineTo(w * .7122, h * .1579);
    c.lineTo(w * .8171, h * .2098);
    c.lineTo(w * .5187, h * .3617);
    c.lineTo(w * .4537, h * .3293);
    c.lineTo(w * .7016, h * .2053);
    c.lineTo(w * .3854, h * .2947);
    c.lineTo(w * .3187, h * .2602);
    c.lineTo(w * .4959, h * .0992);
    c.lineTo(w * .2504, h * .2256);
    c.close();
    c.fill();
    c.setLineJoin("round");
    c.begin();
    c.moveTo(w * .126, h * .1316);
    c.lineTo(w * .126, h * .267);
    c.lineTo(w * .378, h * .4023);
    c.lineTo(w * .5, h * .6015);
    c.lineTo(w * .622, h * .4023);
    c.lineTo(w * .874, h * .267);
    c.lineTo(w * .874, h * .1316);
    c.moveTo(0, h * .3346);
    c.lineTo(w * .126, h * .267);
    c.moveTo(w * .5, h * .6015);
    c.lineTo(w * .5, h);
    c.moveTo(w, h * .3346);
    c.lineTo(w * .87, h * .267);
    c.moveTo(w * .378, h * .4023);
    c.lineTo(w * .622, h * .4023);
    c.stroke();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.begin();
    c.moveTo(0, h * .7331);
    c.lineTo(0, h * .3346);
    c.lineTo(w * .126, h * .1316);
    c.lineTo(w * .374, 0);
    c.lineTo(w * .626, 0);
    c.lineTo(w * .874, h * .1316);
    c.lineTo(w, h * .3346);
    c.lineTo(w, h * .7331);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dRdsMaster.prototype.cst.RDS_MASTER, mxShapeAws3dRdsMaster);
function mxShapeAws3dRds(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dRds, mxShape);
mxShapeAws3dRds.prototype.cst = {
    RDS: "mxgraph.aws3d.rds",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dRds.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 123;
    var strokeWidth2 = strokeWidth * h / 133;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    c.setStrokeWidth(strokeWidth);
    this.background(c, 0, 0, w, h, strokeWidth);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h, strokeWidth)
}
;
mxShapeAws3dRds.prototype.background = function(c, x, y, w, h, strokeWidth) {
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .7331);
    c.lineTo(0, h * .3346);
    c.lineTo(w * .126, h * .1316);
    c.lineTo(w * .374, 0);
    c.lineTo(w * .626, 0);
    c.lineTo(w * .874, h * .1316);
    c.lineTo(w, h * .3346);
    c.lineTo(w, h * .7331);
    c.lineTo(w * .5, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeAws3dRds.prototype.foreground = function(c, x, y, w, h, strokeWidth) {
    c.restore();
    c.setShadow(false);
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dRds.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(w * .126, h * .1316);
    c.lineTo(w * .126, h * .267);
    c.lineTo(w * .378, h * .4023);
    c.lineTo(w * .5, h * .6015);
    c.lineTo(w * .5, h);
    c.lineTo(0, h * .7331);
    c.lineTo(0, h * .3346);
    c.close();
    c.moveTo(w * .874, h * .267);
    c.lineTo(w * .874, h * .1316);
    c.lineTo(w, h * .3308);
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .5, h);
    c.lineTo(w * .5, h * .6015);
    c.lineTo(w * .622, h * .4023);
    c.lineTo(w * .874, h * .267);
    c.lineTo(w, h * .3308);
    c.lineTo(w, h * .7331);
    c.close();
    c.fill();
    c.restore();
    c.setFillColor("#ffffff");
    c.setShadow(false);
    c.begin();
    c.moveTo(0, h * .6053);
    c.lineTo(w * .5, h * .8722);
    c.lineTo(w, h * .6053);
    c.lineTo(w, h * .6278);
    c.lineTo(w * .5, h * .8947);
    c.lineTo(0, h * .6278);
    c.close();
    c.fill();
    c.setLineJoin("round");
    c.begin();
    c.moveTo(w * .126, h * .1316);
    c.lineTo(w * .126, h * .267);
    c.lineTo(w * .378, h * .4023);
    c.lineTo(w * .5, h * .6015);
    c.lineTo(w * .622, h * .4023);
    c.lineTo(w * .874, h * .267);
    c.lineTo(w * .874, h * .1316);
    c.moveTo(0, h * .3346);
    c.lineTo(w * .126, h * .267);
    c.moveTo(w * .5, h * .6015);
    c.lineTo(w * .5, h);
    c.moveTo(w, h * .3346);
    c.lineTo(w * .87, h * .267);
    c.moveTo(w * .378, h * .4023);
    c.lineTo(w * .622, h * .4023);
    c.stroke();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.begin();
    c.moveTo(0, h * .7331);
    c.lineTo(0, h * .3346);
    c.lineTo(w * .126, h * .1316);
    c.lineTo(w * .374, 0);
    c.lineTo(w * .626, 0);
    c.lineTo(w * .874, h * .1316);
    c.lineTo(w, h * .3346);
    c.lineTo(w, h * .7331);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dRds.prototype.cst.RDS, mxShapeAws3dRds);
function mxShapeAws3dRoute53(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dRoute53, mxShape);
mxShapeAws3dRoute53.prototype.cst = {
    ROUTE_53: "mxgraph.aws3d.route53",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dRoute53.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 117;
    var strokeWidth2 = strokeWidth * h / 134.4;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    c.setStrokeWidth(strokeWidth);
    this.background(c, 0, 0, w, h, strokeWidth);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h, strokeWidth)
}
;
mxShapeAws3dRoute53.prototype.background = function(c, x, y, w, h, strokeWidth) {
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .6994);
    c.lineTo(0, h * .2009);
    c.lineTo(w * .0427, h * .0781);
    c.lineTo(w * .7974, 0);
    c.lineTo(w, h * .1004);
    c.lineTo(w, h * .5915);
    c.lineTo(w * .8376, h * .9784);
    c.lineTo(w * .5983, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeAws3dRoute53.prototype.foreground = function(c, x, y, w, h, strokeWidth) {
    c.restore();
    c.setShadow(false);
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dRoute53.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(0, h * .2009);
    c.lineTo(w * .6009, h * .5007);
    c.lineTo(w * .8376, h * .4799);
    c.lineTo(w * .8376, h * .9784);
    c.lineTo(w * .5966, h);
    c.lineTo(0, h * .6979);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .8348, h * .4861);
    c.lineTo(w * .9985, h * .0992);
    c.lineTo(w, h * .5952);
    c.lineTo(w * .8404, h * .9747);
    c.close();
    c.fill();
    c.restore();
    c.setShadow(false);
    c.setLineJoin("round");
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .5855, h * .1079);
    c.arcTo(w * .094, h * .0744, 0, 0, 0, w * .6863, h * .1548);
    c.arcTo(w * .0855, h * .0446, 0, 0, 0, w * .7761, h * .2031);
    c.lineTo(w * .7726, h * .2455);
    c.arcTo(w * .0769, h * .0298, 0, 0, 0, w * .694, h * .2693);
    c.arcTo(w * .0684, h * .0446, 0, 0, 1, w * .5897, h * .3051);
    c.arcTo(w * .4274, h * .372, 0, 0, 0, w * .4573, h * .2753);
    c.arcTo(w * .0855, h * .0744, 0, 0, 0, w * .4188, h * .2344);
    c.lineTo(w * .3846, h * .2083);
    c.arcTo(w * .0769, h * .0372, 0, 0, 1, w * .4103, h * .1525);
    c.arcTo(w * .0855, h * .0409, 0, 0, 0, w * .4906, h * .1079);
    c.close();
    c.fill();
    c.begin();
    c.moveTo(0, h * .2009);
    c.lineTo(w * .6009, h * .5007);
    c.lineTo(w * .8376, h * .4799);
    c.lineTo(w * .8376, h * .9784);
    c.lineTo(w * .5966, h);
    c.lineTo(0, h * .6979);
    c.close();
    c.moveTo(w * .8348, h * .4861);
    c.lineTo(w * .9985, h * .0992);
    c.lineTo(w, h * .5952);
    c.lineTo(w * .8404, h * .9747);
    c.close();
    c.moveTo(w * .6009, h * .5007);
    c.lineTo(w * .6009, h);
    c.stroke();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.begin();
    c.moveTo(0, h * .6994);
    c.lineTo(0, h * .2009);
    c.lineTo(w * .0427, h * .0781);
    c.lineTo(w * .7974, 0);
    c.lineTo(w, h * .1004);
    c.lineTo(w, h * .5915);
    c.lineTo(w * .8376, h * .9784);
    c.lineTo(w * .5983, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dRoute53.prototype.cst.ROUTE_53, mxShapeAws3dRoute53);
function mxShapeAws3dS3Bucket(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dS3Bucket, mxShape);
mxShapeAws3dS3Bucket.prototype.cst = {
    S3_BUCKET: "mxgraph.aws3d.s3Bucket",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dS3Bucket.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 61.5;
    var strokeWidth2 = strokeWidth * h / 63.8;
    var isShadow = parseFloat(mxUtils.getValue(this.state.style, "shadow", "0"));
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    c.setShadow(false);
    c.setStrokeWidth(strokeWidth);
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    if (isShadow == 1)
        c.setShadow(true);
    c.begin();
    c.moveTo(0, h * .2774);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h * .2774);
    c.lineTo(w * .7967, h * .8307);
    c.lineTo(w * .5, h);
    c.lineTo(w * .1951, h * .8307);
    c.close();
    c.fillAndStroke();
    c.restore();
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dS3Bucket.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(0, h * .2774);
    c.lineTo(w * .5, h * .5564);
    c.lineTo(w * .5, h);
    c.lineTo(w * .1984, h * .8307);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .5, h * .5533);
    c.lineTo(w, h * .2774);
    c.lineTo(w * .7967, h * .8307);
    c.lineTo(w * .5, h);
    c.close();
    c.fill();
    c.restore();
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .2774);
    c.lineTo(w * .5, h * .5564);
    c.lineTo(w, h * .2774);
    c.stroke();
    c.begin();
    c.moveTo(w * .5, h * .5564);
    c.lineTo(w * .5, h);
    c.stroke();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .2774);
    c.lineTo(w * .5008, 0);
    c.lineTo(w, h * .2774);
    c.lineTo(w * .7967, h * .8307);
    c.lineTo(w * .5008, h);
    c.lineTo(w * .1951, h * .8307);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dS3Bucket.prototype.cst.S3_BUCKET, mxShapeAws3dS3Bucket);
function mxShapeAws3dS3(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dS3, mxShape);
mxShapeAws3dS3.prototype.cst = {
    S3: "mxgraph.aws3d.s3",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dS3.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 231.5;
    var strokeWidth2 = strokeWidth * h / 239;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    this.background(c, 0, 0, w, h, strokeWidth);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h, strokeWidth)
}
;
mxShapeAws3dS3.prototype.background = function(c, x, y, w, h, strokeWidth) {
    c.setStrokeWidth(strokeWidth);
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .7782);
    c.lineTo(0, h * .3406);
    c.lineTo(w * .5974, 0);
    c.lineTo(w, h * .2218);
    c.lineTo(w, h * .6674);
    c.lineTo(w * .3991, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeAws3dS3.prototype.foreground = function(c, x, y, w, h, strokeWidth) {
    c.restore();
    c.setShadow(false);
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dS3.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(0, h * .3406);
    c.lineTo(w * .3991, h * .5548);
    c.lineTo(w * .3991, h);
    c.lineTo(0, h * .7782);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .3991, h * .5548);
    c.lineTo(w, h * .2218);
    c.lineTo(w, h * .6661);
    c.lineTo(w * .3991, h);
    c.close();
    c.fill();
    c.restore();
    c.setShadow(false);
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .3406);
    c.lineTo(w * .3991, h * .5548);
    c.lineTo(w, h * .2218);
    c.moveTo(w * .3991, h * .5548);
    c.lineTo(w * .3991, h);
    c.moveTo(w * .3991, h * .3335);
    c.lineTo(w * .2009, h * .448);
    c.lineTo(w * .2009, h * .8891);
    c.moveTo(w * .5983, h * .2209);
    c.lineTo(w * .7948, h * .1109);
    c.moveTo(w * .2022, h * .2218);
    c.lineTo(w * .5991, h * .4448);
    c.lineTo(w * .5991, h * .8891);
    c.moveTo(w * .4004, h * .1117);
    c.lineTo(w * .7978, h * .3335);
    c.lineTo(w * .7978, h * .7791);
    c.stroke();
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .4773, h * .2155);
    c.arcTo(w * .0086, h * .0046, 0, 0, 1, w * .4903, h * .2096);
    c.arcTo(w * .2808, h * .272, 0, 0, 1, w * .6004, h * .2619);
    c.arcTo(w * .108, h * .105, 0, 0, 1, w * .6177, h * .277);
    c.arcTo(w * .0065, h * .0063, 0, 0, 1, w * .6099, h * .2879);
    c.arcTo(w * .1944, h * .1883, 0, 0, 1, w * .5378, h * .2607);
    c.arcTo(w * .216, h * .2092, 0, 0, 1, w * .4773, h * .2155);
    c.close();
    c.fill();
    c.begin();
    c.moveTo(w * .4687, h * .2138);
    c.arcTo(w * .1512, h * .1464, 0, 0, 0, w * .4838, h * .2343);
    c.arcTo(w * .2376, h * .2301, 0, 0, 0, w * .5529, h * .2774);
    c.arcTo(w * .1728, h * .1674, 0, 0, 0, w * .6091, h * .2954);
    c.lineTo(w * .4946, h * .3339);
    c.arcTo(w * .1944, h * .1883, 0, 0, 1, w * .4549, h * .3205);
    c.arcTo(w * .1944, h * .1883, 0, 0, 1, w * .419, h * .3004);
    c.arcTo(w * .1944, h * .1883, 0, 0, 1, w * .3965, h * .2795);
    c.close();
    c.fill();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .7782);
    c.lineTo(0, h * .3406);
    c.lineTo(w * .5974, 0);
    c.lineTo(w, h * .2218);
    c.lineTo(w, h * .6674);
    c.lineTo(w * .3991, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dS3.prototype.cst.S3, mxShapeAws3dS3);
function mxShapeAws3dSimpleDB(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dSimpleDB, mxShape);
mxShapeAws3dSimpleDB.prototype.cst = {
    SIMPLE_DB: "mxgraph.aws3d.simpleDb",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dSimpleDB.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 123;
    var strokeWidth2 = strokeWidth * h / 133;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    c.setStrokeWidth(strokeWidth);
    this.background(c, 0, 0, w, h, strokeWidth);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h, strokeWidth)
}
;
mxShapeAws3dSimpleDB.prototype.background = function(c, x, y, w, h, strokeWidth) {
    c.save();
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .7331);
    c.lineTo(0, h * .3346);
    c.lineTo(w * .126, h * .1316);
    c.lineTo(w * .374, 0);
    c.lineTo(w * .626, 0);
    c.lineTo(w * .874, h * .1316);
    c.lineTo(w, h * .3346);
    c.lineTo(w, h * .7331);
    c.lineTo(w * .5, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeAws3dSimpleDB.prototype.foreground = function(c, x, y, w, h, strokeWidth) {
    c.restore();
    c.setShadow(false);
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dSimpleDB.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(w * .126, h * .1316);
    c.lineTo(w * .126, h * .267);
    c.lineTo(w * .378, h * .4023);
    c.lineTo(w * .5, h * .6015);
    c.lineTo(w * .5, h);
    c.lineTo(0, h * .7331);
    c.lineTo(0, h * .3346);
    c.close();
    c.moveTo(w * .874, h * .267);
    c.lineTo(w * .874, h * .1316);
    c.lineTo(w, h * .3308);
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .5, h);
    c.lineTo(w * .5, h * .6015);
    c.lineTo(w * .622, h * .4023);
    c.lineTo(w * .874, h * .267);
    c.lineTo(w, h * .3308);
    c.lineTo(w, h * .7331);
    c.close();
    c.fill();
    c.restore();
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setFillColor(strokeColor);
    c.setShadow(false);
    c.begin();
    c.moveTo(w * .1821, h * .182);
    c.lineTo(w * .4659, h * .0308);
    c.lineTo(w * .822, h * .2218);
    c.lineTo(w * .539, h * .3714);
    c.close();
    c.fill();
    c.setLineJoin("round");
    c.begin();
    c.moveTo(w * .126, h * .1316);
    c.lineTo(w * .126, h * .267);
    c.lineTo(w * .378, h * .4023);
    c.lineTo(w * .5, h * .6015);
    c.lineTo(w * .622, h * .4023);
    c.lineTo(w * .874, h * .267);
    c.lineTo(w * .874, h * .1316);
    c.moveTo(0, h * .3346);
    c.lineTo(w * .126, h * .267);
    c.moveTo(w * .5, h * .6015);
    c.lineTo(w * .5, h);
    c.moveTo(w, h * .3346);
    c.lineTo(w * .87, h * .267);
    c.moveTo(w * .378, h * .4023);
    c.lineTo(w * .622, h * .4023);
    c.stroke();
    c.restore();
    c.setShadow(false);
    var fillColor = mxUtils.getValue(this.state.style, "fillColor", "#ffffff");
    c.setStrokeColor(fillColor);
    c.setStrokeWidth(2.2 * strokeWidth);
    c.begin();
    c.moveTo(w * .2382, h * .2218);
    c.lineTo(w * .5415, h * .0602);
    c.moveTo(w * .3821, h * .0564);
    c.lineTo(w * .7737, h * .2656);
    c.moveTo(w * .2967, h * .0915);
    c.lineTo(w * .7114, h * .312);
    c.moveTo(w * .2209, h * .1316);
    c.lineTo(w * .6179, h * .3434);
    c.stroke();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.begin();
    c.moveTo(0, h * .7331);
    c.lineTo(0, h * .3346);
    c.lineTo(w * .126, h * .1316);
    c.lineTo(w * .374, 0);
    c.lineTo(w * .626, 0);
    c.lineTo(w * .874, h * .1316);
    c.lineTo(w, h * .3346);
    c.lineTo(w, h * .7331);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dSimpleDB.prototype.cst.SIMPLE_DB, mxShapeAws3dSimpleDB);
function mxShapeAws3dSqs(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dSqs, mxShape);
mxShapeAws3dSqs.prototype.cst = {
    SQS: "mxgraph.aws3d.sqs",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dSqs.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 184;
    var strokeWidth2 = strokeWidth * h / 212.75;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    this.background(c, 0, 0, w, h, strokeWidth);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h, strokeWidth)
}
;
mxShapeAws3dSqs.prototype.background = function(c, x, y, w, h, strokeWidth) {
    c.setStrokeWidth(strokeWidth);
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .7485);
    c.lineTo(0, h * .584);
    c.lineTo(w * .1658, h * .1666);
    c.lineTo(w * .5, 0);
    c.lineTo(w * .8337, h * .1666);
    c.lineTo(w, h * .584);
    c.lineTo(w, h * .7485);
    c.lineTo(w * .5, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeAws3dSqs.prototype.foreground = function(c, x, y, w, h, strokeWidth) {
    c.restore();
    c.setShadow(false);
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dSqs.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(w * .1658, h * .1671);
    c.lineTo(w * .5, h * .334);
    c.lineTo(w * .5, h);
    c.lineTo(0, h * .7485);
    c.lineTo(0, h * .584);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .5, h * .3344);
    c.lineTo(w * .8332, h * .1671);
    c.lineTo(w, h * .584);
    c.lineTo(w, h * .7509);
    c.lineTo(w * .5, h);
    c.close();
    c.fill();
    c.restore();
    c.setShadow(false);
    c.setLineJoin("round");
    c.begin();
    c.moveTo(w * .6674, h * .0844);
    c.lineTo(w * .3337, h * .2512);
    c.lineTo(w * .25, h * .7109);
    c.lineTo(w * .25, h * .8736);
    c.moveTo(w * .3326, h * .0839);
    c.lineTo(w * .6674, h * .2512);
    c.lineTo(w * .75, h * .7053);
    c.lineTo(w * .75, h * .874);
    c.moveTo(0, h * .584);
    c.lineTo(w * .5, h * .8331);
    c.lineTo(w, h * .584);
    c.moveTo(w * .1658, h * .1671);
    c.lineTo(w * .5, h * .334);
    c.lineTo(w * .8332, h * .1671);
    c.moveTo(w * .5, h * .334);
    c.lineTo(w * .5, h);
    c.stroke();
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .3337, h * .1511);
    c.lineTo(w * .4668, h * .0848);
    c.lineTo(w * .6663, h * .184);
    c.lineTo(w * .5337, h * .2503);
    c.close();
    c.fill();
    var fillColor = mxUtils.getValue(this.state.style, "fillColor", "#000000");
    c.setFillColor(fillColor);
    c.begin();
    c.moveTo(w * .3902, h * .153);
    c.lineTo(w * .4701, h * .113);
    c.lineTo(w * .4701, h * .153);
    c.close();
    c.moveTo(w * .4402, h * .1784);
    c.lineTo(w * .5196, h * .1384);
    c.lineTo(w * .5196, h * .1784);
    c.close();
    c.moveTo(w * .4908, h * .2033);
    c.lineTo(w * .5701, h * .1633);
    c.lineTo(w * .5701, h * .2033);
    c.close();
    c.fill();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .7485);
    c.lineTo(0, h * .584);
    c.lineTo(w * .1658, h * .1666);
    c.lineTo(w * .5, 0);
    c.lineTo(w * .8337, h * .1666);
    c.lineTo(w, h * .584);
    c.lineTo(w, h * .7485);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dSqs.prototype.cst.SQS, mxShapeAws3dSqs);
function mxShapeAws3dVpcGateway(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dVpcGateway, mxShape);
mxShapeAws3dVpcGateway.prototype.cst = {
    VPC_GATEWAY: "mxgraph.aws3d.vpcGateway",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dVpcGateway.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 116.7;
    var strokeWidth2 = strokeWidth * h / 102.8;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    this.background(c, 0, 0, w, h, strokeWidth);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h, strokeWidth)
}
;
mxShapeAws3dVpcGateway.prototype.background = function(c, x, y, w, h, strokeWidth) {
    c.setStrokeWidth(strokeWidth);
    c.save();
    c.save();
    c.save();
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(w * .5801, h * .5447);
    c.lineTo(w * .5801, h * .035);
    c.lineTo(w * .1054, 0);
    c.lineTo(0, h * .0691);
    c.lineTo(0, h * .4134);
    c.lineTo(w * .3188, h * .7247);
    c.close();
    c.fillAndStroke();
    c.restore();
    c.save();
    c.setShadow(false);
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dVpcGateway.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .5801, h * .5447);
    c.lineTo(w * .5801, h * .035);
    c.lineTo(w * .3162, h * .2072);
    c.lineTo(w * .3162, h * .7247);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(w * .3162, h * .2072);
    c.lineTo(0, h * .0691);
    c.lineTo(0, h * .4134);
    c.lineTo(w * .3162, h * .7247);
    c.close();
    c.fill();
    c.restore();
    c.setShadow(false);
    c.begin();
    c.moveTo(w * .5801, h * .5447);
    c.lineTo(w * .5801, h * .035);
    c.lineTo(w * .3162, h * .2072);
    c.lineTo(w * .3162, h * .7247);
    c.close();
    c.stroke();
    c.restore();
    c.setLineJoin("round");
    c.setShadow(false);
    c.begin();
    c.moveTo(w * .3162, h * .2072);
    c.lineTo(0, h * .0691);
    c.lineTo(0, h * .4134);
    c.lineTo(w * .3162, h * .7247);
    c.close();
    c.stroke();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.begin();
    c.moveTo(w * .5801, h * .5447);
    c.lineTo(w * .5801, h * .035);
    c.lineTo(w * .1054, 0);
    c.lineTo(0, h * .0691);
    c.lineTo(0, h * .4134);
    c.lineTo(w * .3188, h * .7247);
    c.close();
    c.stroke();
    c.restore();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(w, h * .929);
    c.lineTo(w, h * .5866);
    c.lineTo(w * .6829, h * .1031);
    c.lineTo(w * .4216, h * .2753);
    c.lineTo(w * .4216, h * .7928);
    c.lineTo(w * .8946, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeAws3dVpcGateway.prototype.foreground = function(c, x, y, w, h, strokeWidth) {
    c.restore();
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setShadow(false);
    c.setLineJoin("round");
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dVpcGateway.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w, h * .929);
    c.lineTo(w, h * .5866);
    c.lineTo(w * .8946, h * .6537);
    c.lineTo(w * .8946, h);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(w * .8946, h);
    c.lineTo(w * .8946, h * .6537);
    c.lineTo(w * .4216, h * .2753);
    c.lineTo(w * .4216, h * .7928);
    c.close();
    c.fill();
    c.restore();
    c.setShadow(false);
    c.setLineJoin("round");
    c.begin();
    c.moveTo(w, h * .929);
    c.lineTo(w, h * .5866);
    c.lineTo(w * .8946, h * .6537);
    c.lineTo(w * .8946, h);
    c.close();
    c.stroke();
    c.begin();
    c.moveTo(w * .8946, h);
    c.lineTo(w * .8946, h * .6537);
    c.lineTo(w * .4216, h * .2753);
    c.lineTo(w * .4216, h * .7928);
    c.close();
    c.stroke();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(w, h * .929);
    c.lineTo(w, h * .5866);
    c.lineTo(w * .6829, h * .1031);
    c.lineTo(w * .4216, h * .2753);
    c.lineTo(w * .4216, h * .7928);
    c.lineTo(w * .8946, h);
    c.close();
    c.stroke();
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .5587, h * .7743);
    c.lineTo(w * .5587, h * .6274);
    c.lineTo(w * .5775, h * .6342);
    c.lineTo(w * .5775, h * .57);
    c.arcTo(w * .0428, h * .0486, 0, 0, 1, w * .6058, h * .5253);
    c.arcTo(w * .0686, h * .0778, 0, 0, 1, w * .6564, h * .5447);
    c.arcTo(w * .0857, h * .0973, 0, 0, 1, w * .6847, h * .607);
    c.lineTo(w * .6847, h * .6877);
    c.lineTo(w * .7001, h * .6946);
    c.lineTo(w * .7001, h * .8405);
    c.close();
    c.moveTo(w * .6564, h * .6741);
    c.lineTo(w * .6564, h * .6177);
    c.arcTo(w * .06, h * .0681, 0, 0, 0, w * .6392, h * .57);
    c.arcTo(w * .0343, h * .0389, 0, 0, 0, w * .6195, h * .5574);
    c.arcTo(w * .0111, h * .0126, 0, 0, 0, w * .6058, h * .5691);
    c.lineTo(w * .6058, h * .6498);
    c.close();
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeAws3dVpcGateway.prototype.cst.VPC_GATEWAY, mxShapeAws3dVpcGateway);
function mxShapeAws3dWebServer(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dWebServer, mxShape);
mxShapeAws3dWebServer.prototype.cst = {
    WEB_SERVER: "mxgraph.aws3d.webServer",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dWebServer.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 123;
    var strokeWidth2 = strokeWidth * h / 106;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    this.background(c, 0, 0, w, h, strokeWidth);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h, strokeWidth)
}
;
mxShapeAws3dWebServer.prototype.background = function(c, x, y, w, h, strokeWidth) {
    c.setStrokeWidth(strokeWidth);
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .6651);
    c.lineTo(0, h * .3349);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h * .3349);
    c.lineTo(w, h * .6651);
    c.lineTo(w * .5, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeAws3dWebServer.prototype.foreground = function(c, x, y, w, h, strokeWidth) {
    c.restore();
    c.setShadow(false);
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dWebServer.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(0, h * .3349);
    c.lineTo(w * .5, h * .6651);
    c.lineTo(w * .5, h);
    c.lineTo(0, h * .6651);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .5, h * .6651);
    c.lineTo(w, h * .3349);
    c.lineTo(w, h * .6651);
    c.lineTo(w * .5, h);
    c.close();
    c.fill();
    c.restore();
    c.setShadow(false);
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .3349);
    c.lineTo(w * .5, h * .6651);
    c.lineTo(w * .5, h);
    c.lineTo(0, h * .6651);
    c.close();
    c.stroke();
    c.begin();
    c.moveTo(w * .5, h * .6651);
    c.lineTo(w, h * .3349);
    c.lineTo(w, h * .6651);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke();
    c.setLineJoin("miter");
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .374, h * .5189);
    c.arcTo(w * .0325, h * .0236, 0, 0, 1, w * .374, h * .4858);
    c.lineTo(w * .4797, h * .4151);
    c.arcTo(w * .0325, h * .0236, 0, 0, 1, w * .5203, h * .4151);
    c.lineTo(w * .626, h * .4858);
    c.arcTo(w * .0325, h * .0236, 0, 0, 1, w * .626, h * .516);
    c.lineTo(w * .5203, h * .5868);
    c.arcTo(w * .0325, h * .0236, 0, 0, 1, w * .4797, h * .5868);
    c.close();
    c.fill();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .6651);
    c.lineTo(0, h * .3349);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h * .3349);
    c.lineTo(w, h * .6651);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dWebServer.prototype.cst.WEB_SERVER, mxShapeAws3dWebServer);
function mxShapeAws3dDynamoDB(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dDynamoDB, mxShape);
mxShapeAws3dDynamoDB.prototype.cst = {
    DYNAMO_DB: "mxgraph.aws3d.dynamoDb",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dDynamoDB.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 181.5;
    var strokeWidth2 = strokeWidth * h / 210;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    this.background(c, 0, 0, w, h, strokeWidth);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h, strokeWidth)
}
;
mxShapeAws3dDynamoDB.prototype.background = function(c, x, y, w, h, strokeWidth) {
    c.setStrokeWidth(strokeWidth);
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .8333);
    c.lineTo(0, h * .1667);
    c.lineTo(w * .3333, h * .0014);
    c.lineTo(w * .4986, h * .1667);
    c.lineTo(w * .6639, 0);
    c.lineTo(w, h * .169);
    c.lineTo(w, h * .8333);
    c.lineTo(w * .6667, h);
    c.lineTo(w * .5014, h * .9162);
    c.lineTo(w * .3333, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeAws3dDynamoDB.prototype.foreground = function(c, x, y, w, h, strokeWidth) {
    c.restore();
    c.setShadow(false);
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dDynamoDB.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(w * .168, h * .3333);
    c.lineTo(0, h * .3333);
    c.lineTo(w * .3333, h * .5);
    c.lineTo(w * .3333, h);
    c.lineTo(0, h * .8333);
    c.lineTo(0, h * .1714);
    c.close();
    c.moveTo(w * .4986, h * .1667);
    c.lineTo(w * .6667, 0);
    c.lineTo(w, h * .169);
    c.lineTo(w * .832, h * .3348);
    c.lineTo(w, h * .3333);
    c.lineTo(w * .6667, h * .5);
    c.lineTo(w * .5014, h * .5);
    c.lineTo(w * .832, h * .3348);
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .3333, h * .5);
    c.lineTo(w * .4986, h * .5);
    c.lineTo(w * .4986, h * .9162);
    c.lineTo(w * .3333, h);
    c.close();
    c.moveTo(w * .6667, h);
    c.lineTo(w * .6667, h * .5);
    c.lineTo(w, h * .3333);
    c.lineTo(w * .832, h * .3348);
    c.lineTo(w, h * .169);
    c.lineTo(w, h * .831);
    c.close();
    c.fill();
    c.restore();
    c.setShadow(false);
    c.setLineJoin("round");
    c.begin();
    c.moveTo(w * .168, h * .3333);
    c.lineTo(0, h * .3333);
    c.lineTo(w * .3333, h * .5);
    c.lineTo(w * .3333, h);
    c.lineTo(0, h * .8333);
    c.lineTo(0, h * .1714);
    c.close();
    c.moveTo(w * .4986, h * .1667);
    c.lineTo(w * .6667, 0);
    c.lineTo(w, h * .169);
    c.lineTo(w * .832, h * .3348);
    c.lineTo(w, h * .3333);
    c.lineTo(w * .6667, h * .5);
    c.lineTo(w * .5014, h * .5);
    c.lineTo(w * .832, h * .3348);
    c.close();
    c.moveTo(w * .3333, h * .5);
    c.lineTo(w * .4986, h * .5);
    c.lineTo(w * .4986, h * .9162);
    c.lineTo(w * .3333, h);
    c.close();
    c.moveTo(w * .6667, h);
    c.lineTo(w * .6667, h * .5);
    c.lineTo(w, h * .3333);
    c.lineTo(w, h * .831);
    c.close();
    c.moveTo(w * .168, h * .3333);
    c.lineTo(w * .5, h * .1667);
    c.moveTo(w * .168, h * .3333);
    c.lineTo(w * .5014, h * .5);
    c.stroke();
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .4876, h * .2262);
    c.arcTo(w * .303, h * .2619, 0, 0, 1, w * .5647, h * .25);
    c.arcTo(w * .4407, h * .381, 0, 0, 1, w * .6419, h * .2905);
    c.arcTo(w * .303, h * .2619, 0, 0, 1, w * .6799, h * .32);
    c.arcTo(w * .0132, h * .0076, 0, 0, 1, w * .6634, h * .3314);
    c.arcTo(w * .303, h * .2619, 0, 0, 1, w * .5978, h * .3119);
    c.arcTo(w * .4408, h * .381, 0, 0, 1, w * .508, h * .2667);
    c.arcTo(w * .303, h * .2619, 0, 0, 1, w * .4711, h * .2343);
    c.arcTo(w * .0132, h * .0076, 0, 0, 1, w * .4876, h * .2262);
    c.close();
    c.fill();
    c.begin();
    c.moveTo(w * .5124, h * .4143);
    c.arcTo(w * .1102, h * .0952, 0, 0, 1, w * .4683, h * .4095);
    c.arcTo(w * .4408, h * .381, 0, 0, 1, w * .3829, h * .3757);
    c.arcTo(w * .4408, h * .381, 0, 0, 1, w * .3196, h * .3371);
    c.arcTo(w * .0661, h * .0357, 0, 0, 1, w * .3058, h * .3081);
    c.lineTo(w * .4612, h * .2333);
    c.arcTo(w * .0661, h * .0476, 0, 0, 0, w * .4744, h * .2548);
    c.arcTo(w * .3306, h * .2857, 0, 0, 0, w * .53, h * .2905);
    c.arcTo(w * .4408, h * .381, 0, 0, 0, w * .6198, h * .3295);
    c.arcTo(w * .1102, h * .0952, 0, 0, 0, w * .665, h * .3367);
    c.close();
    c.moveTo(w * .5052, h * .3714);
    c.arcTo(w * .0275, h * .019, 0, 0, 1, w * .5135, h * .3581);
    c.arcTo(w * .0275, h * .0238, 0, 0, 1, w * .5344, h * .3571);
    c.lineTo(w * .5405, h * .3471);
    c.arcTo(w * .0275, h * .0143, 0, 0, 1, w * .5278, h * .3381);
    c.arcTo(w * .022, h * .0119, 0, 0, 1, w * .5372, h * .3271);
    c.lineTo(w * .5306, h * .3186);
    c.arcTo(w * .0331, h * .0286, 0, 0, 1, w * .5041, h * .3143);
    c.arcTo(w * .0275, h * .0143, 0, 0, 1, w * .4975, h * .3029);
    c.lineTo(w * .4777, h * .2995);
    c.arcTo(w * .0331, h * .0286, 0, 0, 1, w * .4628, h * .3033);
    c.arcTo(w * .0331, h * .0286, 0, 0, 1, w * .4408, h * .2967);
    c.lineTo(w * .4187, h * .3);
    c.arcTo(w * .011, h * .0081, 0, 0, 1, w * .4132, h * .3124);
    c.arcTo(w * .0386, h * .0333, 0, 0, 1, w * .395, h * .3129);
    c.lineTo(w * .3873, h * .3224);
    c.arcTo(w * .0165, h * .0143, 0, 0, 1, w * .3994, h * .3333);
    c.arcTo(w * .0138, h * .0119, 0, 0, 1, w * .3901, h * .3433);
    c.lineTo(w * .3994, h * .3514);
    c.arcTo(w * .0331, h * .0286, 0, 0, 1, w * .4215, h * .3548);
    c.arcTo(w * .0165, h * .0119, 0, 0, 1, w * .4298, h * .3667);
    c.lineTo(w * .449, h * .3714);
    c.arcTo(w * .0331, h * .0286, 0, 0, 1, w * .4711, h * .3657);
    c.arcTo(w * .0331, h * .0286, 0, 0, 1, w * .4887, h * .3724);
    c.close();
    c.moveTo(w * .4986, h * .351);
    c.arcTo(w * .0441, h * .0381, 0, 0, 1, w * .4804, h * .3552);
    c.arcTo(w * .1102, h * .0952, 0, 0, 1, w * .443, h * .349);
    c.lineTo(w * .4413, h * .3529);
    c.lineTo(w * .4242, h * .3371);
    c.arcTo(w * .1102, h * .0952, 0, 0, 0, w * .4545, h * .3462);
    c.arcTo(w * .1102, h * .0952, 0, 0, 0, w * .4793, h * .3476);
    c.arcTo(w * .0441, h * .0381, 0, 0, 0, w * .4986, h * .3448);
    c.close();
    c.moveTo(w * .503, h * .3349);
    c.arcTo(w * .1102, h * .0952, 0, 0, 0, w * .4766, h * .3233);
    c.arcTo(w * .0826, h * .0714, 0, 0, 0, w * .4529, h * .32);
    c.arcTo(w * .0551, h * .0476, 0, 0, 0, w * .4325, h * .3238);
    c.lineTo(w * .427, h * .3195);
    c.arcTo(w * .0826, h * .0714, 0, 0, 1, w * .4556, h * .3157);
    c.arcTo(w * .0826, h * .0714, 0, 0, 1, w * .4851, h * .3232);
    c.lineTo(w * .4876, h * .3181);
    c.close();
    c.fill();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .8333);
    c.lineTo(0, h * .1667);
    c.lineTo(w * .3333, h * .0014);
    c.lineTo(w * .4986, h * .1667);
    c.lineTo(w * .6639, 0);
    c.lineTo(w, h * .169);
    c.lineTo(w, h * .8333);
    c.lineTo(w * .6667, h);
    c.lineTo(w * .5014, h * .9162);
    c.lineTo(w * .3333, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dDynamoDB.prototype.cst.DYNAMO_DB, mxShapeAws3dDynamoDB);
function mxShapeAws3dElasticMapReduce(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dElasticMapReduce, mxShape);
mxShapeAws3dElasticMapReduce.prototype.cst = {
    ELASTIC_MAP_REDUCE: "mxgraph.aws3d.elasticMapReduce",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dElasticMapReduce.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 123;
    var strokeWidth2 = strokeWidth * h / 133;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    c.setStrokeWidth(strokeWidth);
    this.background(c, 0, 0, w, h, strokeWidth);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h, strokeWidth)
}
;
mxShapeAws3dElasticMapReduce.prototype.background = function(c, x, y, w, h, strokeWidth) {
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .7331);
    c.lineTo(0, h * .3346);
    c.lineTo(w * .126, h * .1316);
    c.lineTo(w * .374, 0);
    c.lineTo(w * .626, 0);
    c.lineTo(w * .874, h * .1316);
    c.lineTo(w, h * .3346);
    c.lineTo(w, h * .7331);
    c.lineTo(w * .5, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeAws3dElasticMapReduce.prototype.foreground = function(c, x, y, w, h, strokeWidth) {
    c.restore();
    c.setShadow(false);
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dDynamoDB.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(w * .126, h * .1316);
    c.lineTo(w * .126, h * .267);
    c.lineTo(w * .378, h * .4023);
    c.lineTo(w * .5, h * .6015);
    c.lineTo(w * .5, h);
    c.lineTo(0, h * .7331);
    c.lineTo(0, h * .3346);
    c.close();
    c.moveTo(w * .874, h * .267);
    c.lineTo(w * .874, h * .1316);
    c.lineTo(w, h * .3308);
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .5, h);
    c.lineTo(w * .5, h * .6015);
    c.lineTo(w * .622, h * .4023);
    c.lineTo(w * .874, h * .267);
    c.lineTo(w, h * .3308);
    c.lineTo(w, h * .7331);
    c.close();
    c.fill();
    c.restore();
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setFillColor(strokeColor);
    c.setShadow(false);
    c.begin();
    c.moveTo(w * .3336, h * .1789);
    c.arcTo(w * .0328, h * .0301, 0, 0, 1, w * .359, h * .1789);
    c.lineTo(w * .4001, h * .2015);
    c.arcTo(w * .0074, h * .0068, 0, 0, 1, w * .4008, h * .2135);
    c.lineTo(w * .3574, h * .2368);
    c.arcTo(w * .0328, h * .0301, 0, 0, 1, w * .3352, h * .2368);
    c.lineTo(w * .2934, h * .2143);
    c.arcTo(w * .0074, h * .0068, 0, 0, 1, w * .2934, h * .2015);
    c.close();
    c.moveTo(w * .3705, h * .1729);
    c.arcTo(w * .0074, h * .0068, 0, 0, 1, w * .3705, h * .1602);
    c.lineTo(w * .4139, h * .1368);
    c.arcTo(w * .0328, h * .0301, 0, 0, 1, w * .4336, h * .1368);
    c.lineTo(w * .4811, h * .1617);
    c.arcTo(w * .0074, h * .0068, 0, 0, 1, w * .4811, h * .1708);
    c.lineTo(w * .4328, h * .1955);
    c.arcTo(w * .0328, h * .0301, 0, 0, 1, w * .4156, h * .1955);
    c.close();
    c.moveTo(w * .4467, h * .1308);
    c.arcTo(w * .0074, h * .0068, 0, 0, 1, w * .4467, h * .1203);
    c.lineTo(w * .491, h * .0962);
    c.arcTo(w * .0328, h * .0301, 0, 0, 1, w * .5123, h * .0962);
    c.lineTo(w * .559, h * .1203);
    c.arcTo(w * .0074, h * .0068, 0, 0, 1, w * .559, h * .1293);
    c.lineTo(w * .5123, h * .1549);
    c.arcTo(w * .0328, h * .0301, 0, 0, 1, w * .4918, h * .1549);
    c.close();
    c.moveTo(w * .568, h * .1383);
    c.arcTo(w * .0328, h * .0301, 0, 0, 1, w * .5918, h * .1383);
    c.lineTo(w * .6361, h * .1624);
    c.arcTo(w * .0074, h * .0068, 0, 0, 1, w * .6366, h * .1714);
    c.lineTo(w * .5885, h * .1955);
    c.arcTo(w * .0328, h * .0301, 0, 0, 1, w * .568, h * .1955);
    c.lineTo(w * .523, h * .1714);
    c.arcTo(w * .0074, h * .0068, 0, 0, 1, w * .523, h * .1616);
    c.close();
    c.moveTo(w * .6451, h * .1789);
    c.arcTo(w * .0328, h * .0301, 0, 0, 1, w * .6697, h * .1789);
    c.lineTo(w * .7123, h * .2023);
    c.arcTo(w * .0074, h * .0068, 0, 0, 1, w * .7123, h * .2128);
    c.lineTo(w * .6664, h * .2376);
    c.arcTo(w * .0328, h * .0301, 0, 0, 1, w * .6492, h * .2376);
    c.lineTo(w * .6016, h * .2135);
    c.arcTo(w * .0074, h * .0068, 0, 0, 1, w * .6016, h * .2023);
    c.close();
    c.moveTo(w * .6369, h * .2451);
    c.arcTo(w * .0074, h * .0068, 0, 0, 1, w * .6369, h * .2526);
    c.lineTo(w * .5172, h * .3173);
    c.arcTo(w * .0328, h * .0301, 0, 0, 1, w * .4893, h * .3173);
    c.lineTo(w * .3697, h * .2541);
    c.arcTo(w * .0074, h * .0068, 0, 0, 1, w * .3697, h * .2436);
    c.lineTo(w * .4918, h * .1782);
    c.arcTo(w * .0328, h * .0301, 0, 0, 1, w * .5131, h * .1782);
    c.close();
    c.fill();
    c.moveTo(w * 0, h * 0);
    c.lineTo(w * 0, h * 0);
    c.arcTo(w * 0, h * 0, 0, 0, 1, w * 0, h * 0);
    c.setLineJoin("round");
    c.begin();
    c.moveTo(w * .126, h * .1316);
    c.lineTo(w * .126, h * .267);
    c.lineTo(w * .378, h * .4023);
    c.lineTo(w * .5, h * .6015);
    c.lineTo(w * .622, h * .4023);
    c.lineTo(w * .874, h * .267);
    c.lineTo(w * .874, h * .1316);
    c.moveTo(0, h * .3346);
    c.lineTo(w * .126, h * .267);
    c.moveTo(w * .5, h * .6015);
    c.lineTo(w * .5, h);
    c.moveTo(w, h * .3346);
    c.lineTo(w * .87, h * .267);
    c.moveTo(w * .378, h * .4023);
    c.lineTo(w * .622, h * .4023);
    c.stroke();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.begin();
    c.moveTo(0, h * .7331);
    c.lineTo(0, h * .3346);
    c.lineTo(w * .126, h * .1316);
    c.lineTo(w * .374, 0);
    c.lineTo(w * .626, 0);
    c.lineTo(w * .874, h * .1316);
    c.lineTo(w, h * .3346);
    c.lineTo(w, h * .7331);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dElasticMapReduce.prototype.cst.ELASTIC_MAP_REDUCE, mxShapeAws3dElasticMapReduce);
function mxShapeAws3dRdsSlave(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dRdsSlave, mxShape);
mxShapeAws3dRdsSlave.prototype.cst = {
    RDS_SLAVE: "mxgraph.aws3d.rdsSlave"
};
mxShapeAws3dRdsSlave.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 123;
    var strokeWidth2 = strokeWidth * h / 133;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    c.setStrokeWidth(strokeWidth);
    this.background(c, 0, 0, w, h, strokeWidth);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h, strokeWidth)
}
;
mxShapeAws3dRdsSlave.prototype.background = function(c, x, y, w, h, strokeWidth) {
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .7331);
    c.lineTo(0, h * .3346);
    c.lineTo(w * .126, h * .1316);
    c.lineTo(w * .374, 0);
    c.lineTo(w * .626, 0);
    c.lineTo(w * .874, h * .1316);
    c.lineTo(w, h * .3346);
    c.lineTo(w, h * .7331);
    c.lineTo(w * .5, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeAws3dRdsSlave.prototype.foreground = function(c, x, y, w, h, strokeWidth) {
    c.restore();
    c.setShadow(false);
    c.setFillColor("#000000");
    c.setAlpha("0.1");
    c.begin();
    c.moveTo(w * .126, h * .1316);
    c.lineTo(w * .126, h * .267);
    c.lineTo(w * .378, h * .4023);
    c.lineTo(w * .5, h * .6015);
    c.lineTo(w * .5, h);
    c.lineTo(0, h * .7331);
    c.lineTo(0, h * .3346);
    c.close();
    c.moveTo(w * .874, h * .267);
    c.lineTo(w * .874, h * .1316);
    c.lineTo(w, h * .3308);
    c.fill();
    c.setAlpha("0.3");
    c.begin();
    c.moveTo(w * .5, h);
    c.lineTo(w * .5, h * .6015);
    c.lineTo(w * .622, h * .4023);
    c.lineTo(w * .874, h * .267);
    c.lineTo(w, h * .3308);
    c.lineTo(w, h * .7331);
    c.close();
    c.fill();
    c.restore();
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setFillColor(strokeColor);
    c.setShadow(false);
    c.begin();
    c.moveTo(w * .2457, h * .2137);
    c.lineTo(w * .5393, h * .0593);
    c.lineTo(w * .6875, h * .1377);
    c.arcTo(w * .0871, h * .0799, 0, 0, 1, w * .7137, h * .1625);
    c.arcTo(w * .0348, h * .032, 0, 0, 1, w * .7076, h * .1968);
    c.arcTo(w * .1743, h * .1599, 0, 0, 1, w * .6597, h * .2249);
    c.arcTo(w * .1307, h * .1199, 0, 0, 1, w * .5943, h * .232);
    c.arcTo(w * .1307, h * .1199, 0, 0, 1, w * .5542, h * .2225);
    c.arcTo(w * .0871, h * .0799, 0, 0, 1, w * .5673, h * .2353);
    c.arcTo(w * .0261, h * .024, 0, 0, 1, w * .5611, h * .2729);
    c.lineTo(w * .4889, h * .316);
    c.arcTo(w * .0261, h * .024, 0, 0, 0, w * .4766, h * .3352);
    c.lineTo(w * .4052, h * .2992);
    c.arcTo(w * .0173, h * .0159, 0, 0, 1, w * .4121, h * .2841);
    c.lineTo(w * .4914, h * .2368);
    c.arcTo(w * .0218, h * .02, 0, 0, 0, w * .4897, h * .2129);
    c.lineTo(w * .4409, h * .1857);
    c.lineTo(w * .3145, h * .2529);
    c.close();
    c.moveTo(w * .4801, h * .1633);
    c.lineTo(w * .5263, h * .1865);
    c.arcTo(w * .0871, h * .0799, 0, 0, 0, w * .583, h * .1905);
    c.arcTo(w * .1307, h * .1199, 0, 0, 0, w * .6196, h * .1721);
    c.arcTo(w * .0261, h * .024, 0, 0, 0, w * .6117, h * .1441);
    c.lineTo(w * .5655, h * .1193);
    c.fill();
    c.setLineJoin("round");
    c.begin();
    c.moveTo(w * .126, h * .1316);
    c.lineTo(w * .126, h * .267);
    c.lineTo(w * .378, h * .4023);
    c.lineTo(w * .5, h * .6015);
    c.lineTo(w * .622, h * .4023);
    c.lineTo(w * .874, h * .267);
    c.lineTo(w * .874, h * .1316);
    c.moveTo(0, h * .3346);
    c.lineTo(w * .126, h * .267);
    c.moveTo(w * .5, h * .6015);
    c.lineTo(w * .5, h);
    c.moveTo(w, h * .3346);
    c.lineTo(w * .87, h * .267);
    c.moveTo(w * .378, h * .4023);
    c.lineTo(w * .622, h * .4023);
    c.stroke();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.begin();
    c.moveTo(0, h * .7331);
    c.lineTo(0, h * .3346);
    c.lineTo(w * .126, h * .1316);
    c.lineTo(w * .374, 0);
    c.lineTo(w * .626, 0);
    c.lineTo(w * .874, h * .1316);
    c.lineTo(w, h * .3346);
    c.lineTo(w, h * .7331);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dRdsSlave.prototype.cst.RDS_SLAVE, mxShapeAws3dRdsSlave);
function mxShapeAws3dAMI2(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dAMI2, mxShape);
mxShapeAws3dAMI2.prototype.cst = {
    AMI_2: "mxgraph.aws3d.ami2",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dAMI2.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var isShadow = parseFloat(mxUtils.getValue(this.state.style, "shadow", "0"));
    var strokeWidth1 = strokeWidth * w / 92;
    var strokeWidth2 = strokeWidth * h / 60;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    c.setStrokeWidth(strokeWidth);
    c.setShadow(false);
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    if (isShadow == 1)
        c.setShadow(true);
    c.begin();
    c.moveTo(0, h * .572);
    c.lineTo(w * .0865, h * .284);
    c.lineTo(w * .4203, 0);
    c.lineTo(w * .5865, 0);
    c.lineTo(w * .919, h * .286);
    c.lineTo(w, h * .566);
    c.lineTo(w * .5027, h);
    c.close();
    c.fillAndStroke();
    c.restore();
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dAMI2.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(0, h * .566);
    c.lineTo(w * .0892, h * .282);
    c.lineTo(w * .0878, h * .426);
    c.lineTo(w * .4216, h * .712);
    c.lineTo(w * .5865, h * .712);
    c.lineTo(w * .5027, h);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .5027, h);
    c.lineTo(w * .5865, h * .712);
    c.lineTo(w * .9176, h * .43);
    c.lineTo(w, h * .566);
    c.close();
    c.fill();
    c.restore();
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .566);
    c.lineTo(w * .0892, h * .282);
    c.lineTo(w * .0878, h * .426);
    c.lineTo(w * .4216, h * .712);
    c.lineTo(w * .5865, h * .712);
    c.lineTo(w * .5027, h);
    c.close();
    c.moveTo(w * .5027, h);
    c.lineTo(w * .5865, h * .712);
    c.lineTo(w * .9176, h * .43);
    c.lineTo(w, h * .566);
    c.close();
    c.moveTo(0, h * .572);
    c.lineTo(w * .0892, h * .422);
    c.moveTo(w * .5027, h);
    c.lineTo(w * .4189, h * .708);
    c.moveTo(w * .9176, h * .43);
    c.lineTo(w * .9176, h * .29);
    c.stroke();
    c.setStrokeWidth(2 * strokeWidth);
    c.setLineJoin("round");
    c.begin();
    c.moveTo(w * .2095, h * .376);
    c.lineTo(w * .527, h * .104);
    c.lineTo(w * .6338, h * .194);
    c.lineTo(w * .3149, h * .468);
    c.close();
    c.moveTo(w * .3716, h * .518);
    c.lineTo(w * .6892, h * .246);
    c.lineTo(w * .796, h * .336);
    c.lineTo(w * .477, h * .61);
    c.close();
    c.moveTo(w * .3108, h * .282);
    c.lineTo(w * .4257, h * .38);
    c.moveTo(w * .4189, h * .194);
    c.lineTo(w * .5297, h * .288);
    c.moveTo(w * .5838, h * .338);
    c.lineTo(w * .6892, h * .426);
    c.moveTo(w * .4757, h * .426);
    c.lineTo(w * .5838, h * .518);
    c.stroke();
    c.setStrokeColor("#292929");
    c.begin();
    c.moveTo(0, h * .572);
    c.lineTo(w * .0865, h * .284);
    c.lineTo(w * .4203, 0);
    c.lineTo(w * .5865, 0);
    c.lineTo(w * .919, h * .286);
    c.lineTo(w, h * .566);
    c.lineTo(w * .5027, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dAMI2.prototype.cst.AMI_2, mxShapeAws3dAMI2);
function mxShapeAws3dEbs(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dEbs, mxShape);
mxShapeAws3dEbs.prototype.cst = {
    EBS: "mxgraph.aws3d.ebs",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dEbs.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 92;
    var strokeWidth2 = strokeWidth * h / 60;
    var isShadow = parseFloat(mxUtils.getValue(this.state.style, "shadow", "0"));
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    c.setStrokeWidth(strokeWidth);
    c.setShadow(false);
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    if (isShadow == 1)
        c.setShadow(true);
    c.begin();
    c.moveTo(0, h * .5276);
    c.lineTo(0, h * .4188);
    c.lineTo(w * .071, h * .2898);
    c.lineTo(w * .4033, 0);
    c.lineTo(w * .9301, h * .464);
    c.lineTo(w, h * .5863);
    c.lineTo(w, h * .7035);
    c.lineTo(w * .6667, h);
    c.lineTo(w * .5355, h);
    c.close();
    c.fillAndStroke();
    c.restore();
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dEbs.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(w * .071, h * .2948);
    c.lineTo(w * .6011, h * .7621);
    c.lineTo(w * .6667, h);
    c.lineTo(w * .5355, h);
    c.lineTo(0, h * .5276);
    c.lineTo(0, h * .4137);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .6011, h * .7655);
    c.lineTo(w * .9344, h * .4724);
    c.lineTo(w, h * .7035);
    c.lineTo(w * .6667, h);
    c.close();
    c.fill();
    c.restore();
    c.setLineJoin("round");
    c.begin();
    c.moveTo(w * .071, h * .2948);
    c.lineTo(w * .6011, h * .7621);
    c.lineTo(w * .6667, h);
    c.lineTo(w * .5355, h);
    c.lineTo(0, h * .5276);
    c.lineTo(0, h * .4137);
    c.close();
    c.moveTo(w * .6011, h * .7655);
    c.lineTo(w * .9344, h * .4724);
    c.lineTo(w, h * .7035);
    c.lineTo(w * .6667, h);
    c.close();
    c.moveTo(w * .0033, h * .5276);
    c.lineTo(w * .071, h * .2898);
    c.moveTo(w * .5325, h * .9976);
    c.lineTo(w * .603, h * .7593);
    c.stroke();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .5276);
    c.lineTo(0, h * .4188);
    c.lineTo(w * .071, h * .2898);
    c.lineTo(w * .4033, 0);
    c.lineTo(w * .9301, h * .464);
    c.lineTo(w, h * .5863);
    c.lineTo(w, h * .7035);
    c.lineTo(w * .6667, h);
    c.lineTo(w * .5355, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dEbs.prototype.cst.EBS, mxShapeAws3dEbs);
function mxShapeAws3dOracleServer(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dOracleServer, mxShape);
mxShapeAws3dOracleServer.prototype.cst = {
    ORACLE_SERVER: "mxgraph.aws3d.oracleServer"
};
mxShapeAws3dOracleServer.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 123;
    var strokeWidth2 = strokeWidth * h / 133;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    c.setStrokeWidth(strokeWidth);
    this.background(c, 0, 0, w, h, strokeWidth);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h, strokeWidth)
}
;
mxShapeAws3dOracleServer.prototype.background = function(c, x, y, w, h, strokeWidth) {
    c.save();
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .7464);
    c.lineTo(0, h * .25);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h * .25);
    c.lineTo(w, h * .7464);
    c.lineTo(w * .5, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeAws3dOracleServer.prototype.foreground = function(c, x, y, w, h, strokeWidth) {
    c.restore();
    c.setShadow(false);
    c.setFillColor("#000000");
    c.setAlpha("0.1");
    c.begin();
    c.moveTo(0, h * .7464);
    c.lineTo(0, h * .25);
    c.lineTo(w * .5, h * .5);
    c.lineTo(w * .5, h);
    c.close();
    c.fill();
    c.setAlpha("0.3");
    c.begin();
    c.moveTo(w * .5, h * .5);
    c.lineTo(w, h * .25);
    c.lineTo(w, h * .7464);
    c.lineTo(w * .5, h);
    c.close();
    c.fill();
    c.restore();
    c.setShadow(false);
    c.setLineJoin("round");
    c.setFillColor("#ff0000");
    c.begin();
    c.moveTo(0, h * .5866);
    c.lineTo(w * .5, h * .8359);
    c.lineTo(w, h * .5866);
    c.lineTo(w, h * .6986);
    c.lineTo(w * .5, h * .9486);
    c.lineTo(0, h * .6986);
    c.fill();
    c.setStrokeWidth(.5 * strokeWidth);
    c.setStrokeColor("#ffffff");
    c.setFillColor("#ffffff");
    c.begin();
    c.moveTo(0, h * .5866);
    c.lineTo(w * .5, h * .8359);
    c.lineTo(w, h * .5866);
    c.moveTo(w, h * .6986);
    c.lineTo(w * .5, h * .9486);
    c.lineTo(0, h * .6986);
    c.stroke();
    c.begin();
    c.moveTo(w * .0813, h * .7113);
    c.arcTo(w * .0569, h * .0493, 0, 0, 1, w * .065, h * .6831);
    c.arcTo(w * .065, h * .0563, 0, 0, 1, w * .065, h * .6613);
    c.arcTo(w * .0163, h * .0141, 0, 0, 1, w * .0797, h * .6549);
    c.lineTo(w * .122, h * .6754);
    c.arcTo(w * .065, h * .0563, 0, 0, 1, w * .1358, h * .6937);
    c.arcTo(w * .065, h * .0563, 0, 0, 1, w * .139, h * .7232);
    c.arcTo(w * .0179, h * .0155, 0, 0, 1, w * .1187, h * .7296);
    c.close();
    c.moveTo(w * .1163, h * .7183);
    c.arcTo(w * .0089, h * .0077, 0, 0, 0, w * .1285, h * .7148);
    c.arcTo(w * .0407, h * .0352, 0, 0, 0, w * .1293, h * .7021);
    c.arcTo(w * .0407, h * .0352, 0, 0, 0, w * .1179, h * .6831);
    c.lineTo(w * .087, h * .6676);
    c.arcTo(w * .0081, h * .007, 0, 0, 0, w * .0764, h * .6697);
    c.arcTo(w * .0325, h * .0352, 0, 0, 0, w * .078, h * .6937);
    c.arcTo(w * .0407, h * .0352, 0, 0, 0, w * .087, h * .7035);
    c.close();
    c.moveTo(w * .1439, h * .743);
    c.lineTo(w * .1439, h * .6866);
    c.lineTo(w * .1846, h * .707);
    c.arcTo(w * .0407, h * .0352, 0, 0, 1, w * .1967, h * .7183);
    c.arcTo(w * .0407, h * .0352, 0, 0, 1, w * .2, h * .738);
    c.arcTo(w * .0138, h * .0155, 0, 0, 1, w * .1813, h * .743);
    c.lineTo(w * .1992, h * .769);
    c.lineTo(w * .187, h * .7641);
    c.lineTo(w * .1577, h * .7218);
    c.lineTo(w * .1854, h * .7345);
    c.arcTo(w * .0041, h * .0035, 0, 0, 0, w * .1911, h * .7317);
    c.arcTo(w * .0163, h * .0141, 0, 0, 0, w * .1894, h * .7225);
    c.arcTo(w * .0325, h * .0282, 0, 0, 0, w * .1821, h * .7155);
    c.lineTo(w * .1528, h * .7007);
    c.lineTo(w * .1528, h * .7472);
    c.close();
    c.moveTo(w * .2008, h * .7711);
    c.lineTo(w * .2293, h * .7338);
    c.arcTo(w * .0065, h * .0056, 0, 0, 1, w * .2382, h * .7324);
    c.arcTo(w * .0407, h * .0352, 0, 0, 1, w * .2431, h * .7415);
    c.lineTo(w * .2699, h * .8035);
    c.lineTo(w * .2602, h * .8007);
    c.lineTo(w * .252, h * .7859);
    c.lineTo(w * .2293, h * .7754);
    c.lineTo(w * .2244, h * .7634);
    c.lineTo(w * .248, h * .7739);
    c.lineTo(w * .235, h * .7444);
    c.lineTo(w * .2122, h * .7768);
    c.close();
    c.moveTo(w * .3244, h * .8225);
    c.lineTo(w * .3171, h * .8289);
    c.lineTo(w * .2854, h * .8127);
    c.arcTo(w * .0407, h * .0352, 0, 0, 1, w * .2724, h * .7986);
    c.arcTo(w * .0569, h * .0493, 0, 0, 1, w * .265, h * .7746);
    c.arcTo(w * .0407, h * .0352, 0, 0, 1, w * .2683, h * .762);
    c.arcTo(w * .0163, h * .0141, 0, 0, 1, w * .2829, h * .757);
    c.lineTo(w * .3228, h * .7761);
    c.lineTo(w * .3179, h * .7831);
    c.lineTo(w * .2878, h * .7683);
    c.arcTo(w * .0081, h * .007, 0, 0, 0, w * .2789, h * .7697);
    c.arcTo(w * .0244, h * .0211, 0, 0, 0, w * .2748, h * .7831);
    c.arcTo(w * .0407, h * .0352, 0, 0, 0, w * .2878, h * .8042);
    c.close();
    c.moveTo(w * .3276, h * .7789);
    c.lineTo(w * .3366, h * .7831);
    c.lineTo(w * .3366, h * .8289);
    c.lineTo(w * .3805, h * .8507);
    c.lineTo(w * .3748, h * .857);
    c.lineTo(w * .3317, h * .8359);
    c.arcTo(w * .0163, h * .0141, 0, 0, 1, w * .3276, h * .8275);
    c.close();
    c.moveTo(w * .435, h * .8775);
    c.lineTo(w * .4325, h * .8866);
    c.lineTo(w * .3959, h * .8683);
    c.arcTo(w * .0407, h * .0352, 0, 0, 1, w * .3862, h * .8563);
    c.arcTo(w * .0528, h * .0458, 0, 0, 1, w * .3805, h * .8183);
    c.arcTo(w * .0163, h * .0141, 0, 0, 1, w * .3951, h * .8134);
    c.lineTo(w * .435, h * .8324);
    c.lineTo(w * .4285, h * .838);
    c.lineTo(w * .4008, h * .8246);
    c.arcTo(w * .0098, h * .0085, 0, 0, 0, w * .3878, h * .831);
    c.lineTo(w * .4333, h * .8542);
    c.lineTo(w * .426, h * .8606);
    c.lineTo(w * .3878, h * .8415);
    c.arcTo(w * .0325, h * .0282, 0, 0, 0, w * .3976, h * .8585);
    c.close();
    c.moveTo(w * .6171, h * .8063);
    c.arcTo(w * .0163, h * .0141, 0, 0, 1, w * .6366, h * .8092);
    c.arcTo(w * .0325, h * .0282, 0, 0, 1, w * .639, h * .8303);
    c.arcTo(w * .065, h * .0563, 0, 0, 1, w * .6211, h * .8592);
    c.lineTo(w * .5894, h * .8761);
    c.arcTo(w * .0203, h * .0176, 0, 0, 1, w * .565, h * .8732);
    c.arcTo(w * .0407, h * .0352, 0, 0, 1, w * .5659, h * .8458);
    c.arcTo(w * .0488, h * .0422, 0, 0, 1, w * .5805, h * .8246);
    c.close();
    c.moveTo(w * .5886, h * .8296);
    c.arcTo(w * .0325, h * .0282, 0, 0, 0, w * .5748, h * .8472);
    c.arcTo(w * .0325, h * .0282, 0, 0, 0, w * .574, h * .862);
    c.arcTo(w * .0098, h * .0085, 0, 0, 0, w * .587, h * .8676);
    c.lineTo(w * .6163, h * .8528);
    c.arcTo(w * .0407, h * .0352, 0, 0, 0, w * .6285, h * .8359);
    c.arcTo(w * .0244, h * .0211, 0, 0, 0, w * .6293, h * .8225);
    c.arcTo(w * .0098, h * .0085, 0, 0, 0, w * .6163, h * .8155);
    c.close();
    c.moveTo(w * .64, h * .85);
    c.lineTo(w * .64, h * .793);
    c.lineTo(w * .6854, h * .7718);
    c.arcTo(w * .0106, h * .0092, 0, 0, 1, w * .7008, h * .7782);
    c.arcTo(w * .0407, h * .0352, 0, 0, 1, w * .6959, h * .8);
    c.arcTo(w * .0407, h * .0352, 0, 0, 1, w * .6805, h * .8127);
    c.lineTo(w * .6992, h * .8218);
    c.lineTo(w * .6854, h * .8282);
    c.lineTo(w * .6569, h * .8141);
    c.lineTo(w * .6805, h * .8021);
    c.arcTo(w * .0203, h * .0176, 0, 0, 0, w * .6894, h * .7923);
    c.arcTo(w * .0244, h * .0211, 0, 0, 0, w * .6894, h * .7845);
    c.arcTo(w * .0041, h * .0035, 0, 0, 0, w * .6837, h * .7831);
    c.lineTo(w * .6528, h * .7979);
    c.lineTo(w * .6528, h * .8437);
    c.close();
    c.moveTo(w * .7, h * .8204);
    c.lineTo(w * .7301, h * .7507);
    c.arcTo(w * .0098, h * .0085, 0, 0, 1, w * .7358, h * .7444);
    c.arcTo(w * .0098, h * .0085, 0, 0, 1, w * .7415, h * .7486);
    c.lineTo(w * .7699, h * .7852);
    c.lineTo(w * .7602, h * .7908);
    c.lineTo(w * .7537, h * .7838);
    c.lineTo(w * .7276, h * .7958);
    c.lineTo(w * .7228, h * .788);
    c.lineTo(w * .748, h * .7768);
    c.lineTo(w * .7358, h * .7585);
    c.lineTo(w * .7114, h * .8155);
    c.close();
    c.moveTo(w * .8244, h * .7486);
    c.lineTo(w * .8171, h * .762);
    c.lineTo(w * .7894, h * .7761);
    c.arcTo(w * .0244, h * .0211, 0, 0, 1, w * .7683, h * .7746);
    c.arcTo(w * .0407, h * .0352, 0, 0, 1, w * .7667, h * .7507);
    c.arcTo(w * .0488, h * .0423, 0, 0, 1, w * .7937, h * .7162);
    c.lineTo(w * .822, h * .7035);
    c.lineTo(w * .8171, h * .7155);
    c.lineTo(w * .7902, h * .7296);
    c.arcTo(w * .0325, h * .0282, 0, 0, 0, w * .778, h * .743);
    c.arcTo(w * .0407, h * .0352, 0, 0, 0, w * .7756, h * .7606);
    c.arcTo(w * .0077, h * .0067, 0, 0, 0, w * .787, h * .767);
    c.close();
    c.moveTo(w * .8366, h * .6949);
    c.lineTo(w * .8366, h * .7423);
    c.lineTo(w * .878, h * .7231);
    c.lineTo(w * .874, h * .7338);
    c.lineTo(w * .8333, h * .7535);
    c.arcTo(w * .0041, h * .0035, 0, 0, 1, w * .8268, h * .75);
    c.lineTo(w * .8268, h * .7007);
    c.close();
    c.moveTo(w * .9342, h * .6472);
    c.lineTo(w * .9293, h * .6599);
    c.lineTo(w * .9033, h * .6725);
    c.arcTo(w * .0325, h * .0282, 0, 0, 0, w * .8927, h * .6817);
    c.arcTo(w * .0406, h * .0352, 0, 0, 0, w * .887, h * .6937);
    c.lineTo(w * .9309, h * .6725);
    c.lineTo(w * .9268, h * .6845);
    c.lineTo(w * .887, h * .7035);
    c.arcTo(w * .0089, h * .0077, 0, 0, 0, w * .8992, h * .7106);
    c.lineTo(w * .935, h * .693);
    c.lineTo(w * .9285, h * .7063);
    c.lineTo(w * .9008, h * .7197);
    c.arcTo(w * .0163, h * .0141, 0, 0, 1, w * .8829, h * .7204);
    c.arcTo(w * .0407, h * .0352, 0, 0, 1, w * .8764, h * .7028);
    c.arcTo(w * .065, h * .0563, 0, 0, 1, w * .8959, h * .6669);
    c.fill();
    c.restore();
    c.setShadow(false);
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .7464);
    c.lineTo(0, h * .25);
    c.lineTo(w * .5, h * .5);
    c.lineTo(w * .5, h);
    c.close();
    c.moveTo(w * .5, h * .5);
    c.lineTo(w, h * .25);
    c.lineTo(w, h * .7464);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke();
    c.setLineJoin("miter");
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .374, h * .3873);
    c.arcTo(w * .0325, h * .01764, 0, 0, 1, w * .374, h * .3626);
    c.lineTo(w * .4797, h * .3098);
    c.arcTo(w * .0325, h * .0141, 0, 0, 1, w * .5203, h * .3098);
    c.lineTo(w * .626, h * .3626);
    c.arcTo(w * .0325, h * .01764, 0, 0, 1, w * .626, h * .3852);
    c.lineTo(w * .5203, h * .438);
    c.arcTo(w * .0325, h * .0141, 0, 0, 1, w * .4797, h * .438);
    c.close();
    c.fill();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .7464);
    c.lineTo(0, h * .25);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h * .25);
    c.lineTo(w, h * .7464);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dOracleServer.prototype.cst.ORACLE_SERVER, mxShapeAws3dOracleServer);
function mxShapeAws3dSecureConnection(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dSecureConnection, mxShape);
mxShapeAws3dSecureConnection.prototype.cst = {
    SECURE_CONNECTION: "mxgraph.aws3d.secureConnection"
};
mxShapeAws3dSecureConnection.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 57;
    var strokeWidth2 = strokeWidth * h / 34;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    c.setStrokeWidth(strokeWidth);
    this.background(c, 0, 0, w, h, strokeWidth);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h, strokeWidth)
}
;
mxShapeAws3dSecureConnection.prototype.background = function(c, x, y, w, h, strokeWidth) {
    c.begin();
    c.moveTo(w * .0058, h * .3889);
    c.arcTo(w * .2096, h * .3536, 0, 0, 1, w * .0774, h * .1856);
    c.arcTo(w * .5241, h * .8839, 0, 0, 1, w * .308, h * .0262);
    c.arcTo(w * .8735, h * 1.4732, 0, 0, 1, w * .6417, h * .056);
    c.arcTo(w * .6988, h * 1.1786, 0, 0, 1, w * .9106, h * .277);
    c.arcTo(w * .2621, h * .442, 0, 0, 1, w, h * .5451);
    c.arcTo(w * .2096, h * .3536, 0, 0, 1, w * .9474, h * .7808);
    c.arcTo(w * .4368, h * .7366, 0, 0, 1, w * .7186, h * .9605);
    c.arcTo(w * .8735, h * 1.4732, 0, 0, 1, w * .3045, h * .9104);
    c.arcTo(w * .6115, h * 1.0312, 0, 0, 1, w * .0687, h * .6747);
    c.arcTo(w * .2096, h * .3536, 0, 0, 1, w * .0058, h * .3889);
    c.close();
    c.fill()
}
;
mxShapeAws3dSecureConnection.prototype.foreground = function(c, x, y, w, h, strokeWidth) {
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .2661, h * .5068);
    c.lineTo(w * .5002, h * .7336);
    c.lineTo(w * .6626, h * .5775);
    c.lineTo(w * .6469, h * .5539);
    c.lineTo(w * .6958, h * .5097);
    c.arcTo(w * .0874, h * .1473, 0, 0, 0, w * .7325, h * .4066);
    c.arcTo(w * .0874, h * .1473, 0, 0, 0, w * .6889, h * .3153);
    c.arcTo(w * .1747, h * .2946, 0, 0, 0, w * .5928, h * .2622);
    c.arcTo(w * .1398, h * .2357, 0, 0, 0, w * .5107, h * .3005);
    c.lineTo(w * .446, h * .3654);
    c.lineTo(w * .4268, h * .3477);
    c.close();
    c.moveTo(w * .4949, h * .4184);
    c.lineTo(w * .5491, h * .3624);
    c.arcTo(w * .1222, h * .2062, 0, 0, 1, w * .6277, h * .3536);
    c.arcTo(w * .0874, h * .1179, 0, 0, 1, w * .6679, h * .3978);
    c.arcTo(w * .0175, h * .0295, 0, 0, 1, w * .6626, h * .439);
    c.lineTo(w * .5928, h * .5068);
    c.close();
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeAws3dSecureConnection.prototype.cst.SECURE_CONNECTION, mxShapeAws3dSecureConnection);
function mxShapeAws3dEmailService(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dEmailService, mxShape);
mxShapeAws3dEmailService.prototype.cst = {
    EMAIL_SERVICE: "mxgraph.aws3d.email_service",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dEmailService.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 151;
    var strokeWidth2 = strokeWidth * h / 192;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    this.background(c, 0, 0, w, h, strokeWidth);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h, strokeWidth)
}
;
mxShapeAws3dEmailService.prototype.background = function(c, x, y, w, h, strokeWidth) {
    c.setStrokeWidth(strokeWidth);
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .8182);
    c.lineTo(0, h * .1818);
    c.lineTo(w * .4007, 0);
    c.lineTo(w * .606, 0);
    c.lineTo(w, h * .1792);
    c.lineTo(w, h * .8182);
    c.lineTo(w * .5993, h);
    c.lineTo(w * .4007, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeAws3dEmailService.prototype.foreground = function(c, x, y, w, h, strokeWidth) {
    c.restore();
    c.setShadow(false);
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dEmailService.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(0, h * .2727);
    c.lineTo(w * .4007, h * .4546);
    c.lineTo(w * .5993, h * .4546);
    c.lineTo(w * .5993, h);
    c.lineTo(w * .4007, h);
    c.lineTo(0, h * .8182);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .5993, h * .4546);
    c.lineTo(w, h * .2727);
    c.lineTo(w * .8013, h * .1792);
    c.lineTo(w * .8013, h * .0883);
    c.lineTo(w, h * .1792);
    c.lineTo(w, h * .8182);
    c.lineTo(w * .5993, h);
    c.close();
    c.fill();
    c.restore();
    c.setShadow(false);
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .2727);
    c.lineTo(w * .4007, h * .4546);
    c.lineTo(w * .5993, h * .4546);
    c.lineTo(w * .5993, h);
    c.lineTo(w * .4007, h);
    c.lineTo(0, h * .8182);
    c.close();
    c.stroke();
    c.begin();
    c.moveTo(w * .5993, h * .4546);
    c.lineTo(w, h * .2727);
    c.lineTo(w * .8013, h * .1792);
    c.lineTo(w * .8013, h * .0883);
    c.lineTo(w, h * .1792);
    c.lineTo(w, h * .8182);
    c.lineTo(w * .5993, h);
    c.close();
    c.stroke();
    c.begin();
    c.moveTo(w * .202, h * .0883);
    c.lineTo(w * .202, h * .1818);
    c.lineTo(w * .4007, h * .2727);
    c.lineTo(w * .5993, h * .2727);
    c.lineTo(w * .798, h * .1818);
    c.moveTo(w * .2053, h * .1818);
    c.lineTo(w * .0033, h * .2714);
    c.moveTo(w * .4007, h * .2727);
    c.lineTo(w * .4007, h * .9961);
    c.moveTo(w * .5993, h * .2727);
    c.lineTo(w * .5993, h * .4546);
    c.stroke();
    c.setLineJoin("miter");
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .4437, h * .0779);
    c.arcTo(w * .0662, h * .0519, 0, 0, 1, w * .404, h * .0706);
    c.arcTo(w * .0464, h * .0364, 0, 0, 1, w * .3815, h * .0421);
    c.arcTo(w * .053, h * .026, 0, 0, 1, w * .4205, h * .0187);
    c.arcTo(w * .1987, h * .1558, 0, 0, 1, w * .4768, h * .0203);
    c.arcTo(w * .0795, h * .0364, 0, 0, 1, w * .5199, h * .0494);
    c.arcTo(w * .0265, h * .0208, 0, 0, 1, w * .5099, h * .0649);
    c.arcTo(w * .0795, h * .0623, 0, 0, 1, w * .4536, h * .0727);
    c.arcTo(w * .0199, h * .0156, 0, 0, 1, w * .4404, h * .0597);
    c.arcTo(w * .0265, h * .0208, 0, 0, 1, w * .4219, h * .0566);
    c.arcTo(w * .0199, h * .0114, 0, 0, 1, w * .4172, h * .0431);
    c.arcTo(w * .0265, h * .0208, 0, 0, 1, w * .4483, h * .0416);
    c.arcTo(w * .0132, h * .0104, 0, 0, 1, w * .457, h * .053);
    c.arcTo(w * .0132, h * .0104, 0, 0, 0, w * .4669, h * .0431);
    c.arcTo(w * .0166, h * .0166, 0, 0, 0, w * .4464, h * .0358);
    c.lineTo(w * .4437, h * .0338);
    c.arcTo(w * .0199, h * .0156, 0, 0, 1, w * .4603, h * .0322);
    c.arcTo(w * .0397, h * .0156, 0, 0, 1, w * .4755, h * .0462);
    c.arcTo(w * .0199, h * .0156, 0, 0, 1, w * .4669, h * .0545);
    c.arcTo(w * .053, h * .0416, 0, 0, 1, w * .453, h * .0608);
    c.arcTo(w * .0099, h * .0078, 0, 0, 0, w * .4636, h * .0675);
    c.arcTo(w * .0662, h * .0519, 0, 0, 0, w * .498, h * .0623);
    c.arcTo(w * .0185, h * .0145, 0, 0, 0, w * .5079, h * .0457);
    c.arcTo(w * .053, h * .0416, 0, 0, 0, w * .4848, h * .0296);
    c.arcTo(w * .0993, h * .0779, 0, 0, 0, w * .455, h * .0234);
    c.arcTo(w * .1325, h * .1039, 0, 0, 0, w * .4172, h * .026);
    c.arcTo(w * .0397, h * .0312, 0, 0, 0, w * .3927, h * .039);
    c.arcTo(w * .0265, h * .0208, 0, 0, 0, w * .3974, h * .0571);
    c.arcTo(w * .053, h * .0416, 0, 0, 0, w * .4205, h * .0701);
    c.arcTo(w * .0331, h * .026, 0, 0, 0, w * .4404, h * .0722);
    c.moveTo(w * .42, h * .049);
    c.arcTo(w * .02, h * .02, 0, 0, 0, w * .435, h * .055);
    c.arcTo(w * .02, h * .02, 0, 0, 0, w * .45, h * .049);
    c.arcTo(w * .02, h * .02, 0, 0, 0, w * .435, h * .043);
    c.arcTo(w * .02, h * .02, 0, 0, 0, w * .42, h * .049);
    c.close();
    c.moveTo(w * .4669, h * .0894);
    c.arcTo(w * .1325, h * .1039, 0, 0, 0, w * .5099, h * .0831);
    c.lineTo(w * .6689, h * .1543);
    c.lineTo(w * .4887, h * .1371);
    c.close();
    c.moveTo(w * .3887, h * .0769);
    c.arcTo(w * .0662, h * .0519, 0, 0, 0, w * .4205, h * .0888);
    c.arcTo(w * .0662, h * .026, 0, 0, 0, w * .447, h * .0894);
    c.lineTo(w * .4735, h * .1512);
    c.lineTo(w * .6689, h * .1688);
    c.lineTo(w * .5199, h * .2364);
    c.lineTo(w * .2815, h * .1273);
    c.close();
    c.fill();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .8182);
    c.lineTo(0, h * .1818);
    c.lineTo(w * .4007, 0);
    c.lineTo(w * .606, 0);
    c.lineTo(w, h * .1792);
    c.lineTo(w, h * .8182);
    c.lineTo(w * .5993, h);
    c.lineTo(w * .4007, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dEmailService.prototype.cst.EMAIL_SERVICE, mxShapeAws3dEmailService);
function mxShapeAws3dWorker(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dWorker, mxShape);
mxShapeAws3dWorker.prototype.cst = {
    WORKER: "mxgraph.aws3d.worker",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dWorker.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var isShadow = parseFloat(mxUtils.getValue(this.state.style, "shadow", "0"));
    var strokeWidth1 = strokeWidth * w / 74;
    var strokeWidth2 = strokeWidth * h / 50;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    c.setStrokeWidth(strokeWidth);
    c.setShadow(false);
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    if (isShadow == 1)
        c.setShadow(true);
    c.begin();
    c.moveTo(0, h * .572);
    c.lineTo(w * .0865, h * .284);
    c.lineTo(w * .4203, 0);
    c.lineTo(w * .5865, 0);
    c.lineTo(w * .919, h * .286);
    c.lineTo(w, h * .566);
    c.lineTo(w * .5027, h);
    c.close();
    c.fillAndStroke();
    c.restore();
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dWorker.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(0, h * .566);
    c.lineTo(w * .0892, h * .282);
    c.lineTo(w * .0878, h * .426);
    c.lineTo(w * .4216, h * .712);
    c.lineTo(w * .5865, h * .712);
    c.lineTo(w * .5027, h);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .5027, h);
    c.lineTo(w * .5865, h * .712);
    c.lineTo(w * .9176, h * .43);
    c.lineTo(w, h * .566);
    c.close();
    c.fill();
    c.restore();
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .566);
    c.lineTo(w * .0892, h * .282);
    c.lineTo(w * .0878, h * .426);
    c.lineTo(w * .4216, h * .712);
    c.lineTo(w * .5865, h * .712);
    c.lineTo(w * .5027, h);
    c.close();
    c.moveTo(w * .5027, h);
    c.lineTo(w * .5865, h * .712);
    c.lineTo(w * .9176, h * .43);
    c.lineTo(w, h * .566);
    c.close();
    c.moveTo(0, h * .572);
    c.lineTo(w * .0892, h * .422);
    c.moveTo(w * .5027, h);
    c.lineTo(w * .4189, h * .708);
    c.moveTo(w * .9176, h * .43);
    c.lineTo(w * .9176, h * .29);
    c.stroke();
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setFillColor(strokeColor);
    c.setLineJoin("round");
    c.begin();
    c.moveTo(w * .2892, h * .2104);
    c.lineTo(w * .3595, h * .1503);
    c.lineTo(w * .3973, h * .1844);
    c.arcTo(w * .2703, h * .4008, 0, 0, 1, w * .4486, h * .1703);
    c.lineTo(w * .4486, h * .1242);
    c.lineTo(w * .5527, h * .1242);
    c.lineTo(w * .5527, h * .1703);
    c.arcTo(w * .2703, h * .4008, 0, 0, 1, w * .6149, h * .1924);
    c.lineTo(w * .6527, h * .1603);
    c.lineTo(w * .7257, h * .2224);
    c.lineTo(w * .6892, h * .2545);
    c.arcTo(w * .2027, h * .3006, 0, 0, 1, w * .7162, h * .3106);
    c.lineTo(w * .7676, h * .3106);
    c.lineTo(w * .7676, h * .3988);
    c.lineTo(w * .7162, h * .3988);
    c.arcTo(w * .2027, h * .3006, 0, 0, 1, w * .6973, h * .4409);
    c.lineTo(w * .7378, h * .475);
    c.lineTo(w * .6635, h * .5371);
    c.lineTo(w * .6297, h * .505);
    c.arcTo(w * .2703, h * .4008, 0, 0, 1, w * .5527, h * .5351);
    c.lineTo(w * .5527, h * .5812);
    c.lineTo(w * .45, h * .5812);
    c.lineTo(w * .45, h * .5351);
    c.arcTo(w * .2703, h * .4008, 0, 0, 1, w * .3878, h * .513);
    c.lineTo(w * .3514, h * .5431);
    c.lineTo(w * .2784, h * .481);
    c.lineTo(w * .3149, h * .4509);
    c.arcTo(w * .2027, h * .3006, 0, 0, 1, w * .2865, h * .3968);
    c.lineTo(w * .2351, h * .3968);
    c.lineTo(w * .2351, h * .3086);
    c.lineTo(w * .2865, h * .3086);
    c.arcTo(w * .2027, h * .3006, 0, 0, 1, w * .3203, h * .2425);
    c.close();
    c.moveTo(w * .4054, h * .2445);
    c.arcTo(w * .1351, h * .2004, 0, 0, 0, w * .3554, h * .2986);
    c.arcTo(w * .0676, h * .1002, 0, 0, 0, w * .3432, h * .3567);
    c.arcTo(w * .0811, h * .1202, 0, 0, 0, w * .3635, h * .4208);
    c.arcTo(w * .1351, h * .2004, 0, 0, 0, w * .4122, h * .4649);
    c.arcTo(w * .2027, h * .3006, 0, 0, 0, w * .4122, h * .4649);
    c.arcTo(w * .2027, h * .3006, 0, 0, 0, w * .5676, h * .4749);
    c.arcTo(w * .1351, h * .2004, 0, 0, 0, w * .6351, h * .4228);
    c.arcTo(w * .0676, h * .1002, 0, 0, 0, w * .6595, h * .3467);
    c.arcTo(w * .0811, h * .1202, 0, 0, 0, w * .6149, h * .2605);
    c.arcTo(w * .2027, h * .3006, 0, 0, 0, w * .5419, h * .2204);
    c.arcTo(w * .3378, h * .501, 0, 0, 0, w * .4649, h * .2184);
    c.arcTo(w * .2027, h * .3006, 0, 0, 0, w * .4054, h * .2445);
    c.close();
    c.moveTo(w * .473, h * .2806);
    c.arcTo(w * .2027, h * .3006, 0, 0, 1, w * .55, h * .2866);
    c.arcTo(w * .0676, h * .1002, 0, 0, 1, w * .5892, h * .3307);
    c.arcTo(w * .0338, h * .0501, 0, 0, 1, w * .5824, h * .3888);
    c.arcTo(w * .0946, h * .1403, 0, 0, 1, w * .5216, h * .4269);
    c.arcTo(w * .1622, h * .2405, 0, 0, 1, w * .4432, h * .4128);
    c.arcTo(w * .0541, h * .0802, 0, 0, 1, w * .4108, h * .3527);
    c.arcTo(w * .0541, h * .0802, 0, 0, 1, w * .4351, h * .2986);
    c.arcTo(w * .0811, h * .1202, 0, 0, 1, w * .473, h * .2806);
    c.close();
    c.fill();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.begin();
    c.moveTo(0, h * .572);
    c.lineTo(w * .0865, h * .284);
    c.lineTo(w * .4203, 0);
    c.lineTo(w * .5865, 0);
    c.lineTo(w * .919, h * .286);
    c.lineTo(w, h * .566);
    c.lineTo(w * .5027, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dWorker.prototype.cst.WORKER, mxShapeAws3dWorker);
function mxShapeAws3dApplication2(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dApplication2, mxShape);
mxShapeAws3dApplication2.prototype.cst = {
    APPLICATION2: "mxgraph.aws3d.application2",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dApplication2.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 62;
    var strokeWidth2 = strokeWidth * h / 53.5;
    var isShadow = parseFloat(mxUtils.getValue(this.state.style, "shadow", "0"));
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    c.setShadow(false);
    c.setStrokeWidth(strokeWidth);
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    if (isShadow == 1)
        c.setShadow(true);
    c.begin();
    c.moveTo(0, h * .6766);
    c.lineTo(0, h * .3271);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h * .3271);
    c.lineTo(w, h * .6766);
    c.lineTo(w * .5, h);
    c.close();
    c.fillAndStroke();
    c.restore();
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dApplication2.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(0, h * .3271);
    c.lineTo(w * .5, h * .6449);
    c.lineTo(w * .5, h);
    c.lineTo(0, h * .6766);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .5, h * .6449);
    c.lineTo(w, h * .3271);
    c.lineTo(w, h * .6766);
    c.lineTo(w * .5, h);
    c.close();
    c.fill();
    c.restore();
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .3271);
    c.lineTo(w * .5, h * .6449);
    c.lineTo(w * .5, h);
    c.lineTo(0, h * .6766);
    c.close();
    c.stroke();
    c.begin();
    c.moveTo(w * .5, h * .6449);
    c.lineTo(w, h * .3271);
    c.lineTo(w, h * .6766);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke();
    c.setLineJoin("miter");
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .1742, h * .6355);
    c.lineTo(w * .1742, h * .4393);
    c.lineTo(w * .6726, h * .1121);
    c.lineTo(w * .7661, h * .1738);
    c.lineTo(w * .2661, h * .4991);
    c.lineTo(w * .2661, h * .6916);
    c.close();
    c.moveTo(w * .2871, h * .7084);
    c.lineTo(w * .2871, h * .514);
    c.lineTo(w * .7823, h * .1869);
    c.lineTo(w * .8629, h * .2374);
    c.lineTo(w * .379, h * .5626);
    c.lineTo(w * .379, h * .7607);
    c.close();
    c.fill();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .6766);
    c.lineTo(0, h * .3271);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h * .3271);
    c.lineTo(w, h * .6766);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dApplication2.prototype.cst.APPLICATION2, mxShapeAws3dApplication2);
function mxShapeAws3dElasticBeanstalk(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dElasticBeanstalk, mxShape);
mxShapeAws3dElasticBeanstalk.prototype.cst = {
    ELASTIC_BEANSTALK: "mxgraph.aws3d.elasticBeanstalk",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dElasticBeanstalk.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 181.5;
    var strokeWidth2 = strokeWidth * h / 140;
    var isShadow = parseFloat(mxUtils.getValue(this.state.style, "shadow", "0"));
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    c.setShadow(false);
    c.setStrokeWidth(strokeWidth);
    c.save();
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    if (isShadow == 1)
        c.setShadow(true);
    c.begin();
    c.moveTo(0, h * .6239);
    c.lineTo(0, h * .3754);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h * .3754);
    c.lineTo(w, h * .6239);
    c.lineTo(w * .5, h);
    c.close();
    c.fillAndStroke();
    c.restore();
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dElasticBeanstalk.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(0, h * .3754);
    c.lineTo(w * .5, h * .7514);
    c.lineTo(w * .5, h);
    c.lineTo(0, h * .6239);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .5, h * .7514);
    c.lineTo(w, h * .3754);
    c.lineTo(w, h * .6239);
    c.lineTo(w * .5, h);
    c.close();
    c.fill();
    c.restore();
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .3754);
    c.lineTo(w * .5, h * .7514);
    c.lineTo(w * .5, h);
    c.lineTo(0, h * .6239);
    c.close();
    c.moveTo(w * .5, h * .7514);
    c.lineTo(w, h * .3754);
    c.lineTo(w, h * .6239);
    c.lineTo(w * .5, h);
    c.close();
    c.moveTo(w * .2485, h * .187);
    c.lineTo(w * .7493, h * .5623);
    c.lineTo(w * .7493, h * .8123);
    c.stroke();
    c.setLineJoin("miter");
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .7763, h * .2063);
    c.lineTo(w * .2749, h * .5817);
    c.lineTo(w * .2749, h * .8309);
    c.lineTo(w * .2204, h * .7894);
    c.lineTo(w * .2204, h * .5394);
    c.lineTo(w * .7185, h * .1619);
    c.close();
    c.fill();
    c.restore();
    c.begin();
    c.moveTo(w * .1713, h * .543);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .2028, h * .5723);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .2281, h * .6096);
    c.arcTo(w * .1102, h * .1433, 0, 0, 1, w * .2402, h * .644);
    c.arcTo(w * .1102, h * .1433, 0, 0, 1, w * .2424, h * .6848);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .216, h * .6612);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .1895, h * .6239);
    c.arcTo(w * .1102, h * .1433, 0, 0, 1, w * .1719, h * .5824);
    c.arcTo(w * .0826, h * .1074, 0, 0, 1, w * .1713, h * .543);
    c.close();
    c.moveTo(w * .2507, h * .7794);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .254, h * .7421);
    c.arcTo(w * .022, h * .0287, 0, 0, 1, w * .27, h * .7264);
    c.arcTo(w * .0551, h * .0716, 0, 0, 1, w * .2986, h * .73);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .3234, h * .7457);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .3218, h * .7815);
    c.arcTo(w * .022, h * .0287, 0, 0, 1, w * .3019, h * .7987);
    c.arcTo(w * .0826, h * .1074, 0, 0, 1, w * .27, h * .7923);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .2507, h * .7794);
    c.close();
    c.moveTo(w * .2799, h * .5265);
    c.arcTo(w * .1102, h * .1433, 0, 0, 1, w * .3003, h * .515);
    c.arcTo(w * .0826, h * .1074, 0, 0, 1, w * .3317, h * .515);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .3774, h * .5315);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .4033, h * .5487);
    c.arcTo(w * .0826, h * .1074, 0, 0, 1, w * .3906, h * .5595);
    c.arcTo(w * .0826, h * .1074, 0, 0, 1, w * .3493, h * .5616);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .3069, h * .5444);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .2799, h * .5265);
    c.close();
    c.moveTo(w * .2887, h * .3933);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .314, h * .414);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .3322, h * .4391);
    c.arcTo(w * .0193, h * .0251, 0, 0, 1, w * .3344, h * .4699);
    c.arcTo(w * .0551, h * .0716, 0, 0, 1, w * .3196, h * .485);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .2887, h * .4592);
    c.arcTo(w * .1102, h * .1433, 0, 0, 1, w * .27, h * .4269);
    c.arcTo(w * .0165, h * .0215, 0, 0, 1, w * .2727, h * .4054);
    c.arcTo(w * .0551, h * .0716, 0, 0, 1, w * .2887, h * .3933);
    c.close();
    c.moveTo(w * .4613, h * .262);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .4867, h * .2827);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .5049, h * .3078);
    c.arcTo(w * .0193, h * .0251, 0, 0, 1, w * .5071, h * .3386);
    c.arcTo(w * .0551, h * .0716, 0, 0, 1, w * .4922, h * .3537);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .4613, h * .3279);
    c.arcTo(w * .1102, h * .1433, 0, 0, 1, w * .4426, h * .2956);
    c.arcTo(w * .0165, h * .0215, 0, 0, 1, w * .4453, h * .2741);
    c.arcTo(w * .0551, h * .0716, 0, 0, 1, w * .4613, h * .262);
    c.close();
    c.moveTo(w * .4525, h * .3952);
    c.arcTo(w * .1102, h * .1433, 0, 0, 1, w * .4729, h * .3837);
    c.arcTo(w * .0826, h * .1074, 0, 0, 1, w * .5043, h * .3837);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .55, h * .4002);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .5759, h * .4174);
    c.arcTo(w * .0826, h * .1074, 0, 0, 1, w * .5633, h * .4282);
    c.arcTo(w * .0826, h * .1074, 0, 0, 1, w * .5219, h * .4303);
    c.arcTo(w * .1653, h * .1074, 0, 0, 1, w * .4795, h * .4131);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .4525, h * .3952);
    c.close();
    c.moveTo(w * .6217, h * .1426);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .6471, h * .1633);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .6652, h * .1884);
    c.arcTo(w * .0193, h * .0251, 0, 0, 1, w * .6674, h * .2192);
    c.arcTo(w * .0551, h * .0716, 0, 0, 1, w * .6526, h * .2342);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .6217, h * .2085);
    c.arcTo(w * .1102, h * .1433, 0, 0, 1, w * .603, h * .1762);
    c.arcTo(w * .0165, h * .0215, 0, 0, 1, w * .6057, h * .1547);
    c.arcTo(w * .0551, h * .0716, 0, 0, 1, w * .6217, h * .1426);
    c.close();
    c.moveTo(w * .6129, h * .2758);
    c.arcTo(w * .1102, h * .1433, 0, 0, 1, w * .6333, h * .2643);
    c.arcTo(w * .0826, h * .1433, 0, 0, 1, w * .6647, h * .2643);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .7104, h * .2808);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .7363, h * .298);
    c.arcTo(w * .0826, h * .2149, 0, 0, 1, w * .7363, h * .298);
    c.arcTo(w * .0826, h * .1074, 0, 0, 1, w * .6823, h * .3109);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .6399, h * .2937);
    c.arcTo(w * .1653, h * .2149, 0, 0, 1, w * .6129, h * .2758);
    c.close();
    c.fillAndStroke();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .6239);
    c.lineTo(0, h * .3754);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h * .3754);
    c.lineTo(w, h * .6239);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dElasticBeanstalk.prototype.cst.ELASTIC_BEANSTALK, mxShapeAws3dElasticBeanstalk);
function mxShapeAws3dSimpleDB2(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dSimpleDB2, mxShape);
mxShapeAws3dSimpleDB2.prototype.cst = {
    SIMPLE_DB_2: "mxgraph.aws3d.simpleDb2",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dSimpleDB2.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 181.5;
    var strokeWidth2 = strokeWidth * h / 210;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    this.background(c, 0, 0, w, h, strokeWidth);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h, strokeWidth)
}
;
mxShapeAws3dSimpleDB2.prototype.background = function(c, x, y, w, h, strokeWidth) {
    c.setStrokeWidth(strokeWidth);
    c.save();
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .8183);
    c.lineTo(0, h * .1848);
    c.lineTo(w * .3366, 0);
    c.lineTo(w * .6293, h * .0021);
    c.lineTo(w, h * .1833);
    c.lineTo(w, h * .8183);
    c.lineTo(w * .6694, h);
    c.lineTo(w * .4986, h * .9091);
    c.lineTo(w * .3333, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeAws3dSimpleDB2.prototype.foreground = function(c, x, y, w, h, strokeWidth) {
    c.restore();
    c.setShadow(false);
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dSimpleDB2.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(0, h * .1848);
    c.lineTo(w * .168, h * .1833);
    c.lineTo(0, h * .365);
    c.lineTo(w * .3333, h * .5467);
    c.lineTo(w * .3333, h);
    c.lineTo(0, h * .8183);
    c.close();
    c.moveTo(w * .4986, h * .9078);
    c.lineTo(w * .4986, h * .3655);
    c.lineTo(w * .6667, h * .5457);
    c.lineTo(w * .6667, h);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .3333, h * .5467);
    c.lineTo(w * .4986, h * .3655);
    c.lineTo(w * .4986, h * .9076);
    c.lineTo(w * .3333, h);
    c.close();
    c.moveTo(w * .8292, h * .1822);
    c.lineTo(w, h * .1848);
    c.lineTo(w, h * .8183);
    c.lineTo(w * .6667, h);
    c.lineTo(w * .6667, h * .5441);
    c.lineTo(w, h * .3666);
    c.close();
    c.fill();
    c.restore();
    c.setShadow(false);
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .1848);
    c.lineTo(w * .168, h * .1833);
    c.lineTo(0, h * .365);
    c.lineTo(w * .3333, h * .5467);
    c.lineTo(w * .3333, h);
    c.lineTo(0, h * .8183);
    c.close();
    c.moveTo(w * .4986, h * .9078);
    c.lineTo(w * .4986, h * .3655);
    c.lineTo(w * .6667, h * .5457);
    c.lineTo(w * .6667, h);
    c.close();
    c.moveTo(w * .3333, h * .5467);
    c.lineTo(w * .4986, h * .3655);
    c.lineTo(w * .4986, h * .9076);
    c.lineTo(w * .3333, h);
    c.close();
    c.moveTo(w * .8292, h * .1822);
    c.lineTo(w, h * .1848);
    c.lineTo(w, h * .8183);
    c.lineTo(w * .6667, h);
    c.lineTo(w * .6667, h * .5441);
    c.lineTo(w, h * .3666);
    c.close();
    c.moveTo(w * .1669, h * .1828);
    c.lineTo(w * .4986, h * .3655);
    c.lineTo(w * .8314, h * .1833);
    c.lineTo(w * .4986, h * .0031);
    c.close();
    c.stroke();
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .2634, h * .1833);
    c.lineTo(w * .5003, h * .0535);
    c.lineTo(w * .7394, h * .1833);
    c.lineTo(w * .5003, h * .3136);
    c.close();
    c.fill();
    var fillColor = mxUtils.getValue(this.state.style, "fillColor", "#000000");
    c.restore();
    c.setShadow(false);
    c.setStrokeWidth(3 * strokeWidth);
    c.setStrokeColor(fillColor);
    c.begin();
    c.moveTo(w * .3003, h * .2108);
    c.lineTo(w * .5642, h * .068);
    c.moveTo(w * .4429, h * .0693);
    c.lineTo(w * .7059, h * .2121);
    c.moveTo(w * .6667, h * .2458);
    c.lineTo(w * .3974, h * .0992);
    c.moveTo(w * .3499, h * .1277);
    c.lineTo(w * .6088, h * .2698);
    c.moveTo(w * .3009, h * .1556);
    c.lineTo(w * .5496, h * .2913);
    c.stroke();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .8183);
    c.lineTo(0, h * .1848);
    c.lineTo(w * .3366, 0);
    c.lineTo(w * .6293, h * .0021);
    c.lineTo(w, h * .1833);
    c.lineTo(w, h * .8183);
    c.lineTo(w * .6694, h);
    c.lineTo(w * .4986, h * .9091);
    c.lineTo(w * .3333, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dSimpleDB2.prototype.cst.SIMPLE_DB_2, mxShapeAws3dSimpleDB2);
function mxShapeAws3dWorkflowService(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dWorkflowService, mxShape);
mxShapeAws3dWorkflowService.prototype.cst = {
    WORKFLOW_SERVICE: "mxgraph.aws3d.workflowService",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dWorkflowService.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 181.5;
    var strokeWidth2 = strokeWidth * h / 210;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    this.background(c, 0, 0, w, h, strokeWidth);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h, strokeWidth)
}
;
mxShapeAws3dWorkflowService.prototype.background = function(c, x, y, w, h, strokeWidth) {
    c.setStrokeWidth(strokeWidth);
    c.save();
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .6456);
    c.lineTo(w * .2481, 0);
    c.lineTo(w * .7497, 0);
    c.lineTo(w, h * .6456);
    c.lineTo(w * .4984, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeAws3dWorkflowService.prototype.foreground = function(c, x, y, w, h, strokeWidth) {
    c.restore();
    c.setShadow(false);
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dWorkflowService.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(0, h * .6456);
    c.lineTo(w * .2486, 0);
    c.lineTo(w * .2486, h * .3531);
    c.lineTo(w * .4984, h);
    c.close();
    c.moveTo(w * .7497, h * .3531);
    c.lineTo(w * .7497, 0);
    c.lineTo(w, h * .6456);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .4984, h);
    c.lineTo(w * .7486, h * .3531);
    c.lineTo(w, h * .6456);
    c.lineTo(w * .4967, h);
    c.close();
    c.fill();
    c.restore();
    c.setShadow(false);
    c.setLineJoin("round");
    c.begin();
    c.moveTo(w * .7497, h * .3531);
    c.lineTo(w * .7497, 0);
    c.lineTo(w, h * .6456);
    c.close();
    c.moveTo(0, h * .6456);
    c.lineTo(w * .2486, 0);
    c.lineTo(w * .2486, h * .3531);
    c.lineTo(w * .4984, h);
    c.lineTo(w * .7486, h * .3531);
    c.lineTo(w, h * .6456);
    c.lineTo(w * .4967, h);
    c.close();
    c.moveTo(w * .2486, h * .3531);
    c.lineTo(w * .7508, h * .3531);
    c.moveTo(w * .2488, h * .353);
    c.lineTo(0, h * .6486);
    c.stroke();
    c.restore();
    c.setShadow(false);
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setFillColor(strokeColor);
    c.setStrokeWidth(2 * strokeWidth);
    c.begin();
    c.ellipse(w * .2925, h * .031, w * .4116, h * .2925);
    c.fill();
    var fillColor = mxUtils.getValue(this.state.style, "fillColor", "#ffffff");
    c.setStrokeColor(fillColor);
    c.begin();
    c.moveTo(w * .5252, h * .0465);
    c.lineTo(w * .5873, h * .0903);
    c.lineTo(w * .5483, h * .1173);
    c.lineTo(w * .4874, h * .0728);
    c.close();
    c.moveTo(w * .4896, h * .1132);
    c.lineTo(w * .5005, h * .1705);
    c.lineTo(w * .4182, h * .1631);
    c.lineTo(w * .4122, h * .1058);
    c.close();
    c.moveTo(w * .3584, h * .1631);
    c.lineTo(w * .4204, h * .2062);
    c.lineTo(w * .3825, h * .2332);
    c.lineTo(w * .32, h * .19);
    c.close();
    c.moveTo(w * .4594, h * .2338);
    c.lineTo(w * .5214, h * .2783);
    c.lineTo(w * .4835, h * .3053);
    c.lineTo(w * .4215, h * .2608);
    c.close();
    c.moveTo(w * .5187, h * .0943);
    c.lineTo(w * .4879, h * .1152);
    c.moveTo(w * .421, h * .1624);
    c.lineTo(w * .3895, h * .1846);
    c.moveTo(w * .5, h * .1698);
    c.lineTo(w * .5554, h * .2089);
    c.lineTo(w * .4885, h * .2567);
    c.stroke();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .6456);
    c.lineTo(w * .2481, 0);
    c.lineTo(w * .7497, 0);
    c.lineTo(w, h * .6456);
    c.lineTo(w * .4984, h);
    c.close();
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dWorkflowService.prototype.cst.WORKFLOW_SERVICE, mxShapeAws3dWorkflowService);
function mxShapeAws3dDecider(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dDecider, mxShape);
mxShapeAws3dDecider.prototype.cst = {
    DECIDER: "mxgraph.aws3d.decider",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dDecider.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var isShadow = parseFloat(mxUtils.getValue(this.state.style, "shadow", "0"));
    var strokeWidth1 = strokeWidth * w / 74;
    var strokeWidth2 = strokeWidth * h / 50;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    c.setStrokeWidth(strokeWidth);
    c.setShadow(false);
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    if (isShadow == 1)
        c.setShadow(true);
    c.begin();
    c.moveTo(0, h * .572);
    c.lineTo(w * .0865, h * .284);
    c.lineTo(w * .4203, 0);
    c.lineTo(w * .5865, 0);
    c.lineTo(w * .919, h * .286);
    c.lineTo(w, h * .566);
    c.lineTo(w * .5027, h);
    c.close();
    c.fillAndStroke();
    c.restore();
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dDecider.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(0, h * .566);
    c.lineTo(w * .0892, h * .282);
    c.lineTo(w * .0878, h * .426);
    c.lineTo(w * .4216, h * .712);
    c.lineTo(w * .5865, h * .712);
    c.lineTo(w * .5027, h);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .5027, h);
    c.lineTo(w * .5865, h * .712);
    c.lineTo(w * .9176, h * .43);
    c.lineTo(w, h * .566);
    c.close();
    c.fill();
    c.restore();
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .566);
    c.lineTo(w * .0892, h * .282);
    c.lineTo(w * .0878, h * .426);
    c.lineTo(w * .4216, h * .712);
    c.lineTo(w * .5865, h * .712);
    c.lineTo(w * .5027, h);
    c.close();
    c.moveTo(w * .5027, h);
    c.lineTo(w * .5865, h * .712);
    c.lineTo(w * .9176, h * .43);
    c.lineTo(w, h * .566);
    c.close();
    c.moveTo(0, h * .572);
    c.lineTo(w * .0892, h * .422);
    c.moveTo(w * .5027, h);
    c.lineTo(w * .4189, h * .708);
    c.moveTo(w * .9176, h * .43);
    c.lineTo(w * .9176, h * .29);
    c.stroke();
    c.setStrokeWidth(1.6 * strokeWidth);
    c.setLineJoin("square");
    c.begin();
    c.moveTo(w * .4973, h * .1523);
    c.lineTo(w * .5608, h * .0982);
    c.lineTo(w * .6581, h * .1844);
    c.lineTo(w * .5986, h * .2365);
    c.close();
    c.moveTo(w * .3784, h * .2164);
    c.lineTo(w * .5054, h * .2305);
    c.lineTo(w * .5203, h * .3407);
    c.lineTo(w * .3892, h * .3246);
    c.close();
    c.moveTo(w * .2932, h * .3246);
    c.lineTo(w * .3919, h * .4128);
    c.lineTo(w * .3334, h * .4647);
    c.lineTo(w * .2357, h * .38);
    c.close();
    c.moveTo(w * .4568, h * .4649);
    c.lineTo(w * .5554, h * .5511);
    c.lineTo(w * .4932, h * .6032);
    c.lineTo(w * .3946, h * .517);
    c.close();
    c.moveTo(w * .5473, h * .1924);
    c.lineTo(w * .5027, h * .2365);
    c.moveTo(w * .4, h * .3186);
    c.lineTo(w * .3446, h * .3667);
    c.moveTo(w * .5189, h * .3387);
    c.lineTo(w * .6081, h * .4148);
    c.lineTo(w * .5068, h * .501);
    c.stroke();
    c.setStrokeColor("#292929");
    c.begin();
    c.moveTo(0, h * .572);
    c.lineTo(w * .0865, h * .284);
    c.lineTo(w * .4203, 0);
    c.lineTo(w * .5865, 0);
    c.lineTo(w * .919, h * .286);
    c.lineTo(w, h * .566);
    c.lineTo(w * .5027, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dDecider.prototype.cst.DECIDER, mxShapeAws3dDecider);
function mxShapeAws3dSearchEngine(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dSearchEngine, mxShape);
mxShapeAws3dSearchEngine.prototype.cst = {
    SEARCH_ENGINE: "mxgraph.aws3d.searchEngine",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dSearchEngine.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 180;
    var strokeWidth2 = strokeWidth * h / 192;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    this.background(c, 0, 0, w, h, strokeWidth);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h, strokeWidth)
}
;
mxShapeAws3dSearchEngine.prototype.background = function(c, x, y, w, h, strokeWidth) {
    c.setStrokeWidth(strokeWidth);
    c.save();
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .7281);
    c.lineTo(w * .1667, h * .5444);
    c.lineTo(w * .1667, h * .1832);
    c.lineTo(w * .5011, 0);
    c.lineTo(w * .8333, h * .1832);
    c.lineTo(w * .8333, h * .5446);
    c.lineTo(w, h * .7281);
    c.lineTo(w * .7486, h * .7735);
    c.lineTo(w * .5819, h * .8617);
    c.lineTo(w * .5011, h);
    c.lineTo(w * .4169, h * .8653);
    c.lineTo(w * .2475, h * .7704);
    c.close();
    c.fillAndStroke()
}
;
mxShapeAws3dSearchEngine.prototype.foreground = function(c, x, y, w, h, strokeWidth) {
    c.restore();
    c.setShadow(false);
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dSearchEngine.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(w * .1672, h * .1837);
    c.lineTo(w * .4989, h * .3638);
    c.lineTo(w * .4989, h * .7291);
    c.lineTo(w * .5825, h * .8633);
    c.lineTo(w * .4989, h);
    c.lineTo(w * .4164, h * .8622);
    c.lineTo(w * .2458, h * .7719);
    c.lineTo(0, h * .7276);
    c.lineTo(w * .1661, h * .5454);
    c.close();
    c.moveTo(w * .7486, h * .7714);
    c.lineTo(w * .8317, h * .5459);
    c.lineTo(w, h * .727);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .4989, h * .3643);
    c.lineTo(w * .8317, h * .1827);
    c.lineTo(w * .8317, h * .5465);
    c.lineTo(w * .7508, h * .7714);
    c.lineTo(w * .5836, h * .8633);
    c.lineTo(w * .4989, h * .727);
    c.close();
    c.fill();
    c.restore();
    c.setShadow(false);
    c.setLineJoin("round");
    c.begin();
    c.moveTo(w * .1672, h * .1837);
    c.lineTo(w * .4989, h * .3638);
    c.lineTo(w * .4989, h * .7291);
    c.lineTo(w * .5825, h * .8633);
    c.lineTo(w * .4989, h);
    c.lineTo(w * .4164, h * .8622);
    c.lineTo(w * .2458, h * .7719);
    c.lineTo(0, h * .7276);
    c.lineTo(w * .1661, h * .5454);
    c.close();
    c.moveTo(w * .7486, h * .7714);
    c.lineTo(w * .8317, h * .5459);
    c.lineTo(w, h * .727);
    c.close();
    c.moveTo(w * .4989, h * .3643);
    c.lineTo(w * .8317, h * .1827);
    c.lineTo(w * .8317, h * .5465);
    c.lineTo(w * .7508, h * .7714);
    c.lineTo(w * .5836, h * .8633);
    c.lineTo(w * .4989, h * .727);
    c.close();
    c.moveTo(w * .1667, h * .5459);
    c.lineTo(w * .2486, h * .7704);
    c.moveTo(w * .4164, h * .8633);
    c.lineTo(w * .4989, h * .727);
    c.lineTo(w * .4989, h);
    c.stroke();
    c.restore();
    c.setShadow(false);
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .3427, h * .179);
    c.arcTo(w * .0277, h * .0261, 0, 0, 1, w * .3267, h * .1487);
    c.arcTo(w * .0664, h * .0365, 0, 0, 1, w * .3621, h * .1227);
    c.arcTo(w * .1052, h * .0992, 0, 0, 1, w * .4247, h * .1195);
    c.arcTo(w * .1274, h * .12, 0, 0, 1, w * .4884, h * .1018);
    c.arcTo(w * .1329, h * .1253, 0, 0, 1, w * .5548, h * .1112);
    c.arcTo(w * .0377, h * .0344, 0, 0, 1, w * .572, h * .166);
    c.arcTo(w * .0388, h * .0365, 0, 0, 1, w * .6047, h * .1775);
    c.arcTo(w * .021, h * .0198, 0, 0, 1, w * .5936, h * .2046);
    c.arcTo(w * .0332, h * .0313, 0, 0, 1, w * .6008, h * .2416);
    c.arcTo(w * .072, h * .0678, 0, 0, 1, w * .5437, h * .2677);
    c.arcTo(w * .1052, h * .0939, 0, 0, 1, w * .4828, h * .2563);
    c.close();
    c.moveTo(w * .448, h * .2156);
    c.arcTo(w * .0111, h * .0104, 0, 0, 0, w * .459, h * .2255);
    c.arcTo(w * .0138, h * .013, 0, 0, 0, w * .4729, h * .2182);
    c.lineTo(w * .4773, h * .1874);
    c.arcTo(w * .0664, h * .0626, 0, 0, 0, w * .5116, h * .1759);
    c.arcTo(w * .0277, h * .0626, 0, 0, 0, w * .5233, h * .1503);
    c.arcTo(w * .0554, h * .0261, 0, 0, 0, w * .5022, h * .1336);
    c.arcTo(w * .0886, h * .0835, 0, 0, 0, w * .4607, h * .1305);
    c.arcTo(w * .0664, h * .0626, 0, 0, 0, w * .4313, h * .142);
    c.arcTo(w * .0332, h * .0313, 0, 0, 0, w * .4175, h * .1597);
    c.arcTo(w * .0249, h * .0235, 0, 0, 0, w * .4313, h * .1822);
    c.arcTo(w * .0443, h * .0418, 0, 0, 0, w * .4535, h * .1884);
    c.close();
    c.moveTo(w * .4718, h * .1764);
    c.arcTo(w * .0443, h * .0418, 0, 0, 1, w * .4496, h * .1754);
    c.arcTo(w * .0221, h * .0157, 0, 0, 1, w * .4369, h * .1634);
    c.arcTo(w * .0221, h * .0183, 0, 0, 1, w * .4496, h * .1467);
    c.arcTo(w * .0609, h * .0574, 0, 0, 1, w * .4759, h * .1414);
    c.arcTo(w * .0388, h * .0365, 0, 0, 1, w * .5033, h * .1514);
    c.arcTo(w * .0443, h * .0209, 0, 0, 1, w * .495, h * .1701);
    c.arcTo(w * .0388, h * .0365, 0, 0, 1, w * .4718, h * .1764);
    c.close();
    c.fill();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .7281);
    c.lineTo(w * .1667, h * .5444);
    c.lineTo(w * .1667, h * .1832);
    c.lineTo(w * .5011, 0);
    c.lineTo(w * .8333, h * .1832);
    c.lineTo(w * .8333, h * .5446);
    c.lineTo(w, h * .7281);
    c.lineTo(w * .7486, h * .7735);
    c.lineTo(w * .5819, h * .8617);
    c.lineTo(w * .5011, h);
    c.lineTo(w * .4169, h * .8653);
    c.lineTo(w * .2475, h * .7704);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dSearchEngine.prototype.cst.SEARCH_ENGINE, mxShapeAws3dSearchEngine);
function mxShapeAws3dSecurityTokenService(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dSecurityTokenService, mxShape);
mxShapeAws3dSecurityTokenService.prototype.cst = {
    SECURITY_TOKEN_SERVICE: "mxgraph.aws3d.securityTokenService",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dSecurityTokenService.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 180;
    var strokeWidth2 = strokeWidth * h / 192;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    this.background(c, 0, 0, w, h, strokeWidth);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h, strokeWidth)
}
;
mxShapeAws3dSecurityTokenService.prototype.background = function(c, x, y, w, h, strokeWidth) {
    c.setStrokeWidth(strokeWidth);
    c.save();
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .7281);
    c.lineTo(w * .1667, h * .5444);
    c.lineTo(w * .1667, h * .1832);
    c.lineTo(w * .5011, 0);
    c.lineTo(w * .8333, h * .1832);
    c.lineTo(w * .8333, h * .5446);
    c.lineTo(w, h * .7281);
    c.lineTo(w * .7486, h * .7735);
    c.lineTo(w * .5819, h * .8617);
    c.lineTo(w * .5011, h);
    c.lineTo(w * .4169, h * .8653);
    c.lineTo(w * .2475, h * .7704);
    c.close();
    c.fillAndStroke()
}
;
mxShapeAws3dSecurityTokenService.prototype.foreground = function(c, x, y, w, h, strokeWidth) {
    c.restore();
    c.setShadow(false);
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dSecurityTokenService.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(w * .1672, h * .1837);
    c.lineTo(w * .4989, h * .3638);
    c.lineTo(w * .4989, h * .7291);
    c.lineTo(w * .5825, h * .8633);
    c.lineTo(w * .4989, h);
    c.lineTo(w * .4164, h * .8622);
    c.lineTo(w * .2458, h * .7719);
    c.lineTo(0, h * .7276);
    c.lineTo(w * .1661, h * .5454);
    c.close();
    c.moveTo(w * .7486, h * .7714);
    c.lineTo(w * .8317, h * .5459);
    c.lineTo(w, h * .727);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .4989, h * .3643);
    c.lineTo(w * .8317, h * .1827);
    c.lineTo(w * .8317, h * .5465);
    c.lineTo(w * .7508, h * .7714);
    c.lineTo(w * .5836, h * .8633);
    c.lineTo(w * .4989, h * .727);
    c.close();
    c.fill();
    c.restore();
    c.setShadow(false);
    c.setLineJoin("round");
    c.begin();
    c.moveTo(w * .1672, h * .1837);
    c.lineTo(w * .4989, h * .3638);
    c.lineTo(w * .4989, h * .7291);
    c.lineTo(w * .5825, h * .8633);
    c.lineTo(w * .4989, h);
    c.lineTo(w * .4164, h * .8622);
    c.lineTo(w * .2458, h * .7719);
    c.lineTo(0, h * .7276);
    c.lineTo(w * .1661, h * .5454);
    c.close();
    c.moveTo(w * .7486, h * .7714);
    c.lineTo(w * .8317, h * .5459);
    c.lineTo(w, h * .727);
    c.close();
    c.moveTo(w * .4989, h * .3643);
    c.lineTo(w * .8317, h * .1827);
    c.lineTo(w * .8317, h * .5465);
    c.lineTo(w * .7508, h * .7714);
    c.lineTo(w * .5836, h * .8633);
    c.lineTo(w * .4989, h * .727);
    c.close();
    c.moveTo(w * .1667, h * .5459);
    c.lineTo(w * .2486, h * .7704);
    c.moveTo(w * .4164, h * .8633);
    c.lineTo(w * .4989, h * .727);
    c.lineTo(w * .4989, h);
    c.stroke();
    c.restore();
    c.setShadow(false);
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .4773, h * .1915);
    c.arcTo(w * .1274, h * .12, 0, 0, 1, w * .4358, h * .1968);
    c.arcTo(w * .1107, h * .1044, 0, 0, 1, w * .3937, h * .1905);
    c.arcTo(w * .0554, h * .0522, 0, 0, 1, w * .3682, h * .1707);
    c.arcTo(w * .0332, h * .0313, 0, 0, 1, w * .3699, h * .1414);
    c.arcTo(w * .0775, h * .0731, 0, 0, 1, w * .4009, h * .118);
    c.arcTo(w * .1107, h * .1044, 0, 0, 1, w * .4524, h * .1059);
    c.arcTo(w * .1107, h * .1044, 0, 0, 1, w * .5028, h * .1112);
    c.arcTo(w * .0664, h * .0626, 0, 0, 1, w * .531, h * .1315);
    c.arcTo(w * .0332, h * .0313, 0, 0, 1, w * .531, h * .1597);
    c.lineTo(w * .5615, h * .1754);
    c.lineTo(w * .5526, h * .1905);
    c.lineTo(w * .5759, h * .1999);
    c.lineTo(w * .5753, h * .2109);
    c.lineTo(w * .5792, h * .2161);
    c.lineTo(w * .6135, h * .2182);
    c.lineTo(w * .6113, h * .2416);
    c.lineTo(w * .5819, h * .2474);
    c.close();
    c.moveTo(w * .4756, h * .1816);
    c.arcTo(w * .0554, h * .0522, 0, 0, 0, w * .5, h * .1691);
    c.arcTo(w * .0332, h * .0313, 0, 0, 0, w * .5144, h * .1435);
    c.arcTo(w * .0277, h * .0261, 0, 0, 0, w * .4967, h * .1247);
    c.arcTo(w * .0554, h * .0522, 0, 0, 0, w * .4729, h * .1174);
    c.arcTo(w * .1107, h * .1044, 0, 0, 0, w * .4452, h * .1169);
    c.arcTo(w * .0831, h * .0783, 0, 0, 0, w * .4197, h * .1232);
    c.arcTo(w * .0554, h * .0522, 0, 0, 0, w * .397, h * .1357);
    c.arcTo(w * .0388, h * .0365, 0, 0, 0, w * .3859, h * .1555);
    c.arcTo(w * .0305, h * .0287, 0, 0, 0, w * .4053, h * .178);
    c.arcTo(w * .072, h * .0678, 0, 0, 0, w * .4385, h * .1863);
    c.arcTo(w * .0831, h * .0783, 0, 0, 0, w * .4596, h * .1848);
    c.arcTo(w * .0664, h * .0626, 0, 0, 0, w * .4756, h * .1816);
    c.fill();
    c.setStrokeWidth(1.5 * strokeWidth);
    c.setLineJoin("round");
    c.setLineCap("round");
    c.begin();
    c.moveTo(w * .4939, h * .1326);
    c.lineTo(w * .4474, h * .1508);
    c.lineTo(w * .4812, h * .1576);
    c.moveTo(w * .4889, h * .1733);
    c.lineTo(w * .4939, h * .1775);
    c.moveTo(w * .5061, h * .1576);
    c.lineTo(w * .5199, h * .1597);
    c.moveTo(w * .5094, h * .1394);
    c.lineTo(w * .5244, h * .1378);
    c.moveTo(w * .4945, h * .1247);
    c.lineTo(w * .4994, h * .1185);
    c.moveTo(w * .4679, h * .1175);
    c.lineTo(w * .4707, h * .1117);
    c.moveTo(w * .4396, h * .1195);
    c.lineTo(w * .4374, h * .1138);
    c.moveTo(w * .412, h * .1284);
    c.lineTo(w * .4059, h * .1232);
    c.moveTo(w * .3948, h * .1441);
    c.lineTo(w * .3804, h * .1425);
    c.moveTo(w * .3931, h * .1608);
    c.lineTo(w * .3804, h * .1649);
    c.moveTo(w * .4059, h * .1754);
    c.lineTo(w * .3998, h * .1801);
    c.moveTo(w * .4308, h * .1822);
    c.lineTo(w * .4286, h * .1884);
    c.moveTo(w * .4618, h * .1827);
    c.lineTo(w * .4635, h * .1868);
    c.stroke();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.begin();
    c.moveTo(0, h * .7281);
    c.lineTo(w * .1667, h * .5444);
    c.lineTo(w * .1667, h * .1832);
    c.lineTo(w * .5011, 0);
    c.lineTo(w * .8333, h * .1832);
    c.lineTo(w * .8333, h * .5446);
    c.lineTo(w, h * .7281);
    c.lineTo(w * .7486, h * .7735);
    c.lineTo(w * .5819, h * .8617);
    c.lineTo(w * .5011, h);
    c.lineTo(w * .4169, h * .8653);
    c.lineTo(w * .2475, h * .7704);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dSecurityTokenService.prototype.cst.SECURITY_TOKEN_SERVICE, mxShapeAws3dSecurityTokenService);
function mxShapeAws3dGlacier(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dGlacier, mxShape);
mxShapeAws3dGlacier.prototype.cst = {
    GLACIER: "mxgraph.aws3d.glacier",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dGlacier.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 180;
    var strokeWidth2 = strokeWidth * h / 192;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    this.background(c, 0, 0, w, h, strokeWidth);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h, strokeWidth)
}
;
mxShapeAws3dGlacier.prototype.background = function(c, x, y, w, h, strokeWidth) {
    c.setStrokeWidth(strokeWidth);
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .8177);
    c.lineTo(0, h * .5448);
    c.lineTo(w * .168, h * .1792);
    c.lineTo(w * .5008, 0);
    c.lineTo(w * .8309, h * .1812);
    c.lineTo(w, h * .5469);
    c.lineTo(w, h * .8188);
    c.lineTo(w * .6661, h);
    c.lineTo(w * .3333, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeAws3dGlacier.prototype.foreground = function(c, x, y, w, h, strokeWidth) {
    c.restore();
    c.setShadow(false);
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dGlacier.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(w * .1658, h * .1802);
    c.lineTo(w * .5008, h * .3651);
    c.lineTo(w * .6661, h * .9089);
    c.lineTo(w * .6661, h);
    c.lineTo(w * .3339, h);
    c.lineTo(0, h * .8177);
    c.lineTo(0, h * .5427);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .5008, h * .362);
    c.lineTo(w * .8314, h * .1823);
    c.lineTo(w, h * .5469);
    c.lineTo(w, h * .8177);
    c.lineTo(w * .6661, h);
    c.lineTo(w * .6661, h * .9089);
    c.close();
    c.fill();
    c.restore();
    c.setShadow(false);
    c.setLineJoin("round");
    c.begin();
    c.moveTo(w * .1658, h * .1802);
    c.lineTo(w * .5008, h * .3651);
    c.lineTo(w * .6661, h * .9089);
    c.lineTo(w * .6661, h);
    c.lineTo(w * .3339, h);
    c.lineTo(0, h * .8177);
    c.lineTo(0, h * .5427);
    c.close();
    c.moveTo(w * .5008, h * .362);
    c.lineTo(w * .8314, h * .1823);
    c.lineTo(w, h * .5469);
    c.lineTo(w, h * .8177);
    c.lineTo(w * .6661, h);
    c.lineTo(w * .6661, h * .9089);
    c.close();
    c.moveTo(w * .1675, h * .1797);
    c.lineTo(0, h * .7281);
    c.lineTo(w * .3284, h * .9089);
    c.lineTo(w * .6661, h * .9089);
    c.lineTo(w, h * .7266);
    c.lineTo(w * .8309, h * .1823);
    c.moveTo(w * .5003, h * .362);
    c.lineTo(w * .3311, h * .9089);
    c.lineTo(w * .3311, h);
    c.stroke();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.begin();
    c.moveTo(0, h * .8177);
    c.lineTo(0, h * .5448);
    c.lineTo(w * .168, h * .1792);
    c.lineTo(w * .5008, 0);
    c.lineTo(w * .8309, h * .1812);
    c.lineTo(w, h * .5469);
    c.lineTo(w, h * .8188);
    c.lineTo(w * .6661, h);
    c.lineTo(w * .3333, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dGlacier.prototype.cst.GLACIER, mxShapeAws3dGlacier);
function mxShapeAws3dCustomerGateway(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dCustomerGateway, mxShape);
mxShapeAws3dCustomerGateway.prototype.cst = {
    CUSTOMER_GATEWAY: "mxgraph.aws3d.customerGateway",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dCustomerGateway.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 116.7;
    var strokeWidth2 = strokeWidth * h / 102.8;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    this.background(c, 0, 0, w, h, strokeWidth);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h, strokeWidth)
}
;
mxShapeAws3dCustomerGateway.prototype.background = function(c, x, y, w, h, strokeWidth) {
    c.setStrokeWidth(strokeWidth);
    c.save();
    c.save();
    c.save();
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(w * .4199, h * .5447);
    c.lineTo(w * .4199, h * .035);
    c.lineTo(w * .8946, 0);
    c.lineTo(w, h * .0691);
    c.lineTo(w, h * .4134);
    c.lineTo(w * .6812, h * .7247);
    c.close();
    c.fillAndStroke();
    c.restore();
    c.save();
    c.setShadow(false);
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dCustomerGateway.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(w * .4199, h * .5447);
    c.lineTo(w * .4199, h * .035);
    c.lineTo(w * .6838, h * .2072);
    c.lineTo(w * .6838, h * .7247);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .6838, h * .2072);
    c.lineTo(w, h * .0691);
    c.lineTo(w, h * .4134);
    c.lineTo(w * .6838, h * .7247);
    c.close();
    c.fill();
    c.restore();
    c.setShadow(false);
    c.begin();
    c.moveTo(w * .4199, h * .5447);
    c.lineTo(w * .4199, h * .035);
    c.lineTo(w * .6838, h * .2072);
    c.lineTo(w * .6838, h * .7247);
    c.close();
    c.stroke();
    c.restore();
    c.setLineJoin("round");
    c.setShadow(false);
    c.begin();
    c.moveTo(w * .6838, h * .2072);
    c.lineTo(w, h * .0691);
    c.lineTo(w, h * .4134);
    c.lineTo(w * .6838, h * .7247);
    c.close();
    c.stroke();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.begin();
    c.moveTo(w * .4199, h * .5447);
    c.lineTo(w * .4199, h * .035);
    c.lineTo(w * .8946, 0);
    c.lineTo(w, h * .0691);
    c.lineTo(w, h * .4134);
    c.lineTo(w * .6812, h * .7247);
    c.close();
    c.stroke();
    c.restore();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .929);
    c.lineTo(0, h * .5866);
    c.lineTo(w * .3171, h * .1031);
    c.lineTo(w * .5784, h * .2753);
    c.lineTo(w * .5784, h * .7928);
    c.lineTo(w * .1054, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeAws3dCustomerGateway.prototype.foreground = function(c, x, y, w, h, strokeWidth) {
    c.restore();
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setShadow(false);
    c.setLineJoin("round");
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dCustomerGateway.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(0, h * .929);
    c.lineTo(0, h * .5866);
    c.lineTo(w * .1054, h * .6537);
    c.lineTo(w * .1054, h);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .1054, h);
    c.lineTo(w * .1054, h * .6537);
    c.lineTo(w * .5784, h * .2753);
    c.lineTo(w * .5784, h * .7928);
    c.close();
    c.fill();
    c.restore();
    c.setShadow(false);
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .929);
    c.lineTo(0, h * .5866);
    c.lineTo(w * .1054, h * .6537);
    c.lineTo(w * .1054, h);
    c.close();
    c.stroke();
    c.begin();
    c.moveTo(w * .1054, h);
    c.lineTo(w * .1054, h * .6537);
    c.lineTo(w * .5784, h * .2753);
    c.lineTo(w * .5784, h * .7928);
    c.close();
    c.stroke();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .929);
    c.lineTo(0, h * .5866);
    c.lineTo(w * .3171, h * .1031);
    c.lineTo(w * .5784, h * .2753);
    c.lineTo(w * .5784, h * .7928);
    c.lineTo(w * .1054, h);
    c.close();
    c.stroke();
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .7575, h * .3969);
    c.arcTo(w * .2142, h * .2432, 0, 0, 1, w * .7686, h * .3259);
    c.arcTo(w * .2142, h * .2432, 0, 0, 1, w * .8055, h * .2481);
    c.arcTo(w * .2142, h * .2432, 0, 0, 1, w * .8406, h * .2091);
    c.lineTo(w * .8269, h * .2665);
    c.lineTo(w * .8372, h * .2607);
    c.lineTo(w * .8372, h * .3444);
    c.lineTo(w * .7832, h * .3804);
    c.lineTo(w * .7832, h * .3658);
    c.close();
    c.moveTo(w * .8466, h * .2082);
    c.arcTo(w * .0514, h * .0584, 0, 0, 1, w * .8766, h * .1955);
    c.arcTo(w * .0514, h * .0584, 0, 0, 1, w * .9186, h * .2286);
    c.arcTo(w * .12, h * .1362, 0, 0, 1, w * .9297, h * .2821);
    c.lineTo(w * .9006, h * .2831);
    c.lineTo(w * .9006, h * .3016);
    c.lineTo(w * .85, h * .3366);
    c.lineTo(w * .85, h * .251);
    c.lineTo(w * .8586, h * .2471);
    c.close();
    c.moveTo(w * .9297, h * .2967);
    c.arcTo(w * .2142, h * .2432, 0, 0, 1, w * .9195, h * .3667);
    c.arcTo(w * .2571, h * .2918, 0, 0, 1, w * .8869, h * .4436);
    c.arcTo(w * .1714, h * .1946, 0, 0, 1, w * .8466, h * .4903);
    c.lineTo(w * .8595, h * .4358);
    c.lineTo(w * .8492, h * .4416);
    c.lineTo(w * .8492, h * .357);
    c.lineTo(w * .9006, h * .32004);
    c.lineTo(w * .9006, h * .3346);
    c.close();
    c.moveTo(w * .838, h * .4942);
    c.arcTo(w * .0857, h * .0973, 0, 0, 1, w * .8072, h * .5049);
    c.arcTo(w * .0514, h * .0584, 0, 0, 1, w * .7712, h * .4815);
    c.arcTo(w * .1714, h * .1946, 0, 0, 1, w * .7566, h * .4163);
    c.lineTo(w * .7832, h * .4173);
    c.lineTo(w * .7832, h * .4008);
    c.lineTo(w * .8372, h * .3638);
    c.lineTo(w * .8372, h * .4494);
    c.lineTo(w * .8278, h * .4562);
    c.close();
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeAws3dCustomerGateway.prototype.cst.CUSTOMER_GATEWAY, mxShapeAws3dCustomerGateway);
function mxShapeAws3dRedshift(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dRedshift, mxShape);
mxShapeAws3dRedshift.prototype.cst = {
    REDSHIFT: "mxgraph.aws3d.redshift",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dRedshift.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 149.5;
    var strokeWidth2 = strokeWidth * h / 187.5;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    this.background(c, 0, 0, w, h, strokeWidth);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h, strokeWidth)
}
;
mxShapeAws3dRedshift.prototype.background = function(c, x, y, w, h, strokeWidth) {
    c.setStrokeWidth(strokeWidth);
    c.save();
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .6517);
    c.lineTo(0, h * .0912);
    c.lineTo(w * .0368, h * .0155);
    c.lineTo(w * .2047, 0);
    c.lineTo(w * .3378, h * .0619);
    c.lineTo(w * .3378, h * .0912);
    c.lineTo(w * .3819, h * .0693);
    c.lineTo(w * .6154, h * .0693);
    c.lineTo(w * .8502, h * .1776);
    c.lineTo(w * .8502, h * .3083);
    c.lineTo(w * .8682, h * .3061);
    c.lineTo(w, h * .3664);
    c.lineTo(w, h * .9099);
    c.lineTo(w * .9672, h * .9861);
    c.lineTo(w * .7926, h);
    c.lineTo(w * .6629, h * .9392);
    c.lineTo(w * .6629, h * .9099);
    c.lineTo(w * .6167, h * .9317);
    c.lineTo(w * .3813, h * .9317);
    c.lineTo(w * .1478, h * .8219);
    c.lineTo(w * .1478, h * .7093);
    c.lineTo(w * .1365, h * .7163);
    c.close();
    c.fillAndStroke()
}
;
mxShapeAws3dRedshift.prototype.foreground = function(c, x, y, w, h, strokeWidth) {
    c.restore();
    c.setShadow(false);
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dRedshift.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(0, h * .6541);
    c.lineTo(0, h * .0933);
    c.lineTo(w * .1371, h * .1573);
    c.lineTo(w * .1371, h * .7157);
    c.close();
    c.moveTo(w * .1485, h * .8219);
    c.lineTo(w * .1485, h * .2864);
    c.lineTo(w * .3846, h * .3941);
    c.lineTo(w * .3846, h * .9317);
    c.close();
    c.moveTo(w * .6642, h * .9392);
    c.lineTo(w * .6642, h * .4011);
    c.lineTo(w * .796, h * .4597);
    c.lineTo(w * .796, h);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .1371, h * .7157);
    c.lineTo(w * .1371, h * .1568);
    c.lineTo(w * .2027, h * .1525);
    c.lineTo(w * .1498, h * .1771);
    c.lineTo(w * .1498, h * .7061);
    c.close();
    c.moveTo(w * .3846, h * .3941);
    c.lineTo(w * .614, h * .3941);
    c.lineTo(w * .6809, h * .3632);
    c.lineTo(w * .6642, h * .4);
    c.lineTo(w * .6642, h * .9067);
    c.lineTo(w * .6191, h * .9317);
    c.lineTo(w * .3833, h * .9317);
    c.close();
    c.moveTo(w * .796, h * .4608);
    c.lineTo(w * .9639, h * .4469);
    c.lineTo(w, h * .3691);
    c.lineTo(w, h * .9077);
    c.lineTo(w * .9686, h * .9856);
    c.lineTo(w * .796, h);
    c.close();
    c.moveTo(w * .3378, h * .0608);
    c.lineTo(w * .3378, h * .0907);
    c.lineTo(w * .3197, h * .1008);
    c.close();
    c.moveTo(w * .8502, h * .2843);
    c.lineTo(w * .8502, h * .3083);
    c.lineTo(w * .794, h * .3136);
    c.close();
    c.fill();
    c.restore();
    c.setShadow(false);
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .6541);
    c.lineTo(0, h * .0933);
    c.lineTo(w * .1371, h * .1573);
    c.lineTo(w * .1371, h * .7157);
    c.close();
    c.moveTo(w * .1485, h * .8219);
    c.lineTo(w * .1485, h * .2864);
    c.lineTo(w * .3846, h * .3941);
    c.lineTo(w * .3846, h * .9317);
    c.close();
    c.moveTo(w * .6642, h * .9392);
    c.lineTo(w * .6642, h * .4011);
    c.lineTo(w * .796, h * .4597);
    c.lineTo(w * .796, h);
    c.close();
    c.moveTo(w * .1371, h * .7157);
    c.lineTo(w * .1371, h * .1568);
    c.lineTo(w * .2027, h * .1525);
    c.lineTo(w * .1498, h * .1771);
    c.lineTo(w * .1498, h * .7061);
    c.close();
    c.moveTo(w * .3846, h * .3941);
    c.lineTo(w * .614, h * .3941);
    c.lineTo(w * .6809, h * .3632);
    c.lineTo(w * .6642, h * .4);
    c.lineTo(w * .6642, h * .9067);
    c.lineTo(w * .6191, h * .9317);
    c.lineTo(w * .3833, h * .9317);
    c.close();
    c.moveTo(w * .796, h * .4608);
    c.lineTo(w * .9639, h * .4469);
    c.lineTo(w, h * .3691);
    c.lineTo(w, h * .9077);
    c.lineTo(w * .9686, h * .9856);
    c.lineTo(w * .796, h);
    c.close();
    c.moveTo(w * .3378, h * .0608);
    c.lineTo(w * .3378, h * .0907);
    c.lineTo(w * .3197, h * .1008);
    c.close();
    c.moveTo(w * .8502, h * .2843);
    c.lineTo(w * .8502, h * .3083);
    c.lineTo(w * .794, h * .3136);
    c.close();
    c.moveTo(w * .6167, h * .3941);
    c.lineTo(w * .6167, h * .9317);
    c.moveTo(w * .9652, h * .4448);
    c.lineTo(w * .9652, h * .9851);
    c.stroke();
    c.restore();
    c.setShadow(false);
    var strokeColor = mxUtils.getValue(this.state.style, "strokeColor", "#000000");
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .4903, h * .1259);
    c.arcTo(w * .01, h * .008, 0, 0, 1, w * .5023, h * .1189);
    c.arcTo(w * .2007, h * .16, 0, 0, 1, w * .5639, h * .1333);
    c.arcTo(w * .602, h * .48, 0, 0, 1, w * .7157, h * .2005);
    c.arcTo(w * .2006, h * .16, 0, 0, 1, w * .7565, h * .2315);
    c.arcTo(w * .01, h * .008, 0, 0, 1, w * .7445, h * .2421);
    c.arcTo(w * .2676, h * .2133, 0, 0, 1, w * .6742, h * .2251);
    c.arcTo(w * .602, h * .48, 0, 0, 1, w * .5204, h * .1541);
    c.arcTo(w * .1338, h * .1067, 0, 0, 1, w * .4903, h * .1259);
    c.close();
    c.moveTo(w * .4789, h * .1275);
    c.arcTo(w * .0334, h * .0267, 0, 0, 0, w * .487, h * .1461);
    c.arcTo(w * .1672, h * .1333, 0, 0, 0, w * .5237, h * .1728);
    c.arcTo(w * .6689, h * .5333, 0, 0, 0, w * .6609, h * .2352);
    c.arcTo(w * .2676, h * .2133, 0, 0, 0, w * .7244, h * .2501);
    c.arcTo(w * .0201, h * .016, 0, 0, 0, w * .7411, h * .2475);
    c.lineTo(w * .5385, h * .3408);
    c.arcTo(w * .0669, h * .05333, 0, 0, 1, w * .512, h * .3397);
    c.arcTo(w * .2676, h * .2133, 0, 0, 1, w * .4548, h * .3248);
    c.arcTo(w * .6689, h * .5333, 0, 0, 1, w * .3084, h * .2565);
    c.arcTo(w * .1672, h * .1333, 0, 0, 1, w * .2776, h * .2304);
    c.arcTo(w * .01, h * .008, 0, 0, 1, w * .2776, h * .2197);
    c.close();
    c.fill();
    var fillColor = mxUtils.getValue(this.state.style, "fillColor", "#ffffff");
    c.setFillColor(fillColor);
    c.setLineJoin("round");
    c.setLineCap("round");
    c.begin();
    c.moveTo(w * .3398, h * .2421);
    c.lineTo(w * .4769, h * .1797);
    c.lineTo(w * .6341, h * .2512);
    c.lineTo(w * .4936, h * .3147);
    c.fill();
    c.begin();
    c.moveTo(w * .4334, h * .1941);
    c.lineTo(w * .6207, h * .2811);
    c.moveTo(w * .5338, h * .1995);
    c.lineTo(w * .3866, h * .2688);
    c.moveTo(w * .5873, h * .2235);
    c.lineTo(w * .4334, h * .2955);
    c.stroke();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.begin();
    c.moveTo(0, h * .6517);
    c.lineTo(0, h * .0912);
    c.lineTo(w * .0368, h * .0155);
    c.lineTo(w * .2047, 0);
    c.lineTo(w * .3378, h * .0619);
    c.lineTo(w * .3378, h * .0912);
    c.lineTo(w * .3819, h * .0693);
    c.lineTo(w * .6154, h * .0693);
    c.lineTo(w * .8502, h * .1776);
    c.lineTo(w * .8502, h * .3083);
    c.lineTo(w * .8682, h * .3061);
    c.lineTo(w, h * .3664);
    c.lineTo(w, h * .9099);
    c.lineTo(w * .9672, h * .9861);
    c.lineTo(w * .7926, h);
    c.lineTo(w * .6629, h * .9392);
    c.lineTo(w * .6629, h * .9099);
    c.lineTo(w * .6167, h * .9317);
    c.lineTo(w * .3813, h * .9317);
    c.lineTo(w * .1478, h * .8219);
    c.lineTo(w * .1478, h * .7093);
    c.lineTo(w * .1365, h * .7163);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dRedshift.prototype.cst.REDSHIFT, mxShapeAws3dRedshift);
function mxShapeAws3dLambda(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dLambda, mxShape);
mxShapeAws3dLambda.prototype.cst = {
    LAMBDA: "mxgraph.aws3d.lambda",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dLambda.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 92;
    var strokeWidth2 = strokeWidth * h / 109.5;
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    this.background(c, 0, 0, w, h, strokeWidth);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h, strokeWidth)
}
;
mxShapeAws3dLambda.prototype.background = function(c, x, y, w, h, strokeWidth) {
    c.setStrokeWidth(strokeWidth);
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .1671);
    c.lineTo(w * .3424, 0);
    c.lineTo(w * .663, 0);
    c.lineTo(w, h * .1671);
    c.lineTo(w, h * .8365);
    c.lineTo(w * .663, h);
    c.lineTo(w * .3424, h);
    c.lineTo(0, h * .8365);
    c.close();
    c.fillAndStroke()
}
;
mxShapeAws3dLambda.prototype.foreground = function(c, x, y, w, h, strokeWidth) {
    c.restore();
    c.setShadow(false);
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dLambda.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(0, h * .3242);
    c.lineTo(w * .3424, h * .4895);
    c.lineTo(w * .663, h * .4895);
    c.lineTo(w * .663, h);
    c.lineTo(w * .3424, h);
    c.lineTo(0, h * .8365);
    c.close();
    c.moveTo(w * 0, h * 0);
    c.lineTo(w * 0, h * 0);
    c.lineTo(w * 0, h * 0);
    c.lineTo(w * 0, h * 0);
    c.lineTo(w * 0, h * 0);
    c.lineTo(w * 0, h * 0);
    c.close();
    c.moveTo(w * 0, h * 0);
    c.lineTo(w * 0, h * 0);
    c.lineTo(w * 0, h * 0);
    c.lineTo(w * 0, h * 0);
    c.lineTo(w * 0, h * 0);
    c.lineTo(w * 0, h * 0);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .663, h * .4895);
    c.lineTo(w, h * .3242);
    c.lineTo(w, h * .8365);
    c.lineTo(w * .663, h);
    c.close();
    c.fill();
    c.restore();
    c.setShadow(false);
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .3242);
    c.lineTo(w * .3424, h * .4895);
    c.lineTo(w * .663, h * .4895);
    c.lineTo(w, h * .3242);
    c.moveTo(w * .3424, h * .4895);
    c.lineTo(w * .3424, h);
    c.moveTo(w * .663, h * .4895);
    c.lineTo(w * .663, h);
    c.stroke();
    c.setFillColor("#5E5E5E");
    c.begin();
    c.moveTo(w * .3804, h * .1169);
    c.arcTo(w * .5435, h * .4566, 0, 0, 1, w * .6087, h * .1123);
    c.arcTo(w * .33804, h * .3196, 0, 0, 1, w * .725, h * .1553);
    c.arcTo(w * .1304, h * .1096, 0, 0, 1, w * .7924, h * .2402);
    c.arcTo(w * .1522, h * .1279, 0, 0, 1, w * .725, h * .3333);
    c.arcTo(w * .4416, h * .274, 0, 0, 1, w * .6087, h * .3772);
    c.arcTo(w * .5435, h * .4566, 0, 0, 1, w * .3804, h * .3708);
    c.arcTo(w * .3804, h * .3196, 0, 0, 1, w * .2772, h * .3324);
    c.arcTo(w * .1522, h * .1279, 0, 0, 1, w * .2163, h * .2539);
    c.arcTo(w * .1522, h * .1279, 0, 0, 1, w * .2663, h * .1644);
    c.arcTo(w * .3804, h * .3196, 0, 0, 1, w * .3804, h * .1169);
    c.fill();
    c.setFillColor("#ffffff");
    c.begin();
    c.moveTo(w * .5565, h * .2174);
    c.arcTo(w * .0652, h * .0548, 0, 0, 0, w * .5837, h * .1945);
    c.arcTo(w * .0326, h * .0274, 0, 0, 0, w * .5793, h * .1671);
    c.arcTo(w * .0652, h * .0548, 0, 0, 0, w * .525, h * .1598);
    c.arcTo(w * .0652, h * .0548, 0, 0, 1, w * .5543, h * .1443);
    c.arcTo(w * .0761, h * .0639, 0, 0, 1, w * .6163, h * .1662);
    c.arcTo(w * .0598, h * .0502, 0, 0, 1, w * .6087, h * .2091);
    c.lineTo(w * .5, h * .3032);
    c.arcTo(w * .0978, h * .0822, 0, 0, 0, w * .4728, h * .3379);
    c.arcTo(w * .0272, h * .0228, 0, 0, 0, w * .4924, h * .3571);
    c.arcTo(w * .0326, h * .0274, 0, 0, 1, w * .4489, h * .3571);
    c.arcTo(w * .038, h * .032, 0, 0, 1, w * .437, h * .3242);
    c.arcTo(w * .1087, h * .0913, 0, 0, 1, w * .4674, h * .2886);
    c.lineTo(w * .5141, h * .2557);
    c.lineTo(w * .3185, h * .2895);
    c.lineTo(w * .2641, h * .2648);
    c.close();
    c.fill();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.begin();
    c.moveTo(0, h * .1671);
    c.lineTo(w * .3424, 0);
    c.lineTo(w * .663, 0);
    c.lineTo(w, h * .1671);
    c.lineTo(w, h * .8365);
    c.lineTo(w * .663, h);
    c.lineTo(w * .3424, h);
    c.lineTo(0, h * .8365);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dLambda.prototype.cst.LAMBDA, mxShapeAws3dLambda);
function mxShapeAws3dEbs2(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAws3dEbs2, mxShape);
mxShapeAws3dEbs2.prototype.cst = {
    EBS2: "mxgraph.aws3d.ebs2",
    SHADING_COLORS: "shadingCols"
};
mxShapeAws3dEbs2.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeWidth = parseFloat(mxUtils.getValue(this.state.style, "strokeWidth", "1"));
    var strokeWidth1 = strokeWidth * w / 92;
    var strokeWidth2 = strokeWidth * h / 60;
    var isShadow = parseFloat(mxUtils.getValue(this.state.style, "shadow", "0"));
    strokeWidth = Math.min(strokeWidth1, strokeWidth2);
    c.setStrokeWidth(strokeWidth);
    c.setShadow(false);
    c.save();
    c.save();
    c.setStrokeWidth(2 * strokeWidth);
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    if (isShadow == 1)
        c.setShadow(true);
    c.begin();
    c.moveTo(0, h * .5276);
    c.lineTo(0, h * .4188);
    c.lineTo(w * .071, h * .2898);
    c.lineTo(w * .4033, 0);
    c.lineTo(w * .9301, h * .464);
    c.lineTo(w, h * .5863);
    c.lineTo(w, h * .7035);
    c.lineTo(w * .6667, h);
    c.lineTo(w * .5355, h);
    c.close();
    c.fillAndStroke();
    c.restore();
    c.setFillColor("#000000");
    var shading = mxUtils.getValue(this.state.style, mxShapeAws3dEbs2.prototype.cst.SHADING_COLORS, "0.1,0.3").toString().split(",");
    var flipH = mxUtils.getValue(this.state.style, "flipH", "0");
    flipH == "0" ? c.setAlpha(shading[0]) : c.setAlpha(shading[1]);
    c.begin();
    c.moveTo(w * .071, h * .2948);
    c.lineTo(w * .6011, h * .7621);
    c.lineTo(w * .6667, h);
    c.lineTo(w * .5355, h);
    c.lineTo(0, h * .5276);
    c.lineTo(0, h * .4137);
    c.close();
    c.fill();
    flipH == "0" ? c.setAlpha(shading[1]) : c.setAlpha(shading[0]);
    c.begin();
    c.moveTo(w * .6011, h * .7655);
    c.lineTo(w * .9344, h * .4724);
    c.lineTo(w, h * .7035);
    c.lineTo(w * .6667, h);
    c.close();
    c.fill();
    c.restore();
    c.setLineJoin("round");
    c.begin();
    c.moveTo(w * .071, h * .2948);
    c.lineTo(w * .6011, h * .7621);
    c.lineTo(w * .6667, h);
    c.lineTo(w * .5355, h);
    c.lineTo(0, h * .5276);
    c.lineTo(0, h * .4137);
    c.close();
    c.moveTo(w * .6011, h * .7655);
    c.lineTo(w * .9344, h * .4724);
    c.lineTo(w, h * .7035);
    c.lineTo(w * .6667, h);
    c.close();
    c.moveTo(w * .0033, h * .5276);
    c.lineTo(w * .071, h * .2898);
    c.moveTo(w * .5325, h * .9976);
    c.lineTo(w * .603, h * .7593);
    c.stroke();
    c.setStrokeWidth(2 * strokeWidth);
    c.setLineCap("round");
    c.begin();
    c.moveTo(w * .3388, h * .3802);
    c.lineTo(w * .5027, h * .2345);
    c.lineTo(w * .6667, h * .3802);
    c.lineTo(w * .5027, h * .526);
    c.close();
    c.moveTo(w * .4426, h * .3802);
    c.lineTo(w * .5027, h * .3266);
    c.lineTo(w * .5628, h * .3802);
    c.lineTo(w * .5027, h * .4338);
    c.close();
    c.moveTo(w * .3867, h * .3284);
    c.lineTo(w * .3541, h * .2998);
    c.moveTo(w * .4436, h * .2748);
    c.lineTo(w * .4077, h * .2412);
    c.moveTo(w * .5704, h * .2803);
    c.lineTo(w * .5992, h * .2513);
    c.moveTo(w * .6231, h * .3284);
    c.lineTo(w * .6503, h * .3032);
    c.moveTo(w * .622, h * .4338);
    c.lineTo(w * .6557, h * .4606);
    c.moveTo(w * .5667, h * .4845);
    c.lineTo(w * .5992, h * .5156);
    c.moveTo(w * .4414, h * .4874);
    c.lineTo(w * .412, h * .5159);
    c.moveTo(w * .3889, h * .4405);
    c.lineTo(w * .3607, h * .4657);
    c.stroke();
    c.setStrokeColor("#292929");
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h * .5276);
    c.lineTo(0, h * .4188);
    c.lineTo(w * .071, h * .2898);
    c.lineTo(w * .4033, 0);
    c.lineTo(w * .9301, h * .464);
    c.lineTo(w, h * .5863);
    c.lineTo(w, h * .7035);
    c.lineTo(w * .6667, h);
    c.lineTo(w * .5355, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAws3dEbs2.prototype.cst.EBS2, mxShapeAws3dEbs2);
function mxShapeAndroidTabBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAndroidTabBar, mxShape);
mxShapeAndroidTabBar.prototype.cst = {
    MAIN_TEXT: "mainText",
    SHAPE_TAB_BAR: "mxgraph.android.tabBar",
    TEXT_COLOR: "textColor",
    TEXT_COLOR2: "textColor2",
    STROKE_COLOR2: "strokeColor2",
    FILL_COLOR2: "fillColor2",
    SELECTED: "+",
    TEXT_SIZE: "textSize"
};
mxShapeAndroidTabBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    var textStrings = mxUtils.getValue(this.style, mxShapeAndroidTabBar.prototype.cst.MAIN_TEXT, "+Tab 1, Tab 2, Tab 3").toString().split(",");
    var fontColor = mxUtils.getValue(this.style, mxShapeAndroidTabBar.prototype.cst.TEXT_COLOR, "none");
    var selectedFontColor = mxUtils.getValue(this.style, mxShapeAndroidTabBar.prototype.cst.TEXT_COLOR2, "none");
    var fontSize = mxUtils.getValue(this.style, mxShapeAndroidTabBar.prototype.cst.TEXT_SIZE, "17").toString();
    var frameColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "none");
    var separatorColor = mxUtils.getValue(this.style, mxShapeAndroidTabBar.prototype.cst.STROKE_COLOR2, "none");
    var bgColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "none");
    var selectedFillColor = mxUtils.getValue(this.style, mxShapeAndroidTabBar.prototype.cst.FILL_COLOR2, "none");
    var buttonNum = textStrings.length;
    var buttonWidths = new Array(buttonNum);
    var buttonTotalWidth = 0;
    var selectedButton = -1;
    var labelOffset = 5;
    for (var i = 0; i < buttonNum; i++) {
        var buttonText = textStrings[i];
        if (buttonText.charAt(0) === mxShapeAndroidTabBar.prototype.cst.SELECTED) {
            buttonText = textStrings[i].substring(1);
            selectedButton = i
        }
        buttonWidths[i] = mxUtils.getSizeForString(buttonText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
        buttonTotalWidth += buttonWidths[i]
    }
    var trueH = Math.max(h, fontSize * 1.5, 7);
    var minW = 2 * labelOffset * buttonNum + buttonTotalWidth;
    var trueW = Math.max(w, minW);
    c.translate(x, y);
    this.background(c, trueW, trueH, buttonNum, buttonWidths, labelOffset, minW, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton);
    c.setShadow(false);
    c.setFontStyle(mxConstants.FONT_BOLD);
    var currWidth = 0;
    for (var i = 0; i < buttonNum; i++) {
        if (i === selectedButton)
            c.setFontColor(selectedFontColor);
        else
            c.setFontColor(fontColor);
        currWidth = currWidth + labelOffset;
        this.buttonText(c, currWidth, trueH, textStrings[i], buttonWidths[i], fontSize, minW, trueW);
        currWidth = currWidth + buttonWidths[i] + labelOffset
    }
}
;
mxShapeAndroidTabBar.prototype.background = function(c, w, h, buttonNum, buttonWidths, labelOffset, minW, frameColor, separatorColor, bgColor, selectedFillColor, selectedButton) {
    c.begin();
    c.setStrokeColor(frameColor);
    c.setFillColor(bgColor);
    c.rect(0, 0, w, h);
    c.fillAndStroke();
    c.setStrokeColor(separatorColor);
    c.begin();
    for (var i = 1; i < buttonNum; i++)
        if (i !== selectedButton && i !== selectedButton + 1) {
            var currWidth = 0;
            for (var j = 0; j < i; j++)
                currWidth += buttonWidths[j] + 2 * labelOffset;
            currWidth = currWidth * w / minW;
            c.moveTo(currWidth, h * .2);
            c.lineTo(currWidth, h * .8)
        }
    c.stroke();
    var buttonLeft = 0;
    c.setFillColor(selectedFillColor);
    for (var i = 0; i < selectedButton; i++)
        buttonLeft += buttonWidths[i] + 2 * labelOffset;
    buttonLeft = buttonLeft * w / minW;
    var buttonRight = (buttonWidths[selectedButton] + 2 * labelOffset) * w / minW;
    buttonRight += buttonLeft;
    c.rect(buttonLeft, 0, buttonRight - buttonLeft, h);
    c.fill();
    c.setAlpha(1);
    c.setFillColor("#33b5e5");
    c.rect(buttonLeft, h * .9, buttonRight - buttonLeft, h * .1);
    c.fill()
}
;
mxShapeAndroidTabBar.prototype.buttonText = function(c, w, h, textString, buttonWidth, fontSize, minW, trueW) {
    if (textString.charAt(0) === mxShapeAndroidTabBar.prototype.cst.SELECTED)
        textString = textString.substring(1);
    c.begin();
    c.setFontSize(fontSize);
    c.text((w + buttonWidth * .5) * trueW / minW, h * .5, 0, 0, textString, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxShapeAndroidTabBar.prototype.cst.SHAPE_TAB_BAR, mxShapeAndroidTabBar);
function mxShapeAndroidPhone(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAndroidPhone, mxShape);
mxShapeAndroidPhone.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = 25;
    c.roundrect(0, 0, w, h, rSize, rSize);
    c.fillAndStroke();
    c.setShadow(false);
    this.foreground(c, x, y, w, h, rSize)
}
;
mxShapeAndroidPhone.prototype.foreground = function(c, x, y, w, h, rSize) {
    c.rect(w * .0625, h * .15, w * .875, h * .7);
    c.stroke();
    c.ellipse(w * .4875, h * .04125, w * .025, h * .0125);
    c.stroke();
    c.roundrect(w * .375, h * .075, w * .25, h * .01875, w * .02, h * .01);
    c.stroke();
    c.ellipse(w * .4, h * .875, w * .2, h * .1);
    c.stroke();
    c.roundrect(w * .4575, h * .905, w * .085, h * .04375, h * .00625, h * .00625);
    c.stroke()
}
;
mxCellRenderer.registerShape("mxgraph.android.phone", mxShapeAndroidPhone);
function mxShapeAndroidStatusBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAndroidStatusBar, mxShape);
mxShapeAndroidStatusBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeAndroidStatusBar.prototype.background = function(c, x, y, w, h) {
    c.rect(0, 0, w, h);
    c.fill()
}
;
mxShapeAndroidStatusBar.prototype.foreground = function(c, x, y, w, h) {
    c.rect(0, 0, w, h);
    c.fill();
    c.setFontColor(mxUtils.getValue(this.style, mxConstants.STYLE_FONTCOLOR, "#222222"));
    c.setFontSize(mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "5"));
    c.text(w - 30, h * .5 + 1, 0, 0, "12:00", mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setFillColor("#444444");
    c.begin();
    c.moveTo(w - 37, h * .5 + 6);
    c.lineTo(w - 37, h * .5 - 5);
    c.lineTo(w - 36, h * .5 - 5);
    c.lineTo(w - 36, h * .5 - 6);
    c.lineTo(w - 32, h * .5 - 6);
    c.lineTo(w - 32, h * .5 - 5);
    c.lineTo(w - 31, h * .5 - 5);
    c.lineTo(w - 31, h * .5 + 6);
    c.close();
    c.fill();
    c.setFillColor(mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "none"));
    c.ellipse(w - 56, h * .5 + 2, 2, 2);
    c.fillAndStroke();
    c.setStrokeWidth(2);
    c.begin();
    c.moveTo(w - 52, h * .5 + 1);
    c.arcTo(3.5, 3.5, 0, 0, 0, w - 58, h * .5 + 1);
    c.stroke();
    c.begin();
    c.moveTo(w - 50, h * .5 - 1);
    c.arcTo(6, 6, 0, 0, 0, w - 60, h * .5 - 1);
    c.stroke();
    c.setStrokeWidth(1);
    c.rect(w - 51, h * .5 + 5, 2, 1);
    c.fill();
    c.rect(w - 48, h * .5 + 2, 2, 4);
    c.fill();
    c.rect(w - 45, h * .5 - 1, 2, 7);
    c.fill();
    c.rect(w - 42, h * .5 - 4, 2, 10);
    c.fill();
    c.rect(w - 37, h * .5 - 2, 6, 8);
    c.fill()
}
;
mxCellRenderer.registerShape("mxgraph.android.statusBar", mxShapeAndroidStatusBar);
function mxShapeAndroidCheckboxGroup(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAndroidCheckboxGroup, mxShape);
mxShapeAndroidCheckboxGroup.prototype.cst = {
    STYLE_TEXTCOLOR2: "textColor2",
    STYLE_STROKECOLOR2: "strokeColor2",
    BUTTON_TEXT: "buttonText",
    SELECTED: "+"
};
mxShapeAndroidCheckboxGroup.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var fontColor = mxUtils.getValue(this.style, mxConstants.STYLE_TEXTCOLOR, "#666666");
    var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "8").toString();
    var optionText = mxUtils.getValue(this.style, mxShapeAndroidCheckboxGroup.prototype.cst.BUTTON_TEXT, "Option 1").toString().split(",");
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "none");
    var strokeColor2 = mxUtils.getValue(this.style, mxShapeAndroidCheckboxGroup.prototype.cst.STYLE_STROKECOLOR2, "none");
    c.setStrokeColor(strokeColor2);
    var optionNum = optionText.length;
    var buttonSize = 5;
    var lineH = Math.max(fontSize * 1.5, buttonSize);
    var maxTextWidth = 0;
    var selected = -1;
    var labelOffset = 2.5;
    var minH = optionNum * lineH;
    var trueH = Math.max(h, minH);
    for (var i = 0; i < optionNum; i++) {
        var currText = optionText[i];
        if (currText.charAt(0) === mxShapeAndroidCheckboxGroup.prototype.cst.SELECTED) {
            currText = optionText[i].substring(1);
            selected = i
        }
        var currWidth = mxUtils.getSizeForString(currText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
        if (currWidth > maxTextWidth)
            maxTextWidth = currWidth
    }
    var minW = 2 * labelOffset + maxTextWidth + 2 * buttonSize;
    var trueW = Math.max(w, minW);
    c.roundrect(0, 0, trueW, trueH, 2.5, 2.5);
    c.fillAndStroke();
    c.setShadow(false);
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    c.setStrokeColor(strokeColor);
    for (var i = 0; i < optionNum; i++) {
        var currHeight = (i * lineH + lineH * .5) * trueH / minH;
        var currText = optionText[i];
        if (currText.charAt(0) === mxShapeAndroidCheckboxGroup.prototype.cst.SELECTED) {
            currText = optionText[i].substring(1);
            selected = i
        }
        c.text(buttonSize * 2 + labelOffset, currHeight, 0, 0, currText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
        var iconX = buttonSize * .5;
        var iconY = currHeight - buttonSize * .5;
        if (selected === i) {
            c.rect(iconX, iconY, buttonSize, buttonSize);
            c.fillAndStroke();
            c.begin();
            c.moveTo(iconX + buttonSize * .25, iconY + buttonSize * .5);
            c.lineTo(iconX + buttonSize * .5, iconY + buttonSize * .75);
            c.lineTo(iconX + buttonSize * .75, iconY + buttonSize * .25);
            c.stroke()
        } else {
            c.rect(iconX, iconY, buttonSize, buttonSize);
            c.fillAndStroke()
        }
        selected = -1
    }
}
;
mxCellRenderer.registerShape("mxgraph.android.checkboxGroup", mxShapeAndroidCheckboxGroup);
function mxShapeAndroidRadioGroup(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAndroidRadioGroup, mxShape);
mxShapeAndroidRadioGroup.prototype.cst = {
    STYLE_TEXTCOLOR2: "textColor2",
    STYLE_STROKECOLOR2: "strokeColor2",
    BUTTON_TEXT: "buttonText",
    SELECTED: "+"
};
mxShapeAndroidRadioGroup.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var fontColor = mxUtils.getValue(this.style, mxConstants.STYLE_TEXTCOLOR, "#666666");
    var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "8").toString();
    var optionText = mxUtils.getValue(this.style, mxShapeAndroidRadioGroup.prototype.cst.BUTTON_TEXT, "Option 1").toString().split(",");
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "none");
    var strokeColor2 = mxUtils.getValue(this.style, mxShapeAndroidRadioGroup.prototype.cst.STYLE_STROKECOLOR2, "none");
    c.setStrokeColor(strokeColor2);
    var optionNum = optionText.length;
    var buttonSize = 5;
    var lineH = Math.max(fontSize * 1.5, buttonSize);
    var maxTextWidth = 0;
    var selected = -1;
    var labelOffset = 2.5;
    var minH = optionNum * lineH;
    var trueH = Math.max(h, minH);
    for (var i = 0; i < optionNum; i++) {
        var currText = optionText[i];
        if (currText.charAt(0) === mxShapeAndroidRadioGroup.prototype.cst.SELECTED) {
            currText = optionText[i].substring(1);
            selected = i
        }
        var currWidth = mxUtils.getSizeForString(currText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
        if (currWidth > maxTextWidth)
            maxTextWidth = currWidth
    }
    var minW = 2 * labelOffset + maxTextWidth + 2 * buttonSize;
    var trueW = Math.max(w, minW);
    c.roundrect(0, 0, trueW, trueH, 2.5, 2.5);
    c.fillAndStroke();
    c.setShadow(false);
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    c.setStrokeColor(strokeColor);
    c.setFillColor(strokeColor);
    for (var i = 0; i < optionNum; i++) {
        var currHeight = (i * lineH + lineH * .5) * trueH / minH;
        var currText = optionText[i];
        if (currText.charAt(0) === mxShapeAndroidRadioGroup.prototype.cst.SELECTED) {
            currText = optionText[i].substring(1);
            selected = i
        }
        c.text(buttonSize * 2 + labelOffset, currHeight, 0, 0, currText, mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
        var iconX = buttonSize * .5;
        var iconY = currHeight - buttonSize * .5;
        if (selected === i) {
            c.ellipse(iconX, iconY, buttonSize, buttonSize);
            c.stroke();
            c.ellipse(iconX + buttonSize * .25, iconY + buttonSize * .25, buttonSize * .5, buttonSize * .5);
            c.fillAndStroke()
        } else {
            c.ellipse(iconX, iconY, buttonSize, buttonSize);
            c.stroke()
        }
    }
}
;
mxCellRenderer.registerShape("mxgraph.android.radioGroup", mxShapeAndroidRadioGroup);
function mxShapeAndroidMenuBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAndroidMenuBar, mxShape);
mxShapeAndroidMenuBar.prototype.cst = {
    MENU_TEXT: "menuText"
};
mxShapeAndroidMenuBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    var textStrings = mxUtils.getValue(this.style, mxShapeAndroidMenuBar.prototype.cst.MENU_TEXT, "Item 1, Item 2, Item 3").toString().split(",");
    var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "12");
    var buttonNum = textStrings.length;
    var maxButtonWidth = 0;
    var labelOffset = 2.5;
    for (var i = 0; i < buttonNum; i++) {
        var buttonText = textStrings[i];
        var currWidth = mxUtils.getSizeForString(buttonText, fontSize, mxConstants.DEFAULT_FONTFAMILY).width;
        if (currWidth > maxButtonWidth)
            maxButtonWidth = currWidth
    }
    var minButtonHeight = fontSize * 1.5;
    var minH = buttonNum * minButtonHeight;
    var trueH = Math.max(h, minH);
    var minW = 2 * labelOffset + maxButtonWidth;
    var trueW = Math.max(w, minW);
    c.translate(x, y);
    c.rect(0, 0, w, trueH);
    c.fillAndStroke();
    c.setShadow(false);
    c.begin();
    for (var i = 1; i < buttonNum; i++) {
        var currHeight = i * minButtonHeight * trueH / minH;
        c.moveTo(0, currHeight);
        c.lineTo(w, currHeight)
    }
    c.stroke();
    for (var i = 0; i < buttonNum; i++) {
        currWidth = currWidth + labelOffset;
        var currHeight = (i * minButtonHeight + minButtonHeight * .5) * trueH / minH;
        c.text(10, currHeight, 0, 0, textStrings[i], mxConstants.ALIGN_LEFT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
    }
}
;
mxCellRenderer.registerShape("mxgraph.android.menuBar", mxShapeAndroidMenuBar);
function mxShapeAndroidTextSelHandles(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAndroidTextSelHandles, mxShape);
mxShapeAndroidTextSelHandles.prototype.paintVertexShape = function(c, x, y, w, h) {
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "none");
    c.translate(x, y);
    var handleSizeX = 15;
    var barH = Math.max(0, h - handleSizeX * 1.5);
    c.setAlpha(.5);
    c.rect(handleSizeX, 0, w - 2 * handleSizeX, barH);
    c.fill();
    c.begin();
    c.moveTo(0, h - handleSizeX);
    c.lineTo(handleSizeX * .5, h - handleSizeX * 1.5);
    c.lineTo(handleSizeX, h - handleSizeX);
    c.close();
    c.moveTo(w - handleSizeX, h - handleSizeX);
    c.lineTo(w - handleSizeX * .5, h - handleSizeX * 1.5);
    c.lineTo(w, h - handleSizeX);
    c.close();
    c.fill();
    c.setFillColor(strokeColor);
    c.rect(0, h - handleSizeX, handleSizeX, handleSizeX);
    c.fill();
    c.rect(w - handleSizeX, h - handleSizeX, handleSizeX, handleSizeX);
    c.fill()
}
;
mxCellRenderer.registerShape("mxgraph.android.textSelHandles", mxShapeAndroidTextSelHandles);
function mxShapeAndroidIndeterminateSpinner(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAndroidIndeterminateSpinner, mxShape);
mxShapeAndroidIndeterminateSpinner.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h)
}
;
mxShapeAndroidIndeterminateSpinner.prototype.background = function(c, x, y, w, h) {
    c.setGradient("#aaaaaa", "#dddddd", w * .325, 0, w * .675, h * .5, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.begin();
    c.moveTo(w * .5, h * .1);
    c.arcTo(w * .4, h * .4, 0, 0, 0, w * .5, h * .9);
    c.lineTo(w * .5, h);
    c.arcTo(w * .5, h * .5, 0, 0, 1, w * .5, 0);
    c.close();
    c.fill();
    c.setGradient("#ffffff", "#dddddd", w * .325, 0, w * .675, h * .5, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.begin();
    c.moveTo(w * .5, h * .1);
    c.arcTo(w * .4, h * .4, 0, 0, 1, w * .5, h * .9);
    c.lineTo(w * .5, h);
    c.arcTo(w * .5, h * .5, 0, 0, 0, w * .5, 0);
    c.close();
    c.fill()
}
;
mxCellRenderer.registerShape("mxgraph.android.indeterminateSpinner", mxShapeAndroidIndeterminateSpinner);
function mxShapeAndroidAnchor(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds
}
mxUtils.extend(mxShapeAndroidAnchor, mxShape);
mxShapeAndroidAnchor.prototype.cst = {
    ANCHOR: "mxgraph.android.anchor"
};
mxShapeAndroidAnchor.prototype.paintVertexShape = function(c, x, y, w, h) {}
;
mxCellRenderer.registerShape(mxShapeAndroidAnchor.prototype.cst.ANCHOR, mxShapeAndroidAnchor);
function mxShapeAndroidRRect(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAndroidRRect, mxShape);
mxShapeAndroidRRect.prototype.cst = {
    RRECT: "mxgraph.android.rrect",
    R_SIZE: "rSize"
};
mxShapeAndroidRRect.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeAndroidRRect.prototype.cst.R_SIZE, "10"));
    c.roundrect(0, 0, w, h, rSize);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeAndroidRRect.prototype.cst.RRECT, mxShapeAndroidRRect);
function mxShapeAndroidCheckbox(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAndroidCheckbox, mxShape);
mxShapeAndroidCheckbox.prototype.cst = {
    CHECKBOX: "mxgraph.android.checkbox"
};
mxShapeAndroidCheckbox.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.rect(0, 0, w, h);
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .8, h * .2);
    c.lineTo(w * .4, h * .8);
    c.lineTo(w * .25, h * .6);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAndroidCheckbox.prototype.cst.CHECKBOX, mxShapeAndroidCheckbox);
function mxShapeAndroidProgressBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx1 = .8;
    this.dx2 = .6
}
mxUtils.extend(mxShapeAndroidProgressBar, mxShape);
mxShapeAndroidProgressBar.prototype.cst = {
    PROGRESS_BAR: "mxgraph.android.progressBar"
};
mxShapeAndroidProgressBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    var dx1 = w * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx1", this.dx1))));
    var dx2 = w * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx2", this.dx2))));
    c.translate(x, y);
    c.save();
    c.save();
    c.setStrokeColor("#444444");
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(w, h * .5);
    c.stroke();
    c.restore();
    c.setShadow(false);
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(dx1, h * .5);
    c.stroke();
    c.setStrokeColor("#000000");
    c.setAlpha("0.2");
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(dx1, h * .5);
    c.stroke();
    c.restore();
    c.setShadow(false);
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(dx2, h * .5);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeAndroidProgressBar.prototype.cst.PROGRESS_BAR, mxShapeAndroidProgressBar);
mxShapeAndroidProgressBar.prototype.constraints = null;
Graph.handleFactory[mxShapeAndroidProgressBar.prototype.cst.PROGRESS_BAR] = function(state) {
    var handles = [Graph.createHandle(state, ["dx1"], function(bounds) {
        var dx1 = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "dx1", this.dx1))));
        return new mxPoint(bounds.x + dx1 * bounds.width,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["dx1"] = Math.round(100 * Math.max(0, Math.min(1, (pt.x - bounds.x) / bounds.width))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["dx2"], function(bounds) {
        var dx2 = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "dx2", this.dx1))));
        return new mxPoint(bounds.x + dx2 * bounds.width,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["dx2"] = Math.round(100 * Math.max(0, Math.min(1, (pt.x - bounds.x) / bounds.width))) / 100
    });
    handles.push(handle2);
    return handles
}
;
function mxShapeAndroidProgressScrubberDisabled(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .3
}
mxUtils.extend(mxShapeAndroidProgressScrubberDisabled, mxShape);
mxShapeAndroidProgressScrubberDisabled.prototype.cst = {
    PROGRESS_SCRUBBER_DISABLED: "mxgraph.android.progressScrubberDisabled"
};
mxShapeAndroidProgressScrubberDisabled.prototype.paintVertexShape = function(c, x, y, w, h) {
    var dx = w * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    c.translate(x, y);
    c.save();
    c.save();
    c.setStrokeColor("#444444");
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(w, h * .5);
    c.stroke();
    c.restore();
    c.setShadow(false);
    c.setAlpha("0.5");
    c.setFillColor("#666666");
    c.begin();
    var r = Math.min(h, w * .1) / 2;
    c.ellipse(dx - r, h * .5 - r, 2 * r, 2 * r);
    c.fill();
    c.restore();
    c.setShadow(false);
    c.begin();
    var r = Math.min(h, w * .1) / 8;
    c.ellipse(dx - r, h * .5 - r, 2 * r, 2 * r);
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeAndroidProgressScrubberDisabled.prototype.cst.PROGRESS_SCRUBBER_DISABLED, mxShapeAndroidProgressScrubberDisabled);
mxShapeAndroidProgressScrubberDisabled.prototype.constraints = null;
Graph.handleFactory[mxShapeAndroidProgressScrubberDisabled.prototype.cst.PROGRESS_SCRUBBER_DISABLED] = function(state) {
    var handles = [Graph.createHandle(state, ["dx"], function(bounds) {
        var dx = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        return new mxPoint(bounds.x + dx * bounds.width,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(1, (pt.x - bounds.x) / bounds.width))) / 100
    })];
    return handles
}
;
function mxShapeAndroidProgressScrubberFocused(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .3
}
mxUtils.extend(mxShapeAndroidProgressScrubberFocused, mxShape);
mxShapeAndroidProgressScrubberFocused.prototype.cst = {
    PROGRESS_SCRUBBER_FOCUSED: "mxgraph.android.progressScrubberFocused"
};
mxShapeAndroidProgressScrubberFocused.prototype.paintVertexShape = function(c, x, y, w, h) {
    var dx = w * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    var fillColor = mxUtils.getValue(this.style, "fillColor", "#ffffff");
    c.translate(x, y);
    c.save();
    c.save();
    c.setStrokeColor("#444444");
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(w, h * .5);
    c.stroke();
    c.restore();
    c.setShadow(false);
    c.setAlpha("0.75");
    c.begin();
    var r = Math.min(h, w * .1) / 2;
    c.ellipse(dx - r, h * .5 - r, 2 * r, 2 * r);
    c.fill();
    c.restore();
    c.setShadow(false);
    c.setStrokeColor(fillColor);
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(dx, h * .5);
    c.stroke();
    c.begin();
    var r = Math.min(h, w * .1) / 8;
    c.ellipse(dx - r, h * .5 - r, 2 * r, 2 * r);
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeAndroidProgressScrubberFocused.prototype.cst.PROGRESS_SCRUBBER_FOCUSED, mxShapeAndroidProgressScrubberFocused);
mxShapeAndroidProgressScrubberFocused.prototype.constraints = null;
Graph.handleFactory[mxShapeAndroidProgressScrubberFocused.prototype.cst.PROGRESS_SCRUBBER_FOCUSED] = function(state) {
    var handles = [Graph.createHandle(state, ["dx"], function(bounds) {
        var dx = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        return new mxPoint(bounds.x + dx * bounds.width,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(1, (pt.x - bounds.x) / bounds.width))) / 100
    })];
    return handles
}
;
function mxShapeAndroidProgressScrubberPressed(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .3
}
mxUtils.extend(mxShapeAndroidProgressScrubberPressed, mxShape);
mxShapeAndroidProgressScrubberPressed.prototype.cst = {
    PROGRESS_SCRUBBER_PRESSED: "mxgraph.android.progressScrubberPressed"
};
mxShapeAndroidProgressScrubberPressed.prototype.paintVertexShape = function(c, x, y, w, h) {
    var dx = w * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    var fillColor = mxUtils.getValue(this.style, "fillColor", "#ffffff");
    c.translate(x, y);
    c.save();
    c.save();
    c.setStrokeColor("#444444");
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(w, h * .5);
    c.stroke();
    c.restore();
    c.setShadow(false);
    c.setStrokeColor(fillColor);
    c.setAlpha("0.5");
    c.begin();
    var r = Math.min(h, w * .1) / 2;
    c.ellipse(dx - r, h * .5 - r, 2 * r, 2 * r);
    c.fillAndStroke();
    c.restore();
    c.setShadow(false);
    c.setStrokeColor(fillColor);
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(dx, h * .5);
    c.stroke();
    c.begin();
    var r = Math.min(h, w * .1) / 8;
    c.ellipse(dx - r, h * .5 - r, 2 * r, 2 * r);
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeAndroidProgressScrubberPressed.prototype.cst.PROGRESS_SCRUBBER_PRESSED, mxShapeAndroidProgressScrubberPressed);
mxShapeAndroidProgressScrubberPressed.prototype.constraints = null;
Graph.handleFactory[mxShapeAndroidProgressScrubberPressed.prototype.cst.PROGRESS_SCRUBBER_PRESSED] = function(state) {
    var handles = [Graph.createHandle(state, ["dx"], function(bounds) {
        var dx = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        return new mxPoint(bounds.x + dx * bounds.width,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(1, (pt.x - bounds.x) / bounds.width))) / 100
    })];
    return handles
}
;
function mxShapeAndroidQuickscroll2(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy = .5
}
mxUtils.extend(mxShapeAndroidQuickscroll2, mxShape);
mxShapeAndroidQuickscroll2.prototype.cst = {
    QUICKSCROLL: "mxgraph.android.quickscroll2"
};
mxShapeAndroidQuickscroll2.prototype.paintVertexShape = function(c, x, y, w, h) {
    var dy = Math.min(h - 20, Math.max(20, h * Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))))));
    var fillColor = mxUtils.getValue(this.style, "fillColor", "#ffffff");
    c.translate(x, y);
    c.save();
    c.save();
    c.setStrokeColor("#cccccc");
    c.begin();
    c.moveTo(w - 3, 0);
    c.lineTo(w - 3, h);
    c.stroke();
    c.restore();
    c.begin();
    c.roundrect(w - 6, dy - 10, 6, 20, 1, 1);
    c.fillAndStroke();
    c.setFillColor("#cccccc");
    c.begin();
    c.rect(0, dy - 20, w - 18, 40);
    c.fill();
    c.setFillColor("#666666");
    c.begin();
    c.moveTo(w - 18, dy - 20);
    c.lineTo(w - 6, dy);
    c.lineTo(w - 18, dy + 20);
    c.close();
    c.fill();
    c.setFontSize("12");
    c.text((w - 18) * .5, dy, 0, 0, "Aa", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxShapeAndroidQuickscroll2.prototype.cst.QUICKSCROLL, mxShapeAndroidQuickscroll2);
mxShapeAndroidQuickscroll2.prototype.constraints = null;
Graph.handleFactory[mxShapeAndroidQuickscroll2.prototype.cst.QUICKSCROLL] = function(state) {
    var handles = [Graph.createHandle(state, ["dy"], function(bounds) {
        var dy = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + bounds.width - 3,bounds.y + Math.min(bounds.height - 20, Math.max(20, dy * bounds.height)))
    }, function(bounds, pt) {
        this.state.style["dy"] = Math.round(1E3 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height))) / 1E3
    })];
    return handles
}
;
function mxShapeAndroidQuickscroll3(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy = .5
}
mxUtils.extend(mxShapeAndroidQuickscroll3, mxShape);
mxShapeAndroidQuickscroll3.prototype.cst = {
    QUICKSCROLL: "mxgraph.android.quickscroll3"
};
mxShapeAndroidQuickscroll3.prototype.paintVertexShape = function(c, x, y, w, h) {
    var dy = Math.min(h - 10, Math.max(10, h * Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))))));
    var fillColor = mxUtils.getValue(this.style, "fillColor", "#ffffff");
    c.translate(x, y);
    c.save();
    c.setStrokeColor("#cccccc");
    c.begin();
    c.moveTo(w * .5, 0);
    c.lineTo(w * .5, h);
    c.stroke();
    c.restore();
    c.begin();
    c.roundrect(w * .5 - 3, dy - 10, 6, 20, 1, 1);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeAndroidQuickscroll3.prototype.cst.QUICKSCROLL, mxShapeAndroidQuickscroll3);
mxShapeAndroidQuickscroll3.prototype.constraints = null;
Graph.handleFactory[mxShapeAndroidQuickscroll3.prototype.cst.QUICKSCROLL] = function(state) {
    var handles = [Graph.createHandle(state, ["dy"], function(bounds) {
        var dy = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + bounds.width * .5,bounds.y + Math.min(bounds.height - 10, Math.max(10, dy * bounds.height)))
    }, function(bounds, pt) {
        this.state.style["dy"] = Math.round(1E3 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height))) / 1E3
    })];
    return handles
}
;
function mxShapeAndroidScrollbars2(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAndroidScrollbars2, mxShape);
mxShapeAndroidScrollbars2.prototype.cst = {
    SCROLLBARS: "mxgraph.android.scrollbars2"
};
mxShapeAndroidScrollbars2.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.rect(w - 5, 0, 5, h - 7);
    c.fillAndStroke();
    c.begin();
    c.rect(0, h - 5, w - 7, 5);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeAndroidScrollbars2.prototype.cst.SCROLLBARS, mxShapeAndroidScrollbars2);
mxShapeAndroidScrollbars2.prototype.constraints = null;
function mxShapeAndroidSpinner2(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeAndroidSpinner2, mxShape);
mxShapeAndroidSpinner2.prototype.cst = {
    SPINNER: "mxgraph.android.spinner2"
};
mxShapeAndroidSpinner2.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.moveTo(0, h);
    c.lineTo(w, h);
    c.stroke();
    var s = Math.min(w / 10, h);
    c.begin();
    c.moveTo(w - s, h);
    c.lineTo(w, h - s);
    c.lineTo(w, h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeAndroidSpinner2.prototype.cst.SPINNER, mxShapeAndroidSpinner2);
mxShapeAndroidSpinner2.prototype.constraints = null;
function mxArchiMateLocation(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMateLocation, mxShape);
mxArchiMateLocation.prototype.cst = {
    LOCATION: "mxgraph.archimate.location"
};
mxArchiMateLocation.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false);
    c.translate(w - 20, 5);
    this.foreground(c, w - 20, 5, 15, 15)
}
;
mxArchiMateLocation.prototype.background = function(c, x, y, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxArchiMateLocation.prototype.foreground = function(c, x, y, w, h) {
    c.setDashed(false);
    c.translate(3, 0);
    w = w - 6;
    c.begin();
    c.moveTo(w * .5, h);
    c.arcTo(w * .1775, h * .3, 0, 0, 0, w * .345, h * .7);
    c.arcTo(w * .538, h * .364, 0, 0, 1, w * .5, 0);
    c.arcTo(w * .538, h * .364, 0, 0, 1, w * .655, h * .7);
    c.arcTo(w * .1775, h * .3, 0, 0, 0, w * .5, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxArchiMateLocation.prototype.cst.LOCATION, mxArchiMateLocation);
function mxArchiMateBusiness(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMateBusiness, mxShape);
mxArchiMateBusiness.prototype.cst = {
    BUSINESS: "mxgraph.archimate.business",
    TYPE: "busType",
    PROCESS: "process",
    FUNCTION: "function",
    INTERACTION: "interaction",
    EVENT: "event",
    SERVICE: "service"
};
mxArchiMateBusiness.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false);
    c.translate(w - 20, 5);
    this.foreground(c, w - 20, 5, 15, 15)
}
;
mxArchiMateBusiness.prototype.background = function(c, x, y, w, h) {
    c.roundrect(0, 0, w, h, 10, 10);
    c.fillAndStroke()
}
;
mxArchiMateBusiness.prototype.foreground = function(c, x, y, w, h) {
    var type = mxUtils.getValue(this.style, mxArchiMateBusiness.prototype.cst.TYPE, mxArchiMateBusiness.prototype.cst.PROCESS);
    c.setDashed(false);
    if (type === mxArchiMateBusiness.prototype.cst.PROCESS) {
        c.translate(0, 2);
        h = h - 4;
        c.begin();
        c.moveTo(0, h * .15);
        c.lineTo(w * .65, h * .15);
        c.lineTo(w * .65, 0);
        c.lineTo(w, h * .5);
        c.lineTo(w * .65, h);
        c.lineTo(w * .65, h * .85);
        c.lineTo(0, h * .85);
        c.close();
        c.stroke()
    } else if (type === mxArchiMateBusiness.prototype.cst.FUNCTION) {
        c.translate(2, 0);
        w = w - 4;
        c.begin();
        c.moveTo(0, h * .15);
        c.lineTo(w * .5, 0);
        c.lineTo(w, h * .15);
        c.lineTo(w, h);
        c.lineTo(w * .5, h * .85);
        c.lineTo(0, h);
        c.close();
        c.stroke()
    } else if (type === mxArchiMateBusiness.prototype.cst.INTERACTION) {
        c.begin();
        c.moveTo(w * .55, 0);
        c.arcTo(w * .45, h * .5, 0, 0, 1, w * .55, h);
        c.close();
        c.moveTo(w * .45, 0);
        c.arcTo(w * .45, h * .5, 0, 0, 0, w * .45, h);
        c.close();
        c.stroke()
    } else if (type === mxArchiMateBusiness.prototype.cst.EVENT) {
        c.translate(0, 3);
        h = h - 6;
        c.begin();
        c.moveTo(w - h * .5, 0);
        c.arcTo(h * .5, h * .5, 0, 0, 1, w - h * .5, h);
        c.lineTo(0, h);
        c.arcTo(h * .5, h * .5, 0, 0, 0, 0, 0);
        c.close();
        c.stroke()
    } else if (type === mxArchiMateBusiness.prototype.cst.SERVICE) {
        c.translate(0, 3);
        h = h - 6;
        c.begin();
        c.moveTo(w - h * .5, 0);
        c.arcTo(h * .5, h * .5, 0, 0, 1, w - h * .5, h);
        c.lineTo(0, h);
        c.arcTo(h * .5, h * .5, 0, 0, 1, 0, 0);
        c.close();
        c.stroke()
    }
}
;
mxCellRenderer.registerShape(mxArchiMateBusiness.prototype.cst.BUSINESS, mxArchiMateBusiness);
function mxArchiMateBusinessObject(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMateBusinessObject, mxShape);
mxArchiMateBusinessObject.prototype.cst = {
    BUSINESS_OBJECT: "mxgraph.archimate.businessObject"
};
mxArchiMateBusinessObject.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h)
}
;
mxArchiMateBusinessObject.prototype.background = function(c, x, y, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxArchiMateBusinessObject.prototype.foreground = function(c, x, y, w, h) {
    if (h >= 15) {
        c.begin();
        c.moveTo(0, 15);
        c.lineTo(w, 15);
        c.stroke()
    }
}
;
mxCellRenderer.registerShape(mxArchiMateBusinessObject.prototype.cst.BUSINESS_OBJECT, mxArchiMateBusinessObject);
function mxArchiMateRepresentation(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMateRepresentation, mxShape);
mxArchiMateRepresentation.prototype.cst = {
    REPRESENTATION: "mxgraph.archimate.representation"
};
mxArchiMateRepresentation.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h)
}
;
mxArchiMateRepresentation.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h * .85);
    c.arcTo(w * .35, h * .35, 0, 0, 0, w * .5, h * .85);
    c.arcTo(w * .35, h * .35, 0, 0, 1, 0, h * .85);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxArchiMateRepresentation.prototype.cst.REPRESENTATION, mxArchiMateRepresentation);
function mxArchiMateProduct(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMateProduct, mxShape);
mxArchiMateProduct.prototype.cst = {
    PRODUCT: "mxgraph.archimate.product"
};
mxArchiMateProduct.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h)
}
;
mxArchiMateProduct.prototype.background = function(c, x, y, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxArchiMateProduct.prototype.foreground = function(c, x, y, w, h) {
    if (h >= 15) {
        c.begin();
        c.moveTo(0, 15);
        c.lineTo(w * .6, 15);
        c.lineTo(w * .6, 0);
        c.stroke()
    }
}
;
mxCellRenderer.registerShape(mxArchiMateProduct.prototype.cst.PRODUCT, mxArchiMateProduct);
function mxArchiMateApplication(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMateApplication, mxShape);
mxArchiMateApplication.prototype.cst = {
    APPLICATION: "mxgraph.archimate.application",
    TYPE: "appType",
    COMPONENT: "comp",
    INTERFACE: "interface",
    INTERFACE2: "interface2",
    FUNCTION: "function",
    INTERACTION: "interaction",
    SERVICE: "service",
    NODE: "node",
    NETWORK: "network",
    COMM_PATH: "commPath",
    SYS_SW: "sysSw",
    ARTIFACT: "artifact",
    ACTOR: "actor",
    ROLE: "role",
    COLLABORATION: "collab"
};
mxArchiMateApplication.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false);
    c.translate(w - 20, 5);
    this.foreground(c, w - 20, 5, 15, 15)
}
;
mxArchiMateApplication.prototype.background = function(c, x, y, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxArchiMateApplication.prototype.foreground = function(c, x, y, w, h) {
    var type = mxUtils.getValue(this.style, mxArchiMateApplication.prototype.cst.TYPE, mxArchiMateApplication.prototype.cst.COMPONENT);
    c.setDashed(false);
    if (type === mxArchiMateApplication.prototype.cst.COMPONENT) {
        c.translate(1, 0);
        w = w - 2;
        c.rect(w * .25, 0, w * .75, h);
        c.stroke();
        c.rect(0, h * .25, w * .5, h * .15);
        c.fillAndStroke();
        c.rect(0, h * .6, w * .5, h * .15);
        c.fillAndStroke()
    } else if (type === mxArchiMateApplication.prototype.cst.COLLABORATION) {
        c.translate(0, 3);
        h = h - 6;
        c.ellipse(0, 0, w * .6, h);
        c.stroke();
        c.ellipse(w * .4, 0, w * .6, h);
        c.fillAndStroke()
    } else if (type === mxArchiMateApplication.prototype.cst.INTERFACE) {
        c.translate(0, 4);
        h = h - 8;
        c.ellipse(w * .5, 0, w * .5, h);
        c.stroke();
        c.begin();
        c.moveTo(0, h * .5);
        c.lineTo(w * .5, h * .5);
        c.stroke()
    } else if (type === mxArchiMateApplication.prototype.cst.INTERFACE2) {
        c.translate(0, 1);
        h = h - 2;
        c.begin();
        c.moveTo(0, h * .5);
        c.lineTo(w * .6, h * .5);
        c.moveTo(w, 0);
        c.arcTo(w * .4, h * .5, 0, 0, 0, w, h);
        c.stroke()
    } else if (type === mxArchiMateApplication.prototype.cst.FUNCTION) {
        c.begin();
        c.moveTo(w * .5, 0);
        c.lineTo(w, h * .2);
        c.lineTo(w, h);
        c.lineTo(w * .5, h * .8);
        c.lineTo(0, h);
        c.lineTo(0, h * .2);
        c.close();
        c.stroke()
    } else if (type === mxArchiMateApplication.prototype.cst.INTERACTION) {
        c.begin();
        c.moveTo(w * .55, 0);
        c.arcTo(w * .45, h * .5, 0, 0, 1, w * .55, h);
        c.close();
        c.moveTo(w * .45, 0);
        c.arcTo(w * .45, h * .5, 0, 0, 0, w * .45, h);
        c.close();
        c.stroke()
    } else if (type === mxArchiMateApplication.prototype.cst.SERVICE) {
        c.translate(0, 3);
        h = h - 6;
        c.begin();
        c.moveTo(w - h * .5, 0);
        c.arcTo(h * .5, h * .5, 0, 0, 1, w - h * .5, h);
        c.lineTo(0, h);
        c.arcTo(h * .5, h * .5, 0, 0, 1, 0, 0);
        c.close();
        c.stroke()
    } else if (type === mxArchiMateApplication.prototype.cst.NODE) {
        c.begin();
        c.moveTo(0, h * .25);
        c.lineTo(w * .25, 0);
        c.lineTo(w, 0);
        c.lineTo(w, h * .75);
        c.lineTo(w * .75, h);
        c.lineTo(0, h);
        c.close();
        c.moveTo(0, h * .25);
        c.lineTo(w * .75, h * .25);
        c.lineTo(w * .75, h);
        c.moveTo(w, 0);
        c.lineTo(w * .75, h * .25);
        c.stroke()
    } else if (type === mxArchiMateApplication.prototype.cst.NETWORK) {
        c.translate(0, 2);
        h = h - 4;
        c.begin();
        c.moveTo(w * .4, h * .2);
        c.lineTo(w * .85, h * .2);
        c.lineTo(w * .6, h * .8);
        c.lineTo(w * .15, h * .8);
        c.close();
        c.stroke();
        var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
        c.setFillColor(strokeColor);
        c.ellipse(w * .25, 0, w * .3, h * .4);
        c.fill();
        c.ellipse(w * .7, 0, w * .3, h * .4);
        c.fill();
        c.ellipse(0, h * .6, w * .3, h * .4);
        c.fill();
        c.ellipse(w * .45, h * .6, w * .3, h * .4);
        c.fill()
    } else if (type === mxArchiMateApplication.prototype.cst.COMM_PATH) {
        c.translate(0, 5);
        h = h - 10;
        c.begin();
        c.moveTo(w * .1, 0);
        c.lineTo(0, h * .5);
        c.lineTo(w * .1, h);
        c.moveTo(w * .9, 0);
        c.lineTo(w, h * .5);
        c.lineTo(w * .9, h);
        c.stroke();
        c.setDashed(true);
        c.begin();
        c.moveTo(0, h * .5);
        c.lineTo(w, h * .5);
        c.stroke()
    } else if (type === mxArchiMateApplication.prototype.cst.SYS_SW) {
        c.ellipse(w * .3, 0, w * .7, h * .7);
        c.stroke();
        c.ellipse(0, h * .02, w * .98, h * .98);
        c.fillAndStroke()
    } else if (type === mxArchiMateApplication.prototype.cst.ARTIFACT) {
        c.translate(2, 0);
        w = w - 4;
        c.begin();
        c.moveTo(0, 0);
        c.lineTo(w * .7, 0);
        c.lineTo(w, h * .22);
        c.lineTo(w, h);
        c.lineTo(0, h);
        c.close();
        c.moveTo(w * .7, 0);
        c.lineTo(w * .7, h * .22);
        c.lineTo(w, h * .22);
        c.stroke()
    } else if (type === mxArchiMateApplication.prototype.cst.ACTOR) {
        c.translate(3, 0);
        w = w - 6;
        c.ellipse(w * .2, 0, w * .6, h * .3);
        c.stroke();
        c.begin();
        c.moveTo(w * .5, h * .3);
        c.lineTo(w * .5, h * .75);
        c.moveTo(0, h * .45);
        c.lineTo(w, h * .45);
        c.moveTo(0, h);
        c.lineTo(w * .5, h * .75);
        c.lineTo(w, h);
        c.stroke()
    }
    if (type === mxArchiMateApplication.prototype.cst.ROLE) {
        c.translate(0, 4);
        h = h - 8;
        c.begin();
        c.moveTo(w * .8, 0);
        c.lineTo(w * .2, 0);
        c.arcTo(w * .2, h * .5, 0, 0, 0, w * .2, h);
        c.lineTo(w * .8, h);
        c.stroke();
        c.ellipse(w * .6, 0, w * .4, h);
        c.stroke()
    }
}
;
mxCellRenderer.registerShape(mxArchiMateApplication.prototype.cst.APPLICATION, mxArchiMateApplication);
function mxArchiMateTech(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMateTech, mxShape);
mxArchiMateTech.prototype.cst = {
    TECH: "mxgraph.archimate.tech",
    TYPE: "techType",
    DEVICE: "device",
    PLATEAU: "plateau"
};
mxArchiMateTech.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false);
    c.translate(w - 30, 15);
    this.foreground(c, w - 30, 15, 15, 15)
}
;
mxArchiMateTech.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(0, 10);
    c.lineTo(10, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h - 10);
    c.lineTo(w - 10, h);
    c.lineTo(0, h);
    c.close();
    c.moveTo(0, 10);
    c.lineTo(w - 10, 10);
    c.lineTo(w - 10, h);
    c.moveTo(w, 0);
    c.lineTo(w - 10, 10);
    c.fillAndStroke()
}
;
mxArchiMateTech.prototype.foreground = function(c, x, y, w, h) {
    var type = mxUtils.getValue(this.style, mxArchiMateTech.prototype.cst.TYPE, mxArchiMateTech.prototype.cst.DEVICE);
    c.setDashed(false);
    if (type === mxArchiMateTech.prototype.cst.DEVICE) {
        c.roundrect(0, 0, w, h * .88, w * .05, h * .05);
        c.stroke();
        c.begin();
        c.moveTo(w * .1, h * .88);
        c.lineTo(0, h);
        c.lineTo(w, h);
        c.lineTo(w * .9, h * .88);
        c.stroke()
    } else if (type === mxArchiMateTech.prototype.cst.PLATEAU) {
        var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
        c.setFillColor(strokeColor);
        c.rect(w * .4, 0, w * .6, h * .2);
        c.fill();
        c.rect(w * .2, h * .4, w * .6, h * .2);
        c.fill();
        c.rect(0, h * .8, w * .6, h * .2);
        c.fill()
    }
}
;
mxCellRenderer.registerShape(mxArchiMateTech.prototype.cst.TECH, mxArchiMateTech);
function mxArchiMateMotivational(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMateMotivational, mxShape);
mxArchiMateMotivational.prototype.cst = {
    MOTIV: "mxgraph.archimate.motiv",
    TYPE: "motivType",
    STAKE: "stake",
    DRIVER: "driver",
    ASSESSMENT: "assess",
    GOAL: "goal",
    REQUIREMENT: "req",
    CONSTRAINT: "const",
    PRINCIPLE: "princ"
};
mxArchiMateMotivational.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false);
    c.translate(w - 20, 5);
    this.foreground(c, w - 20, 5, 15, 15)
}
;
mxArchiMateMotivational.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(10, 0);
    c.lineTo(w - 10, 0);
    c.lineTo(w, 10);
    c.lineTo(w, h - 10);
    c.lineTo(w - 10, h);
    c.lineTo(10, h);
    c.lineTo(0, h - 10);
    c.lineTo(0, 10);
    c.close();
    c.fillAndStroke()
}
;
mxArchiMateMotivational.prototype.foreground = function(c, x, y, w, h) {
    var type = mxUtils.getValue(this.style, mxArchiMateMotivational.prototype.cst.TYPE, mxArchiMateMotivational.prototype.cst.STAKE);
    c.setDashed(false);
    if (type === mxArchiMateMotivational.prototype.cst.STAKE) {
        c.translate(0, 4);
        h = h - 8;
        c.begin();
        c.moveTo(w * .8, 0);
        c.lineTo(w * .2, 0);
        c.arcTo(w * .2, h * .5, 0, 0, 0, w * .2, h);
        c.lineTo(w * .8, h);
        c.stroke();
        c.ellipse(w * .6, 0, w * .4, h);
        c.stroke()
    } else if (type === mxArchiMateMotivational.prototype.cst.DRIVER) {
        c.ellipse(w * .1, h * .1, w * .8, h * .8);
        c.stroke();
        c.begin();
        c.moveTo(0, h * .5);
        c.lineTo(w, h * .5);
        c.moveTo(w * .5, 0);
        c.lineTo(w * .5, h);
        c.moveTo(w * .145, h * .145);
        c.lineTo(w * .855, h * .855);
        c.moveTo(w * .145, h * .855);
        c.lineTo(w * .855, h * .145);
        c.stroke();
        var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
        c.setFillColor(strokeColor);
        c.ellipse(w * .35, h * .35, w * .3, h * .3);
        c.fillAndStroke()
    } else if (type === mxArchiMateMotivational.prototype.cst.ASSESSMENT) {
        c.ellipse(w * .2, 0, w * .8, h * .8);
        c.stroke();
        c.begin();
        c.moveTo(0, h);
        c.lineTo(w * .32, h * .68);
        c.stroke()
    } else if (type === mxArchiMateMotivational.prototype.cst.GOAL) {
        c.ellipse(0, 0, w, h);
        c.stroke();
        c.ellipse(w * .15, h * .15, w * .7, h * .7);
        c.stroke();
        var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
        c.setFillColor(strokeColor);
        c.ellipse(w * .3, h * .3, w * .4, h * .4);
        c.fillAndStroke()
    } else if (type === mxArchiMateMotivational.prototype.cst.REQUIREMENT) {
        c.translate(0, 4);
        h = h - 8;
        c.begin();
        c.moveTo(w * .25, 0);
        c.lineTo(w, 0);
        c.lineTo(w * .75, h);
        c.lineTo(0, h);
        c.close();
        c.stroke()
    } else if (type === mxArchiMateMotivational.prototype.cst.CONSTRAINT) {
        c.translate(0, 4);
        h = h - 8;
        c.begin();
        c.moveTo(w * .25, 0);
        c.lineTo(w, 0);
        c.lineTo(w * .75, h);
        c.lineTo(0, h);
        c.close();
        c.moveTo(w * .45, 0);
        c.lineTo(w * .2, h);
        c.stroke()
    } else if (type === mxArchiMateMotivational.prototype.cst.PRINCIPLE) {
        c.begin();
        c.moveTo(w * .05, h * .05);
        c.arcTo(w * 2.3, h * 2.3, 0, 0, 1, w * .95, h * .05);
        c.arcTo(w * 2.3, h * 2.3, 0, 0, 1, w * .95, h * .95);
        c.arcTo(w * 2.3, h * 2.3, 0, 0, 1, w * .05, h * .95);
        c.arcTo(w * 2.3, h * 2.3, 0, 0, 1, w * .05, h * .05);
        c.close();
        c.stroke();
        var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
        c.setFillColor(strokeColor);
        c.begin();
        c.moveTo(w * .45, h * .7);
        c.lineTo(w * .42, h * .15);
        c.lineTo(w * .58, h * .15);
        c.lineTo(w * .55, h * .7);
        c.close();
        c.fill();
        c.rect(w * .45, h * .75, w * .1, h * .1);
        c.fill()
    }
}
;
mxCellRenderer.registerShape(mxArchiMateMotivational.prototype.cst.MOTIV, mxArchiMateMotivational);
function mxArchiMateGap(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMateGap, mxShape);
mxArchiMateGap.prototype.cst = {
    GAP: "mxgraph.archimate.gap"
};
mxArchiMateGap.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false);
    c.translate(w - 20, 5);
    this.foreground(c, w - 20, 5, 15, 15)
}
;
mxArchiMateGap.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h * .85);
    c.arcTo(w * .35, h * .35, 0, 0, 0, w * .5, h * .85);
    c.arcTo(w * .35, h * .35, 0, 0, 1, 0, h * .85);
    c.close();
    c.fillAndStroke()
}
;
mxArchiMateGap.prototype.foreground = function(c, x, y, w, h) {
    c.setDashed(false);
    c.translate(0, 2);
    h = h - 4;
    c.ellipse(w * .15, 0, w * .7, h);
    c.stroke();
    c.begin();
    c.moveTo(0, h * .35);
    c.lineTo(w, h * .35);
    c.moveTo(0, h * .65);
    c.lineTo(w, h * .65);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxArchiMateGap.prototype.cst.GAP, mxArchiMateGap);
function mxArchiMate3Application(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Application, mxShape);
mxArchiMate3Application.prototype.cst = {
    APPLICATION: "mxgraph.archimate3.application",
    TYPE: "appType",
    COMPONENT: "comp",
    COLLABORATION: "collab",
    INTERFACE: "interface",
    INTERFACE2: "interface2",
    FUNCTION: "func",
    INTERACTION: "interaction",
    SERVICE: "serv",
    EVENT: "event",
    EVENT2: "event2",
    NODE: "node",
    NETWORK: "netw",
    COMM_PATH: "commPath",
    ACTOR: "actor",
    ASSESSMENT: "assess",
    GOAL: "goal",
    OUTCOME: "outcome",
    ROLE: "role",
    PROCESS: "proc",
    DRIVER: "driver",
    PRINCIPLE: "principle",
    REQUIREMENT: "requirement",
    CONSTRAINT: "constraint",
    RESOURCE: "resource",
    CAPABILITY: "capability",
    COURSE: "course",
    MATERIAL: "material",
    DISTRIBUTION: "distribution",
    SYS_SW: "sysSw",
    ARTIFACT: "artifact",
    PATH: "path",
    ARCHI_TYPE: "archiType",
    TYPE_SQUARE: "square",
    TYPE_ROUNDED: "rounded",
    TYPE_OCT: "oct"
};
mxArchiMate3Application.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false);
    c.translate(w - 20, 5);
    this.foreground(c, w - 20, 5, 15, 15)
}
;
mxArchiMate3Application.prototype.background = function(c, x, y, w, h) {
    var archiType = mxUtils.getValue(this.style, mxArchiMate3Application.prototype.cst.ARCHI_TYPE, "square");
    if (archiType === "rounded")
        c.roundrect(0, 0, w, h, 10, 10);
    else if (archiType === "oct" && w >= 20 && h >= 20) {
        c.begin();
        c.moveTo(0, 10);
        c.lineTo(10, 0);
        c.lineTo(w - 10, 0);
        c.lineTo(w, 10);
        c.lineTo(w, h - 10);
        c.lineTo(w - 10, h);
        c.lineTo(10, h);
        c.lineTo(0, h - 10);
        c.close();
        c.fillAndStroke()
    } else
        c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxArchiMate3Application.prototype.foreground = function(c, x, y, w, h) {
    var type = mxUtils.getValue(this.style, mxArchiMate3Application.prototype.cst.TYPE, "");
    c.setDashed(false);
    if (type === mxArchiMate3Application.prototype.cst.COMPONENT) {
        c.translate(1, 0);
        w = w - 2;
        mxArchiMate3Component.prototype.background(c, x, y, w, h)
    } else if (type === mxArchiMate3Application.prototype.cst.COLLABORATION) {
        c.translate(0, 3);
        h = h - 6;
        mxArchiMate3Collaboration.prototype.background(c, x, y, w, h)
    } else if (type === mxArchiMate3Application.prototype.cst.INTERFACE) {
        c.translate(0, 4);
        h = h - 8;
        mxArchiMate3Interface.prototype.background(c, x, y, w, h)
    } else if (type === mxArchiMate3Application.prototype.cst.INTERFACE2) {
        c.translate(0, 1);
        h = h - 2;
        c.begin();
        c.moveTo(0, h * .5);
        c.lineTo(w * .6, h * .5);
        c.moveTo(w, 0);
        c.arcTo(w * .4, h * .5, 0, 0, 0, w, h);
        c.stroke()
    } else if (type === mxArchiMate3Application.prototype.cst.FUNCTION)
        mxArchiMate3Function.prototype.background(c, x, y, w, h);
    else if (type === mxArchiMate3Application.prototype.cst.INTERACTION)
        mxArchiMate3Interaction.prototype.background(c, x, y, w, h);
    else if (type === mxArchiMate3Application.prototype.cst.SERVICE) {
        c.translate(0, 3);
        h = h - 6;
        mxArchiMate3Service.prototype.background(c, x, y, w, h)
    } else if (type === mxArchiMate3Application.prototype.cst.EVENT) {
        c.translate(0, 3);
        h = h - 6;
        mxArchiMate3Event.prototype.background(c, x, y, w, h)
    } else if (type === mxArchiMate3Application.prototype.cst.EVENT2) {
        c.translate(0, 3);
        h = h - 6;
        mxArchiMate3Event2.prototype.background(c, x, y, w, h)
    } else if (type === mxArchiMate3Application.prototype.cst.NODE)
        mxArchiMate3Node.prototype.background(c, x, y, w, h);
    else if (type === mxArchiMate3Application.prototype.cst.NETWORK) {
        c.translate(0, 2);
        h = h - 4;
        c.begin();
        c.moveTo(w * .4, h * .2);
        c.lineTo(w * .85, h * .2);
        c.lineTo(w * .6, h * .8);
        c.lineTo(w * .15, h * .8);
        c.close();
        c.stroke();
        var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
        c.setFillColor(strokeColor);
        c.ellipse(w * .25, 0, w * .3, h * .4);
        c.fill();
        c.ellipse(w * .7, 0, w * .3, h * .4);
        c.fill();
        c.ellipse(0, h * .6, w * .3, h * .4);
        c.fill();
        c.ellipse(w * .45, h * .6, w * .3, h * .4);
        c.fill()
    } else if (type === mxArchiMate3Application.prototype.cst.COMM_PATH) {
        c.translate(0, 5);
        h = h - 10;
        c.begin();
        c.moveTo(w * .1, 0);
        c.lineTo(0, h * .5);
        c.lineTo(w * .1, h);
        c.moveTo(w * .9, 0);
        c.lineTo(w, h * .5);
        c.lineTo(w * .9, h);
        c.stroke();
        c.setDashed(true);
        c.begin();
        c.moveTo(0, h * .5);
        c.lineTo(w, h * .5);
        c.stroke()
    } else if (type === mxArchiMate3Application.prototype.cst.ARTIFACT) {
        c.translate(2, 0);
        w = w - 4;
        c.begin();
        c.moveTo(0, 0);
        c.lineTo(w * .7, 0);
        c.lineTo(w, h * .22);
        c.lineTo(w, h);
        c.lineTo(0, h);
        c.close();
        c.moveTo(w * .7, 0);
        c.lineTo(w * .7, h * .22);
        c.lineTo(w, h * .22);
        c.stroke()
    } else if (type === mxArchiMate3Application.prototype.cst.ACTOR) {
        c.translate(3, 0);
        w = w - 6;
        mxArchiMate3Actor.prototype.background(c, x, y, w, h)
    } else if (type === mxArchiMate3Application.prototype.cst.ROLE) {
        c.translate(0, 4);
        h = h - 8;
        mxArchiMate3Role.prototype.background(c, x, y, w, h)
    } else if (type === mxArchiMate3Application.prototype.cst.PROCESS) {
        c.translate(0, 3);
        h = h - 6;
        mxArchiMate3Process.prototype.background(c, x, y, w, h)
    } else if (type === mxArchiMate3Application.prototype.cst.DRIVER) {
        c.ellipse(w * .1, h * .1, w * .8, h * .8);
        c.stroke();
        c.begin();
        c.moveTo(0, h * .5);
        c.lineTo(w, h * .5);
        c.moveTo(w * .5, 0);
        c.lineTo(w * .5, h);
        c.moveTo(w * .145, h * .145);
        c.lineTo(w * .855, h * .855);
        c.moveTo(w * .145, h * .855);
        c.lineTo(w * .855, h * .145);
        c.stroke();
        var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
        c.setFillColor(strokeColor);
        c.ellipse(w * .35, h * .35, w * .3, h * .3);
        c.fillAndStroke()
    } else if (type === mxArchiMate3Application.prototype.cst.ASSESSMENT) {
        c.ellipse(w * .2, 0, w * .8, h * .8);
        c.stroke();
        c.begin();
        c.moveTo(0, h);
        c.lineTo(w * .32, h * .68);
        c.stroke()
    } else if (type === mxArchiMate3Application.prototype.cst.GOAL) {
        c.ellipse(0, 0, w, h);
        c.stroke();
        c.ellipse(w * .15, h * .15, w * .7, h * .7);
        c.stroke();
        var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
        c.setFillColor(strokeColor);
        c.ellipse(w * .3, h * .3, w * .4, h * .4);
        c.fillAndStroke()
    } else if (type === mxArchiMate3Application.prototype.cst.OUTCOME) {
        c.ellipse(0, w * .2, w * .8, h * .8);
        c.stroke();
        c.ellipse(w * .15, w * .35, w * .5, h * .5);
        c.stroke();
        c.ellipse(w * .3, w * .5, w * .2, h * .2);
        c.stroke();
        c.begin();
        c.moveTo(w * .4, h * .6);
        c.lineTo(w * .9, h * .1);
        c.moveTo(w * .42, h * .4);
        c.lineTo(w * .4, h * .6);
        c.lineTo(w * .6, h * .58);
        c.moveTo(w * .8, 0);
        c.lineTo(w * .75, h * .25);
        c.lineTo(w, h * .2);
        c.stroke()
    } else if (type === mxArchiMate3Application.prototype.cst.PRINCIPLE) {
        c.begin();
        c.moveTo(w * .05, h * .05);
        c.arcTo(w * 2.3, h * 2.3, 0, 0, 1, w * .95, h * .05);
        c.arcTo(w * 2.3, h * 2.3, 0, 0, 1, w * .95, h * .95);
        c.arcTo(w * 2.3, h * 2.3, 0, 0, 1, w * .05, h * .95);
        c.arcTo(w * 2.3, h * 2.3, 0, 0, 1, w * .05, h * .05);
        c.close();
        c.stroke();
        var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
        c.setFillColor(strokeColor);
        c.begin();
        c.moveTo(w * .45, h * .7);
        c.lineTo(w * .42, h * .15);
        c.lineTo(w * .58, h * .15);
        c.lineTo(w * .55, h * .7);
        c.close();
        c.fill();
        c.rect(w * .45, h * .75, w * .1, h * .1);
        c.fill()
    } else if (type === mxArchiMate3Application.prototype.cst.REQUIREMENT) {
        c.translate(0, 4);
        h = h - 8;
        mxArchiMate3Requirement.prototype.background(c, x, y, w, h)
    } else if (type === mxArchiMate3Application.prototype.cst.CONSTRAINT) {
        c.translate(0, 4);
        h = h - 8;
        mxArchiMate3Constraint.prototype.background(c, x, y, w, h)
    } else if (type === mxArchiMate3Application.prototype.cst.MATERIAL) {
        c.translate(0, 1);
        h = h - 2;
        c.begin();
        c.moveTo(0, h * .5);
        c.lineTo(w * .25, 0);
        c.lineTo(w * .75, 0);
        c.lineTo(w, h * .5);
        c.lineTo(w * .75, h);
        c.lineTo(w * .25, h);
        c.close();
        c.moveTo(w * .15, h * .5);
        c.lineTo(w * .31, h * .2);
        c.moveTo(w * .69, h * .2);
        c.lineTo(w * .85, h * .5);
        c.moveTo(w * .68, h * .8);
        c.lineTo(w * .32, h * .8);
        c.stroke()
    } else if (type === mxArchiMate3Application.prototype.cst.DISTRIBUTION) {
        c.translate(0, 4);
        h = h - 8;
        mxArchiMate3Distribution.prototype.background(c, x, y, w, h)
    } else if (type === mxArchiMate3Application.prototype.cst.RESOURCE) {
        c.translate(0, 1);
        h = h - 2;
        mxArchiMate3Resource.prototype.background(c, x, y, w, h)
    } else if (type === mxArchiMate3Application.prototype.cst.CAPABILITY)
        mxArchiMate3Capability.prototype.background(c, x, y, w, h);
    else if (type === mxArchiMate3Application.prototype.cst.COURSE)
        mxArchiMate3Course.prototype.background(c, x, y, w, h);
    else if (type === mxArchiMate3Application.prototype.cst.SYS_SW)
        mxArchiMate3SysSw.prototype.background(c, x, y, w, h);
    else if (type === mxArchiMate3Application.prototype.cst.ARTIFACT) {
        c.translate(2, 0);
        w = w - 4;
        mxArchiMate3Artifact.prototype.background(c, x, y, w, h)
    } else if (type === mxArchiMate3Application.prototype.cst.PATH) {
        c.translate(0, 5);
        h = h - 10;
        mxArchiMate3Path.prototype.background(c, x, y, w, h)
    }
}
;
mxCellRenderer.registerShape(mxArchiMate3Application.prototype.cst.APPLICATION, mxArchiMate3Application);
function mxArchiMate3Component(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Component, mxShape);
mxArchiMate3Component.prototype.cst = {
    COMPONENT: "mxgraph.archimate3.component"
};
mxArchiMate3Component.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false)
}
;
mxArchiMate3Component.prototype.background = function(c, x, y, w, h) {
    c.rect(w * .25, 0, w * .75, h);
    c.fillAndStroke();
    c.rect(0, h * .25, w * .5, h * .15);
    c.fillAndStroke();
    c.rect(0, h * .6, w * .5, h * .15);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxArchiMate3Component.prototype.cst.COMPONENT, mxArchiMate3Component);
function mxArchiMate3Collaboration(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Collaboration, mxShape);
mxArchiMate3Collaboration.prototype.cst = {
    COLLABORATION: "mxgraph.archimate3.collaboration"
};
mxArchiMate3Collaboration.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false)
}
;
mxArchiMate3Collaboration.prototype.background = function(c, x, y, w, h) {
    c.ellipse(0, 0, w * .6, h);
    c.fillAndStroke();
    c.ellipse(w * .4, 0, w * .6, h);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxArchiMate3Collaboration.prototype.cst.COLLABORATION, mxArchiMate3Collaboration);
function mxArchiMate3Interface(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Interface, mxShape);
mxArchiMate3Interface.prototype.cst = {
    INTERFACE: "mxgraph.archimate3.interface"
};
mxArchiMate3Interface.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false)
}
;
mxArchiMate3Interface.prototype.background = function(c, x, y, w, h) {
    c.ellipse(w * .5, 0, w * .5, h);
    c.fillAndStroke();
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(w * .5, h * .5);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxArchiMate3Interface.prototype.cst.INTERFACE, mxArchiMate3Interface);
function mxArchiMate3Process(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Process, mxShape);
mxArchiMate3Process.prototype.cst = {
    PROCESS: "mxgraph.archimate3.process"
};
mxArchiMate3Process.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false)
}
;
mxArchiMate3Process.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(0, h * .3);
    c.lineTo(w * .6, h * .3);
    c.lineTo(w * .6, 0);
    c.lineTo(w, h * .5);
    c.lineTo(w * .6, h);
    c.lineTo(w * .6, h * .7);
    c.lineTo(0, h * .7);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxArchiMate3Process.prototype.cst.PROCESS, mxArchiMate3Process);
function mxArchiMate3Function(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Function, mxShape);
mxArchiMate3Function.prototype.cst = {
    FUNCTION: "mxgraph.archimate3.function"
};
mxArchiMate3Function.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false)
}
;
mxArchiMate3Function.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(w * .5, 0);
    c.lineTo(w, h * .2);
    c.lineTo(w, h);
    c.lineTo(w * .5, h * .8);
    c.lineTo(0, h);
    c.lineTo(0, h * .2);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxArchiMate3Function.prototype.cst.FUNCTION, mxArchiMate3Function);
function mxArchiMate3Interaction(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Interaction, mxShape);
mxArchiMate3Interaction.prototype.cst = {
    INTERACTION: "mxgraph.archimate3.interaction"
};
mxArchiMate3Interaction.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false)
}
;
mxArchiMate3Interaction.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(w * .55, 0);
    c.arcTo(w * .45, h * .5, 0, 0, 1, w * .55, h);
    c.close();
    c.moveTo(w * .45, 0);
    c.arcTo(w * .45, h * .5, 0, 0, 0, w * .45, h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxArchiMate3Interaction.prototype.cst.INTERACTION, mxArchiMate3Interaction);
function mxArchiMate3Service(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Service, mxShape);
mxArchiMate3Service.prototype.cst = {
    SERVICE: "mxgraph.archimate3.service"
};
mxArchiMate3Service.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false)
}
;
mxArchiMate3Service.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(w - h * .5, 0);
    c.arcTo(h * .5, h * .5, 0, 0, 1, w - h * .5, h);
    c.lineTo(h * .5, h);
    c.arcTo(h * .5, h * .5, 0, 0, 1, h * .5, 0);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxArchiMate3Service.prototype.cst.SERVICE, mxArchiMate3Service);
function mxArchiMate3Requirement(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Requirement, mxShape);
mxArchiMate3Requirement.prototype.cst = {
    REQUIREMENT: "mxgraph.archimate3.requirement"
};
mxArchiMate3Requirement.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false)
}
;
mxArchiMate3Requirement.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(w * .25, 0);
    c.lineTo(w, 0);
    c.lineTo(w * .75, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxArchiMate3Requirement.prototype.cst.REQUIREMENT, mxArchiMate3Requirement);
function mxArchiMate3Constraint(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Constraint, mxShape);
mxArchiMate3Constraint.prototype.cst = {
    CONSTRAINT: "mxgraph.archimate3.constraint"
};
mxArchiMate3Constraint.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false)
}
;
mxArchiMate3Constraint.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(w * .25, 0);
    c.lineTo(w, 0);
    c.lineTo(w * .75, h);
    c.lineTo(0, h);
    c.close();
    c.moveTo(w * .45, 0);
    c.lineTo(w * .2, h);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxArchiMate3Constraint.prototype.cst.CONSTRAINT, mxArchiMate3Constraint);
function mxArchiMate3Event(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Event, mxShape);
mxArchiMate3Event.prototype.cst = {
    EVENT: "mxgraph.archimate3.event"
};
mxArchiMate3Event.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false)
}
;
mxArchiMate3Event.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(w - h * .5, 0);
    c.arcTo(h * .5, h * .5, 0, 0, 1, w - h * .5, h);
    c.lineTo(0, h);
    c.lineTo(h * .5, h * .5);
    c.lineTo(0, 0);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxArchiMate3Event.prototype.cst.EVENT, mxArchiMate3Event);
function mxArchiMate3Event2(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Event2, mxShape);
mxArchiMate3Event2.prototype.cst = {
    EVENT2: "mxgraph.archimate3.event2"
};
mxArchiMate3Event2.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false)
}
;
mxArchiMate3Event2.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(w - h * .5, 0);
    c.arcTo(h * .5, h * .5, 0, 0, 1, w - h * .5, h);
    c.lineTo(0, h);
    c.arcTo(h * .5, h * .5, 0, 0, 0, 0, 0);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxArchiMate3Event2.prototype.cst.EVENT2, mxArchiMate3Event2);
function mxArchiMate3Actor(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Actor, mxShape);
mxArchiMate3Actor.prototype.cst = {
    ACTOR: "mxgraph.archimate3.actor"
};
mxArchiMate3Actor.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false)
}
;
mxArchiMate3Actor.prototype.background = function(c, x, y, w, h) {
    c.ellipse(w * .2, 0, w * .6, h * .3);
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .5, h * .3);
    c.lineTo(w * .5, h * .75);
    c.moveTo(0, h * .45);
    c.lineTo(w, h * .45);
    c.moveTo(0, h);
    c.lineTo(w * .5, h * .75);
    c.lineTo(w, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxArchiMate3Actor.prototype.cst.ACTOR, mxArchiMate3Actor);
function mxArchiMate3Role(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Role, mxShape);
mxArchiMate3Role.prototype.cst = {
    ROLE: "mxgraph.archimate3.role"
};
mxArchiMate3Role.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false)
}
;
mxArchiMate3Role.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(w * .8, 0);
    c.lineTo(w * .2, 0);
    c.arcTo(w * .2, h * .5, 0, 0, 0, w * .2, h);
    c.lineTo(w * .8, h);
    c.fillAndStroke();
    c.ellipse(w * .6, 0, w * .4, h);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxArchiMate3Role.prototype.cst.ROLE, mxArchiMate3Role);
function mxArchiMate3BusinessObject(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3BusinessObject, mxShape);
mxArchiMate3BusinessObject.prototype.cst = {
    BUSINESS_OBJECT: "mxgraph.archimate3.businessObject"
};
mxArchiMate3BusinessObject.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h)
}
;
mxArchiMate3BusinessObject.prototype.background = function(c, x, y, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxArchiMate3BusinessObject.prototype.foreground = function(c, x, y, w, h) {
    if (h >= 15) {
        c.begin();
        c.moveTo(0, 15);
        c.lineTo(w, 15);
        c.stroke()
    }
}
;
mxCellRenderer.registerShape(mxArchiMate3BusinessObject.prototype.cst.BUSINESS_OBJECT, mxArchiMate3BusinessObject);
function mxArchiMate3Contract(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Contract, mxShape);
mxArchiMate3Contract.prototype.cst = {
    CONTRACT: "mxgraph.archimate3.contract"
};
mxArchiMate3Contract.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h)
}
;
mxArchiMate3Contract.prototype.background = function(c, x, y, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxArchiMate3Contract.prototype.foreground = function(c, x, y, w, h) {
    if (h >= 15) {
        c.begin();
        c.moveTo(0, 15);
        c.lineTo(w, 15);
        c.stroke()
    }
    if (h >= 30) {
        c.begin();
        c.moveTo(0, h - 15);
        c.lineTo(w, h - 15);
        c.stroke()
    }
}
;
mxCellRenderer.registerShape(mxArchiMate3Contract.prototype.cst.CONTRACT, mxArchiMate3Contract);
function mxArchiMate3Product(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Product, mxShape);
mxArchiMate3Product.prototype.cst = {
    PRODUCT: "mxgraph.archimate3.product"
};
mxArchiMate3Product.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h)
}
;
mxArchiMate3Product.prototype.background = function(c, x, y, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxArchiMate3Product.prototype.foreground = function(c, x, y, w, h) {
    if (h >= 15) {
        c.begin();
        c.moveTo(0, 15);
        c.lineTo(w * .6, 15);
        c.lineTo(w * .6, 0);
        c.stroke()
    }
}
;
mxCellRenderer.registerShape(mxArchiMate3Product.prototype.cst.PRODUCT, mxArchiMate3Product);
function mxArchiMate3Representation(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Representation, mxShape);
mxArchiMate3Representation.prototype.cst = {
    REPRESENTATION: "mxgraph.archimate3.representation"
};
mxArchiMate3Representation.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h)
}
;
mxArchiMate3Representation.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h * .85);
    c.arcTo(w * .35, h * .35, 0, 0, 0, w * .5, h * .85);
    c.arcTo(w * .35, h * .35, 0, 0, 1, 0, h * .85);
    c.close();
    c.fillAndStroke();
    if (h >= 20)
        c.begin();
    c.moveTo(0, 15);
    c.lineTo(w, 15);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxArchiMate3Representation.prototype.cst.REPRESENTATION, mxArchiMate3Representation);
function mxArchiMate3Deliverable(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Deliverable, mxShape);
mxArchiMate3Deliverable.prototype.cst = {
    DELIVERABLE: "mxgraph.archimate3.deliverable"
};
mxArchiMate3Deliverable.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h)
}
;
mxArchiMate3Deliverable.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h * .85);
    c.arcTo(w * .35, h * .35, 0, 0, 0, w * .5, h * .85);
    c.arcTo(w * .35, h * .35, 0, 0, 1, 0, h * .85);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxArchiMate3Deliverable.prototype.cst.DELIVERABLE, mxArchiMate3Deliverable);
function mxArchiMate3Location(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Location, mxShape);
mxArchiMate3Location.prototype.cst = {
    LOCATION: "mxgraph.archimate3.location"
};
mxArchiMate3Location.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false);
    c.translate(w - 20, 5);
    this.foreground(c, w - 20, 5, 15, 15)
}
;
mxArchiMate3Location.prototype.background = function(c, x, y, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxArchiMate3Location.prototype.foreground = function(c, x, y, w, h) {
    c.setDashed(false);
    c.translate(3, 0);
    w = w - 6;
    c.begin();
    c.moveTo(w * .5, h);
    c.arcTo(w * .1775, h * .3, 0, 0, 0, w * .345, h * .7);
    c.arcTo(w * .538, h * .364, 0, 0, 1, w * .5, 0);
    c.arcTo(w * .538, h * .364, 0, 0, 1, w * .655, h * .7);
    c.arcTo(w * .1775, h * .3, 0, 0, 0, w * .5, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxArchiMate3Location.prototype.cst.LOCATION, mxArchiMate3Location);
function mxArchiMate3Gap(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Gap, mxShape);
mxArchiMate3Gap.prototype.cst = {
    GAP: "mxgraph.archimate3.gap"
};
mxArchiMate3Gap.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false);
    c.translate(w - 20, 5);
    this.foreground(c, w - 20, 5, 15, 15)
}
;
mxArchiMate3Gap.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h * .85);
    c.arcTo(w * .35, h * .35, 0, 0, 0, w * .5, h * .85);
    c.arcTo(w * .35, h * .35, 0, 0, 1, 0, h * .85);
    c.close();
    c.fillAndStroke()
}
;
mxArchiMate3Gap.prototype.foreground = function(c, x, y, w, h) {
    c.setDashed(false);
    c.translate(0, 2);
    h = h - 4;
    c.ellipse(w * .15, 0, w * .7, h);
    c.stroke();
    c.begin();
    c.moveTo(0, h * .35);
    c.lineTo(w, h * .35);
    c.moveTo(0, h * .65);
    c.lineTo(w, h * .65);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxArchiMate3Gap.prototype.cst.GAP, mxArchiMate3Gap);
function mxArchiMate3Tech(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Tech, mxShape);
mxArchiMate3Tech.prototype.cst = {
    TECH: "mxgraph.archimate3.tech",
    TYPE: "techType",
    DEVICE: "device",
    PLATEAU: "plateau",
    FACILITY: "facility",
    EQUIPMENT: "equipment",
    SYS_SW: "sysSw"
};
mxArchiMate3Tech.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false);
    c.translate(w - 30, 15);
    this.foreground(c, w - 30, 15, 15, 15)
}
;
mxArchiMate3Tech.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(0, 10);
    c.lineTo(10, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h - 10);
    c.lineTo(w - 10, h);
    c.lineTo(0, h);
    c.close();
    c.moveTo(0, 10);
    c.lineTo(w - 10, 10);
    c.lineTo(w - 10, h);
    c.moveTo(w, 0);
    c.lineTo(w - 10, 10);
    c.fillAndStroke()
}
;
mxArchiMate3Tech.prototype.foreground = function(c, x, y, w, h) {
    var type = mxUtils.getValue(this.style, mxArchiMate3Tech.prototype.cst.TYPE, mxArchiMate3Tech.prototype.cst.DEVICE);
    c.setDashed(false);
    if (type === mxArchiMate3Tech.prototype.cst.PLATEAU) {
        var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
        c.setFillColor(strokeColor);
        c.rect(w * .4, 0, w * .6, h * .2);
        c.fill();
        c.rect(w * .2, h * .4, w * .6, h * .2);
        c.fill();
        c.rect(0, h * .8, w * .6, h * .2);
        c.fill()
    } else if (type === mxArchiMate3Tech.prototype.cst.FACILITY) {
        c.begin();
        c.moveTo(0, h);
        c.lineTo(0, 0);
        c.lineTo(w * .13, 0);
        c.lineTo(w * .13, h * .7);
        c.lineTo(w * .42, h * .55);
        c.lineTo(w * .42, h * .7);
        c.lineTo(w * .71, h * .55);
        c.lineTo(w * .71, h * .7);
        c.lineTo(w, h * .55);
        c.lineTo(w, h);
        c.close();
        c.stroke()
    } else if (type === mxArchiMate3Tech.prototype.cst.EQUIPMENT) {
        c.begin();
        c.moveTo(w * .72, h * .38);
        c.curveTo(w * .78, w * .38, w * .85, h * .34, w * .85, h * .26);
        c.curveTo(w * .85, w * .18, w * .78, h * .14, w * .73, h * .14);
        c.curveTo(w * .64, w * .14, w * .59, h * .2, w * .59, h * .26);
        c.curveTo(w * .59, h * .33, w * .65, w * .38, w * .72, h * .38);
        c.close();
        c.moveTo(w * .68, h * .52);
        c.lineTo(w * .67, h * .45);
        c.lineTo(w * .61, h * .43);
        c.lineTo(w * .56, h * .48);
        c.lineTo(w * .5, h * .42);
        c.lineTo(w * .54, h * .36);
        c.lineTo(w * .52, h * .31);
        c.lineTo(w * .45, h * .31);
        c.lineTo(w * .45, h * .22);
        c.lineTo(w * .52, h * .21);
        c.lineTo(w * .54, h * .16);
        c.lineTo(w * .5, h * .11);
        c.lineTo(w * .56, h * .05);
        c.lineTo(w * .62, h * .09);
        c.lineTo(w * .67, h * .07);
        c.lineTo(w * .68, 0);
        c.lineTo(w * .77, 0);
        c.lineTo(w * .78, h * .07);
        c.lineTo(w * .83, h * .09);
        c.lineTo(w * .89, h * .05);
        c.lineTo(w * .95, h * .11);
        c.lineTo(w * .91, h * .16);
        c.lineTo(w * .93, h * .21);
        c.lineTo(w, h * .22);
        c.lineTo(w, h * .31);
        c.lineTo(w * .93, h * .31);
        c.lineTo(w * .91, h * .36);
        c.lineTo(w * .95, h * .41);
        c.lineTo(w * .89, h * .47);
        c.lineTo(w * .83, h * .43);
        c.lineTo(w * .78, h * .45);
        c.lineTo(w * .77, h * .52);
        c.lineTo(w * .68, h * .52);
        c.close();
        c.moveTo(w * .36, h * .81);
        c.curveTo(w * .44, h * .81, w * .52, h * .75, w * .52, h * .67);
        c.curveTo(w * .52, h * .59, w * .45, h * .51, w * .35, h * .51);
        c.curveTo(w * .27, h * .51, w * .19, h * .58, w * .19, h * .67);
        c.curveTo(w * .19, h * .74, w * .27, h * .82, w * .36, h * .81);
        c.close();
        c.moveTo(w * .21, h * .98);
        c.lineTo(w * .22, h * .89);
        c.lineTo(w * .16, h * .85);
        c.lineTo(w * .08, h * .88);
        c.lineTo(w * .02, h * .79);
        c.lineTo(w * .09, h * .74);
        c.lineTo(w * .08, h * .67);
        c.lineTo(0, h * .63);
        c.lineTo(w * .03, h * .53);
        c.lineTo(w * .12, h * .54);
        c.lineTo(w * .16, h * .48);
        c.lineTo(w * .13, h * .4);
        c.lineTo(w * .22, h * .35);
        c.lineTo(w * .28, h * .42);
        c.lineTo(w * .36, h * .41);
        c.lineTo(w * .39, h * .33);
        c.lineTo(w * .5, h * .36);
        c.lineTo(w * .49, h * .45);
        c.lineTo(w * .55, h * .49);
        c.lineTo(w * .63, h * .45);
        c.lineTo(w * .69, h * .54);
        c.lineTo(w * .62, h * .6);
        c.lineTo(w * .63, h * .67);
        c.lineTo(w * .71, h * .7);
        c.lineTo(w * .68, h * .8);
        c.lineTo(w * .59, h * .79);
        c.lineTo(w * .55, h * .85);
        c.lineTo(w * .59, h * .79);
        c.lineTo(w * .55, h * .85);
        c.lineTo(w * .59, h * .93);
        c.lineTo(w * .49, h * .98);
        c.lineTo(w * .43, h * .91);
        c.lineTo(w * .36, h * .92);
        c.lineTo(w * .32, h);
        c.lineTo(w * .21, h * .98);
        c.close();
        c.stroke()
    } else if (type === mxArchiMate3Tech.prototype.cst.SYS_SW)
        mxArchiMate3SysSw.prototype.background(c, x, y, w, h);
    else if (type === mxArchiMate3Tech.prototype.cst.DEVICE)
        mxArchiMate3Device.prototype.background(c, x, y, w, h)
}
;
mxCellRenderer.registerShape(mxArchiMate3Tech.prototype.cst.TECH, mxArchiMate3Tech);
function mxArchiMate3Distribution(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Distribution, mxShape);
mxArchiMate3Distribution.prototype.cst = {
    DISTRIBUTION: "mxgraph.archimate3.distribution"
};
mxArchiMate3Distribution.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false)
}
;
mxArchiMate3Distribution.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(w * .1, h * .25);
    c.lineTo(w * .9, h * .25);
    c.lineTo(w, h * .5);
    c.lineTo(w * .9, h * .75);
    c.lineTo(w * .1, h * .75);
    c.lineTo(0, h * .5);
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .2, 0);
    c.lineTo(0, h * .5);
    c.lineTo(w * .2, h);
    c.moveTo(w * .8, 0);
    c.lineTo(w, h * .5);
    c.lineTo(w * .8, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxArchiMate3Distribution.prototype.cst.DISTRIBUTION, mxArchiMate3Distribution);
function mxArchiMate3Resource(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Resource, mxShape);
mxArchiMate3Resource.prototype.cst = {
    RESOURCE: "mxgraph.archimate3.resource"
};
mxArchiMate3Resource.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false)
}
;
mxArchiMate3Resource.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(w * .51, h * .34);
    c.lineTo(w * .51, h * .65);
    c.moveTo(w * .35, h * .34);
    c.lineTo(w * .35, h * .65);
    c.moveTo(w * .19, h * .34);
    c.lineTo(w * .19, h * .65);
    c.moveTo(w * .91, h * .4);
    c.curveTo(w * .93, h * .39, w * .95, h * .39, w * .97, h * .4);
    c.curveTo(w * .99, h * .4, w, h * .41, w, h * .43);
    c.curveTo(w, h * .48, w, h * .52, w, h * .57);
    c.curveTo(w, h * .58, w * .99, h * .59, w * .98, h * .6);
    c.curveTo(w * .96, h * .6, w * .93, h * .6, w * .91, h * .6);
    c.moveTo(0, h * .73);
    c.curveTo(0, h * .6, 0, h * .43, 0, h * .27);
    c.curveTo(0, h * .24, w * .03, h * .21, w * .08, h * .21);
    c.curveTo(w * .33, h * .2, w * .61, h * .2, w * .84, h * .21);
    c.curveTo(w * .88, h * .22, w * .89, h * .24, w * .9, h * .26);
    c.curveTo(w * .91, h * .41, w * .91, h * .57, w * .9, h * .72);
    c.curveTo(w * .9, h * .74, w * .88, h * .78, w * .83, h * .79);
    c.curveTo(w * .57, h * .79, w * .32, h * .79, w * .06, h * .79);
    c.curveTo(w * .02, h * .78, 0, h * .76, 0, h * .73);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxArchiMate3Resource.prototype.cst.RESOURCE, mxArchiMate3Resource);
function mxArchiMate3Capability(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Capability, mxShape);
mxArchiMate3Capability.prototype.cst = {
    CAPABILITY: "mxgraph.archimate3.capability"
};
mxArchiMate3Capability.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false)
}
;
mxArchiMate3Capability.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.lineTo(0, h * .67);
    c.lineTo(w * .33, h * .67);
    c.lineTo(w * .33, h * .33);
    c.lineTo(w * .67, h * .33);
    c.lineTo(w * .67, 0);
    c.close();
    c.moveTo(w * .67, h * .33);
    c.lineTo(w, h * .33);
    c.moveTo(w * .33, h * .67);
    c.lineTo(w, h * .67);
    c.moveTo(w * .33, h * .67);
    c.lineTo(w * .33, h);
    c.moveTo(w * .67, h * .33);
    c.lineTo(w * .67, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxArchiMate3Capability.prototype.cst.CAPABILITY, mxArchiMate3Capability);
function mxArchiMate3Course(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Course, mxShape);
mxArchiMate3Course.prototype.cst = {
    COURSE: "mxgraph.archimate3.course"
};
mxArchiMate3Course.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false)
}
;
mxArchiMate3Course.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(0, h);
    c.arcTo(w * .7, h * .7, 0, 0, 1, w * .41, h * .56);
    c.moveTo(w * .14, h * .54);
    c.lineTo(w * .41, h * .56);
    c.lineTo(w * .3, h * .78);
    c.stroke();
    c.ellipse(w * .4, 0, w * .6, h * .6);
    c.stroke();
    c.ellipse(w * .5, h * .1, w * .4, h * .4);
    c.stroke();
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#000000");
    c.setFillColor(fillColor);
    c.ellipse(w * .6, h * .2, w * .2, h * .2);
    c.fill()
}
;
mxCellRenderer.registerShape(mxArchiMate3Course.prototype.cst.COURSE, mxArchiMate3Course);
function mxArchiMate3Node(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Node, mxShape);
mxArchiMate3Node.prototype.cst = {
    NODE: "mxgraph.archimate3.node"
};
mxArchiMate3Node.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false)
}
;
mxArchiMate3Node.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(0, h * .25);
    c.lineTo(w * .25, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h * .75);
    c.lineTo(w * .75, h);
    c.lineTo(0, h);
    c.close();
    c.moveTo(0, h * .25);
    c.lineTo(w * .75, h * .25);
    c.lineTo(w * .75, h);
    c.moveTo(w, 0);
    c.lineTo(w * .75, h * .25);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxArchiMate3Node.prototype.cst.NODE, mxArchiMate3Node);
function mxArchiMate3Device(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Device, mxShape);
mxArchiMate3Device.prototype.cst = {
    DEVICE: "mxgraph.archimate3.device"
};
mxArchiMate3Device.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false)
}
;
mxArchiMate3Device.prototype.background = function(c, x, y, w, h) {
    c.roundrect(0, 0, w, h * .88, w * .1, h * .1);
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .1, h * .88);
    c.lineTo(0, h);
    c.lineTo(w, h);
    c.lineTo(w * .9, h * .88);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxArchiMate3Device.prototype.cst.DEVICE, mxArchiMate3Device);
function mxArchiMate3SysSw(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3SysSw, mxShape);
mxArchiMate3SysSw.prototype.cst = {
    SYS_SW: "mxgraph.archimate3.sysSw"
};
mxArchiMate3SysSw.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false)
}
;
mxArchiMate3SysSw.prototype.background = function(c, x, y, w, h) {
    c.ellipse(w * .3, 0, w * .7, h * .7);
    c.stroke();
    c.ellipse(0, h * .02, w * .98, h * .98);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxArchiMate3SysSw.prototype.cst.SYS_SW, mxArchiMate3SysSw);
function mxArchiMate3Artifact(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Artifact, mxShape);
mxArchiMate3Artifact.prototype.cst = {
    ARTIFACT: "mxgraph.archimate3.artifact"
};
mxArchiMate3Artifact.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false)
}
;
mxArchiMate3Artifact.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w * .7, 0);
    c.lineTo(w, h * .22);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .7, 0);
    c.lineTo(w * .7, h * .22);
    c.lineTo(w, h * .22);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxArchiMate3Artifact.prototype.cst.ARTIFACT, mxArchiMate3Artifact);
function mxArchiMate3CommNetw(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3CommNetw, mxShape);
mxArchiMate3CommNetw.prototype.cst = {
    COMM_NETW: "mxgraph.archimate3.commNetw"
};
mxArchiMate3CommNetw.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false)
}
;
mxArchiMate3CommNetw.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(w * .2, h);
    c.lineTo(0, h * .5);
    c.lineTo(w * .2, 0);
    c.moveTo(w * .8, h);
    c.lineTo(w, h * .5);
    c.lineTo(w * .8, 0);
    c.moveTo(0, h * .5);
    c.lineTo(w, h * .5);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxArchiMate3CommNetw.prototype.cst.COMM_NETW, mxArchiMate3CommNetw);
function mxArchiMate3Path(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxArchiMate3Path, mxShape);
mxArchiMate3Path.prototype.cst = {
    PATH: "mxgraph.archimate3.path"
};
mxArchiMate3Path.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false)
}
;
mxArchiMate3Path.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(w * .2, h);
    c.lineTo(0, h * .5);
    c.lineTo(w * .2, 0);
    c.moveTo(w * .8, h);
    c.lineTo(w, h * .5);
    c.lineTo(w * .8, 0);
    c.stroke();
    c.setDashed(true);
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(w, h * .5);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxArchiMate3Path.prototype.cst.PATH, mxArchiMate3Path);
function mxShapeArrows2Arrow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy = .5;
    this.dx = .5;
    this.notch = 0
}
mxUtils.extend(mxShapeArrows2Arrow, mxActor);
mxShapeArrows2Arrow.prototype.cst = {
    ARROW: "mxgraph.arrows2.arrow"
};
mxShapeArrows2Arrow.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dy = h * .5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "notch", this.notch))));
    c.begin();
    c.moveTo(0, dy);
    c.lineTo(w - dx, dy);
    c.lineTo(w - dx, 0);
    c.lineTo(w, h * .5);
    c.lineTo(w - dx, h);
    c.lineTo(w - dx, h - dy);
    c.lineTo(0, h - dy);
    c.lineTo(notch, h * .5);
    c.close();
    c.fillAndStroke()
}
;
mxShapeArrows2Arrow.prototype.getLabelBounds = function(rect) {
    if (mxUtils.getValue(this.style, "boundedLbl", false)) {
        var w = rect.width;
        var h = rect.height;
        var dy, dx;
        var direction = this.direction || mxConstants.DIRECTION_EAST;
        if (mxUtils.getValue(this.style, "flipH", false))
            if (direction == mxConstants.DIRECTION_WEST)
                direction = mxConstants.DIRECTION_EAST;
            else if (direction == mxConstants.DIRECTION_EAST)
                direction = mxConstants.DIRECTION_WEST;
        if (mxUtils.getValue(this.style, "flipV", false))
            if (direction == mxConstants.DIRECTION_NORTH)
                direction = mxConstants.DIRECTION_SOUTH;
            else if (direction == mxConstants.DIRECTION_SOUTH)
                direction = mxConstants.DIRECTION_NORTH;
        if (direction == mxConstants.DIRECTION_NORTH || direction == mxConstants.DIRECTION_SOUTH) {
            dy = w * .5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
            dx = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))))
        } else {
            dy = h * .5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
            dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))))
        }
        if (direction == mxConstants.DIRECTION_EAST)
            return new mxRectangle(rect.x,rect.y + dy,w - dx,h - 2 * dy);
        else if (direction == mxConstants.DIRECTION_WEST)
            return new mxRectangle(rect.x + dx,rect.y + dy,w - dx,h - 2 * dy);
        else if (direction == mxConstants.DIRECTION_NORTH)
            return new mxRectangle(rect.x + dy,rect.y + dx,w - 2 * dy,h - dx);
        else
            return new mxRectangle(rect.x + dy,rect.y,w - 2 * dy,h - dx)
    }
    return rect
}
;
mxCellRenderer.registerShape(mxShapeArrows2Arrow.prototype.cst.ARROW, mxShapeArrows2Arrow);
mxShapeArrows2Arrow.prototype.constraints = null;
Graph.handleFactory[mxShapeArrows2Arrow.prototype.cst.ARROW] = function(state) {
    var handles = [Graph.createHandle(state, ["dx", "dy"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + bounds.width - dx,bounds.y + dy * bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch)), bounds.x + bounds.width - pt.x))) / 100;
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height * 2))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["notch"], function(bounds) {
        var notch = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch))));
        return new mxPoint(bounds.x + notch,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["notch"] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx)), pt.x - bounds.x))) / 100
    });
    handles.push(handle2);
    return handles
}
;
function mxShapeArrows2TwoWayArrow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy = .5;
    this.dx = .5
}
mxUtils.extend(mxShapeArrows2TwoWayArrow, mxActor);
mxShapeArrows2TwoWayArrow.prototype.cst = {
    TWO_WAY_ARROW: "mxgraph.arrows2.twoWayArrow"
};
mxShapeArrows2TwoWayArrow.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dy = h * .5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    c.begin();
    c.moveTo(dx, dy);
    c.lineTo(w - dx, dy);
    c.lineTo(w - dx, 0);
    c.lineTo(w, h * .5);
    c.lineTo(w - dx, h);
    c.lineTo(w - dx, h - dy);
    c.lineTo(dx, h - dy);
    c.lineTo(dx, h);
    c.lineTo(0, h * .5);
    c.lineTo(dx, 0);
    c.close();
    c.fillAndStroke()
}
;
mxShapeArrows2TwoWayArrow.prototype.getLabelBounds = function(rect) {
    if (mxUtils.getValue(this.style, "boundedLbl", false)) {
        var w = rect.width;
        var h = rect.height;
        var vertical = this.direction == mxConstants.DIRECTION_NORTH || this.direction == mxConstants.DIRECTION_SOUTH;
        var dy, dx;
        if (vertical) {
            dy = w * .5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
            dx = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))))
        } else {
            dy = h * .5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
            dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))))
        }
        if (vertical)
            return new mxRectangle(rect.x + dy,rect.y + dx,w - 2 * dy,h - 2 * dx);
        else
            return new mxRectangle(rect.x + dx,rect.y + dy,w - 2 * dx,h - 2 * dy)
    }
    return rect
}
;
mxCellRenderer.registerShape(mxShapeArrows2TwoWayArrow.prototype.cst.TWO_WAY_ARROW, mxShapeArrows2TwoWayArrow);
mxShapeArrows2TwoWayArrow.prototype.constraints = null;
Graph.handleFactory[mxShapeArrows2TwoWayArrow.prototype.cst.TWO_WAY_ARROW] = function(state) {
    var handles = [Graph.createHandle(state, ["dx", "dy"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width / 2, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + bounds.width - dx,bounds.y + dy * bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.width / 2, bounds.x + bounds.width - pt.x))) / 100;
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height * 2))) / 100
    })];
    return handles
}
;
function mxShapeArrows2StylisedArrow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy = .5;
    this.dx = .5;
    this.notch = 0;
    this.feather = .5
}
mxUtils.extend(mxShapeArrows2StylisedArrow, mxActor);
mxShapeArrows2StylisedArrow.prototype.cst = {
    STYLISED_ARROW: "mxgraph.arrows2.stylisedArrow"
};
mxShapeArrows2StylisedArrow.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dy = h * .5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "notch", this.notch))));
    var feather = h * .5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "feather", this.feather))));
    c.begin();
    c.moveTo(0, feather);
    c.lineTo(w - dx, dy);
    c.lineTo(w - dx - 10, 0);
    c.lineTo(w, h * .5);
    c.lineTo(w - dx - 10, h);
    c.lineTo(w - dx, h - dy);
    c.lineTo(0, h - feather);
    c.lineTo(notch, h * .5);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeArrows2StylisedArrow.prototype.cst.STYLISED_ARROW, mxShapeArrows2StylisedArrow);
mxShapeArrows2StylisedArrow.prototype.constraints = null;
Graph.handleFactory[mxShapeArrows2StylisedArrow.prototype.cst.STYLISED_ARROW] = function(state) {
    var handles = [Graph.createHandle(state, ["dx", "dy"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width - 10, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + bounds.width - dx,bounds.y + dy * bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.width - 10, bounds.width - parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch)), bounds.x + bounds.width - pt.x))) / 100;
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height * 2))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["notch"], function(bounds) {
        var notch = Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx)), parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch))));
        return new mxPoint(bounds.x + notch,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["notch"] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx)), pt.x - bounds.x))) / 100
    });
    handles.push(handle2);
    var handle3 = Graph.createHandle(state, ["feather"], function(bounds) {
        var feather = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "feather", this.dy))));
        return new mxPoint(bounds.x,bounds.y + feather * bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["feather"] = Math.round(100 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height * 2))) / 100
    });
    handles.push(handle3);
    return handles
}
;
function mxShapeArrows2SharpArrow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy1 = .5;
    this.dx1 = .5;
    this.dx2 = .5;
    this.notch = 0
}
mxUtils.extend(mxShapeArrows2SharpArrow, mxActor);
mxShapeArrows2SharpArrow.prototype.cst = {
    SHARP_ARROW: "mxgraph.arrows2.sharpArrow"
};
mxShapeArrows2SharpArrow.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dy1 = h * .5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "dy1", this.dy1))));
    var dx1 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx1", this.dx1))));
    var dx2 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx2", this.dx2))));
    var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "notch", this.notch))));
    var dx1a = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx1", this.dx1))));
    var dy1a = h * .5 * Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dy1", this.dy1))));
    var x2 = 0;
    if (h != 0)
        x2 = dx1a + dx2 * dy1a * 2 / h;
    c.begin();
    c.moveTo(0, dy1);
    c.lineTo(w - dx1, dy1);
    c.lineTo(w - x2, 0);
    c.lineTo(w - dx2, 0);
    c.lineTo(w, h * .5);
    c.lineTo(w - dx2, h);
    c.lineTo(w - x2, h);
    c.lineTo(w - dx1, h - dy1);
    c.lineTo(0, h - dy1);
    c.lineTo(notch, h * .5);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeArrows2SharpArrow.prototype.cst.SHARP_ARROW, mxShapeArrows2SharpArrow);
mxShapeArrows2SharpArrow.prototype.constraints = null;
Graph.handleFactory[mxShapeArrows2SharpArrow.prototype.cst.SHARP_ARROW] = function(state) {
    var handles = [Graph.createHandle(state, ["dx1", "dy1"], function(bounds) {
        var dx1 = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx1", this.dx1))));
        var dy1 = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "dy1", this.dy1))));
        return new mxPoint(bounds.x + bounds.width - dx1,bounds.y + dy1 * bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["dx1"] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch)), bounds.x + bounds.width - pt.x))) / 100;
        this.state.style["dy1"] = Math.round(100 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height * 2))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["notch"], function(bounds) {
        var notch = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch))));
        return new mxPoint(bounds.x + notch,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["notch"] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, "dx1", this.dx1)), pt.x - bounds.x))) / 100
    });
    handles.push(handle2);
    var handle3 = Graph.createHandle(state, ["dx2"], function(bounds) {
        var dx2 = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx2", this.dx2))));
        return new mxPoint(bounds.x + bounds.width - dx2,bounds.y)
    }, function(bounds, pt) {
        this.state.style["dx2"] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch)), bounds.x + bounds.width - pt.x))) / 100
    });
    handles.push(handle3);
    return handles
}
;
function mxShapeArrows2SharpArrow2(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy1 = .5;
    this.dx1 = .5;
    this.dx2 = .5;
    this.dy3 = .5;
    this.dx3 = .5;
    this.notch = 0
}
mxUtils.extend(mxShapeArrows2SharpArrow2, mxActor);
mxShapeArrows2SharpArrow2.prototype.cst = {
    SHARP_ARROW2: "mxgraph.arrows2.sharpArrow2"
};
mxShapeArrows2SharpArrow2.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dy1 = h * .5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "dy1", this.dy1))));
    var dx1 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx1", this.dx1))));
    var dx2 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx2", this.dx2))));
    var dy3 = h * .5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "dy3", this.dy3))));
    var dx3 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx3", this.dx3))));
    var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "notch", this.notch))));
    var dx1a = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx1", this.dx1))));
    var dy1a = h * .5 * Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dy1", this.dy1))));
    c.begin();
    c.moveTo(0, dy1);
    c.lineTo(w - dx1, dy1);
    c.lineTo(w - dx3, dy3);
    c.lineTo(w - dx2, 0);
    c.lineTo(w, h * .5);
    c.lineTo(w - dx2, h);
    c.lineTo(w - dx3, h - dy3);
    c.lineTo(w - dx1, h - dy1);
    c.lineTo(0, h - dy1);
    c.lineTo(notch, h * .5);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeArrows2SharpArrow2.prototype.cst.SHARP_ARROW2, mxShapeArrows2SharpArrow2);
mxShapeArrows2SharpArrow2.prototype.constraints = null;
Graph.handleFactory[mxShapeArrows2SharpArrow2.prototype.cst.SHARP_ARROW2] = function(state) {
    var handles = [Graph.createHandle(state, ["dx1", "dy1"], function(bounds) {
        var dx1 = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx1", this.dx1))));
        var dy1 = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "dy1", this.dy1))));
        return new mxPoint(bounds.x + bounds.width - dx1,bounds.y + dy1 * bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["dx1"] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch)), bounds.x + bounds.width - pt.x))) / 100;
        this.state.style["dy1"] = Math.round(100 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height * 2))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["notch"], function(bounds) {
        var notch = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch))));
        return new mxPoint(bounds.x + notch,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["notch"] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, "dx1", this.dx1)), pt.x - bounds.x))) / 100
    });
    handles.push(handle2);
    var handle3 = Graph.createHandle(state, ["dx2"], function(bounds) {
        var dx2 = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx2", this.dx2))));
        return new mxPoint(bounds.x + bounds.width - dx2,bounds.y)
    }, function(bounds, pt) {
        this.state.style["dx2"] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch)), bounds.x + bounds.width - pt.x))) / 100
    });
    handles.push(handle3);
    var handle4 = Graph.createHandle(state, ["dx3", "dy3"], function(bounds) {
        var dx3 = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx3", this.dx3))));
        var dy3 = Math.max(0, Math.min(1 - parseFloat(mxUtils.getValue(this.state.style, "dy1", this.dy1)) / 2, parseFloat(mxUtils.getValue(this.state.style, "dy3", this.dy3))));
        return new mxPoint(bounds.x + bounds.width - dx3,bounds.y + dy3 * bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["dx3"] = Math.round(100 * Math.max(parseFloat(mxUtils.getValue(this.state.style, "dx2", this.dx2)), Math.min(bounds.width, bounds.x + bounds.width - pt.x))) / 100;
        this.state.style["dy3"] = Math.round(100 * Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, "dy1", this.dy1)), (pt.y - bounds.y) / bounds.height * 2))) / 100
    });
    handles.push(handle4);
    return handles
}
;
function mxShapeArrows2CalloutArrow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy = .5;
    this.dx = .5;
    this.notch = 0;
    this.arrowHead = 0
}
mxUtils.extend(mxShapeArrows2CalloutArrow, mxActor);
mxShapeArrows2CalloutArrow.prototype.cst = {
    CALLOUT_ARROW: "mxgraph.arrows2.calloutArrow"
};
mxShapeArrows2CalloutArrow.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "notch", this.notch))));
    var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "arrowHead", this.arrowHead))));
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(notch, 0);
    c.lineTo(notch, h * .5 - dy);
    c.lineTo(w - dx, h * .5 - dy);
    c.lineTo(w - dx, h * .5 - dy - arrowHead);
    c.lineTo(w, h * .5);
    c.lineTo(w - dx, h * .5 + dy + arrowHead);
    c.lineTo(w - dx, h * .5 + dy);
    c.lineTo(notch, h * .5 + dy);
    c.lineTo(notch, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeArrows2CalloutArrow.prototype.cst.CALLOUT_ARROW, mxShapeArrows2CalloutArrow);
mxShapeArrows2CalloutArrow.prototype.constraints = null;
Graph.handleFactory[mxShapeArrows2CalloutArrow.prototype.cst.CALLOUT_ARROW] = function(state) {
    var handles = [Graph.createHandle(state, ["dx", "dy"], function(bounds) {
        var arrowHead = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))));
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(bounds.height / 2 - arrowHead, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + bounds.width - dx,bounds.y + bounds.height / 2 - dy)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch)), bounds.x + bounds.width - pt.x))) / 100;
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2 - parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead)), bounds.y + bounds.height / 2 - pt.y))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["notch"], function(bounds) {
        var notch = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch))));
        return new mxPoint(bounds.x + notch,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["notch"] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx)), pt.x - bounds.x))) / 100
    });
    handles.push(handle2);
    var handle3 = Graph.createHandle(state, ["arrowHead"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        var arrowHead = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))));
        return new mxPoint(bounds.x + bounds.width - dx,bounds.y + bounds.height / 2 - dy - arrowHead)
    }, function(bounds, pt) {
        this.state.style["arrowHead"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2 - parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy)), bounds.y + bounds.height / 2 - parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy)) - pt.y))) / 100
    });
    handles.push(handle3);
    return handles
}
;
function mxShapeArrows2BendArrow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy = .5;
    this.dx = .5;
    this.notch = 0;
    this.arrowHead = 40
}
mxUtils.extend(mxShapeArrows2BendArrow, mxActor);
mxShapeArrows2BendArrow.prototype.cst = {
    BEND_ARROW: "mxgraph.arrows2.bendArrow"
};
mxShapeArrows2BendArrow.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    var notch = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "notch", this.notch))));
    var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "arrowHead", this.arrowHead))));
    var rounded = mxUtils.getValue(this.style, "rounded", "0");
    c.begin();
    c.moveTo(w - dx, 0);
    c.lineTo(w, arrowHead * .5);
    c.lineTo(w - dx, arrowHead);
    c.lineTo(w - dx, arrowHead / 2 + dy);
    if (rounded == "1") {
        c.lineTo(dy * 2.2, arrowHead / 2 + dy);
        c.arcTo(dy * .2, dy * .2, 0, 0, 0, dy * 2, arrowHead / 2 + dy * 1.2)
    } else
        c.lineTo(dy * 2, arrowHead / 2 + dy);
    c.lineTo(dy * 2, h);
    c.lineTo(dy, h - notch);
    c.lineTo(0, h);
    if (rounded == "1") {
        c.lineTo(0, arrowHead / 2 + dy);
        c.arcTo(dy * 2, dy * 2, 0, 0, 1, dy * 2, arrowHead / 2 - dy)
    } else
        c.lineTo(0, arrowHead / 2 - dy);
    c.lineTo(w - dx, arrowHead / 2 - dy);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeArrows2BendArrow.prototype.cst.BEND_ARROW, mxShapeArrows2BendArrow);
mxShapeArrows2BendArrow.prototype.constraints = null;
Graph.handleFactory[mxShapeArrows2BendArrow.prototype.cst.BEND_ARROW] = function(state) {
    var handles = [Graph.createHandle(state, ["dx", "dy"], function(bounds) {
        var arrowHead = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))));
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(arrowHead, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + bounds.width - dx,bounds.y + arrowHead / 2 - dy)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy)) * 2.2, bounds.x + bounds.width - pt.x))) / 100;
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead)) / 2, bounds.y + parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead)) / 2 - pt.y))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["notch"], function(bounds) {
        var arrowHead = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))));
        var dy = Math.max(0, Math.min(arrowHead, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        var notch = Math.max(0, Math.min(bounds.height - arrowHead / 2 - dy, parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch))));
        return new mxPoint(bounds.x + dy,bounds.y + bounds.height - notch)
    }, function(bounds, pt) {
        this.state.style["notch"] = Math.round(100 * Math.max(0, Math.min(bounds.height - parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead)) / 2 - parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy)), bounds.y + bounds.height - pt.y))) / 100
    });
    handles.push(handle2);
    var handle3 = Graph.createHandle(state, ["arrowHead"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var arrowHead = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))));
        return new mxPoint(bounds.x + bounds.width - dx,bounds.y + arrowHead)
    }, function(bounds, pt) {
        this.state.style["arrowHead"] = Math.round(100 * Math.max(2 * parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy)), Math.min(bounds.height, pt.y - bounds.y))) / 100
    });
    handles.push(handle3);
    return handles
}
;
function mxShapeArrows2BendDoubleArrow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy = .5;
    this.dx = .5;
    this.notch = 0;
    this.arrowHead = 40
}
mxUtils.extend(mxShapeArrows2BendDoubleArrow, mxActor);
mxShapeArrows2BendDoubleArrow.prototype.cst = {
    BEND_DOUBLE_ARROW: "mxgraph.arrows2.bendDoubleArrow"
};
mxShapeArrows2BendDoubleArrow.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    var arrowHead = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "arrowHead", this.arrowHead))));
    var rounded = mxUtils.getValue(this.style, "rounded", "0");
    c.begin();
    c.moveTo(w - dx, 0);
    c.lineTo(w, arrowHead * .5);
    c.lineTo(w - dx, arrowHead);
    c.lineTo(w - dx, arrowHead / 2 + dy);
    if (rounded == "1") {
        c.lineTo(arrowHead / 2 + dy * 1.2, arrowHead / 2 + dy);
        c.arcTo(dy * .2, dy * .2, 0, 0, 0, arrowHead / 2 + dy, arrowHead / 2 + dy * 1.2)
    } else
        c.lineTo(arrowHead / 2 + dy, arrowHead / 2 + dy);
    c.lineTo(arrowHead / 2 + dy, h - dx);
    c.lineTo(arrowHead, h - dx);
    c.lineTo(arrowHead / 2, h);
    c.lineTo(0, h - dx);
    c.lineTo(arrowHead / 2 - dy, h - dx);
    if (rounded == "1") {
        c.lineTo(arrowHead / 2 - dy, arrowHead / 2 + dy);
        c.arcTo(dy * 2, dy * 2, 0, 0, 1, arrowHead / 2 + dy, arrowHead / 2 - dy)
    } else
        c.lineTo(arrowHead / 2 - dy, arrowHead / 2 - dy);
    c.lineTo(w - dx, arrowHead / 2 - dy);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeArrows2BendDoubleArrow.prototype.cst.BEND_DOUBLE_ARROW, mxShapeArrows2BendDoubleArrow);
mxShapeArrows2BendDoubleArrow.prototype.constraints = null;
Graph.handleFactory[mxShapeArrows2BendDoubleArrow.prototype.cst.BEND_DOUBLE_ARROW] = function(state) {
    var handles = [Graph.createHandle(state, ["dx", "dy"], function(bounds) {
        var arrowHead = Math.max(0, Math.min(Math.min(bounds.height, bounds.width) - parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx)), parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))));
        var dx = Math.max(0, Math.min(Math.min(bounds.width, bounds.height) - arrowHead, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(arrowHead, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + bounds.width - dx,bounds.y + arrowHead / 2 - dy)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(Math.min(bounds.width, bounds.height) - parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead)), bounds.x + bounds.width - pt.x))) / 100;
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead)) / 2, bounds.y + parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead)) / 2 - pt.y))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["arrowHead"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var arrowHead = Math.max(0, Math.min(Math.min(bounds.height, bounds.width) - dx, parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))));
        return new mxPoint(bounds.x + bounds.width - dx,bounds.y + arrowHead)
    }, function(bounds, pt) {
        this.state.style["arrowHead"] = Math.round(100 * Math.max(2 * parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy)), Math.min(Math.min(bounds.height, bounds.width) - parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx)), pt.y - bounds.y))) / 100
    });
    handles.push(handle2);
    return handles
}
;
function mxShapeArrows2CalloutDoubleArrow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy = .5;
    this.dx = .5;
    this.notch = 0;
    this.arrowHead = 0
}
mxUtils.extend(mxShapeArrows2CalloutDoubleArrow, mxActor);
mxShapeArrows2CalloutDoubleArrow.prototype.cst = {
    CALLOUT_DOUBLE_ARROW: "mxgraph.arrows2.calloutDoubleArrow"
};
mxShapeArrows2CalloutDoubleArrow.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "notch", this.notch))));
    var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "arrowHead", this.arrowHead))));
    c.begin();
    c.moveTo(w / 2 - notch, 0);
    c.lineTo(w / 2 + notch, 0);
    c.lineTo(w / 2 + notch, h * .5 - dy);
    c.lineTo(w - dx, h * .5 - dy);
    c.lineTo(w - dx, h * .5 - dy - arrowHead);
    c.lineTo(w, h * .5);
    c.lineTo(w - dx, h * .5 + dy + arrowHead);
    c.lineTo(w - dx, h * .5 + dy);
    c.lineTo(w / 2 + notch, h * .5 + dy);
    c.lineTo(w / 2 + notch, h);
    c.lineTo(w / 2 - notch, h);
    c.lineTo(w / 2 - notch, h * .5 + dy);
    c.lineTo(dx, h * .5 + dy);
    c.lineTo(dx, h * .5 + dy + arrowHead);
    c.lineTo(0, h * .5);
    c.lineTo(dx, h * .5 - dy - arrowHead);
    c.lineTo(dx, h * .5 - dy);
    c.lineTo(w / 2 - notch, h * .5 - dy);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeArrows2CalloutDoubleArrow.prototype.cst.CALLOUT_DOUBLE_ARROW, mxShapeArrows2CalloutDoubleArrow);
mxShapeArrows2CalloutDoubleArrow.prototype.constraints = null;
Graph.handleFactory[mxShapeArrows2CalloutDoubleArrow.prototype.cst.CALLOUT_DOUBLE_ARROW] = function(state) {
    var handles = [Graph.createHandle(state, ["dx", "dy"], function(bounds) {
        var arrowHead = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))));
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(bounds.height / 2 - arrowHead, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + bounds.width - dx,bounds.y + bounds.height / 2 - dy)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.width / 2 - parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch)), bounds.x + bounds.width - pt.x))) / 100;
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2 - parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead)), bounds.y + bounds.height / 2 - pt.y))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["notch"], function(bounds) {
        var notch = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch))));
        return new mxPoint(bounds.x + bounds.width / 2 + notch,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["notch"] = Math.round(100 * Math.max(0, Math.min(bounds.width / 2 - parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx)), pt.x - bounds.x - bounds.width / 2))) / 100
    });
    handles.push(handle2);
    var handle3 = Graph.createHandle(state, ["arrowHead"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        var arrowHead = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))));
        return new mxPoint(bounds.x + bounds.width - dx,bounds.y + bounds.height / 2 - dy - arrowHead)
    }, function(bounds, pt) {
        this.state.style["arrowHead"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2 - parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy)), bounds.y + bounds.height / 2 - parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy)) - pt.y))) / 100
    });
    handles.push(handle3);
    return handles
}
;
function mxShapeArrows2CalloutQuadArrow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy = .5;
    this.dx = .5;
    this.notch = 0;
    this.arrowHead = 0
}
mxUtils.extend(mxShapeArrows2CalloutQuadArrow, mxActor);
mxShapeArrows2CalloutQuadArrow.prototype.cst = {
    CALLOUT_QUAD_ARROW: "mxgraph.arrows2.calloutQuadArrow"
};
mxShapeArrows2CalloutQuadArrow.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "notch", this.notch))));
    var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "arrowHead", this.arrowHead))));
    c.begin();
    c.moveTo(w * .5 + dy, h * .5 - notch);
    c.lineTo(w * .5 + notch, h * .5 - notch);
    c.lineTo(w * .5 + notch, h * .5 - dy);
    c.lineTo(w - dx, h * .5 - dy);
    c.lineTo(w - dx, h * .5 - dy - arrowHead);
    c.lineTo(w, h * .5);
    c.lineTo(w - dx, h * .5 + dy + arrowHead);
    c.lineTo(w - dx, h * .5 + dy);
    c.lineTo(w * .5 + notch, h * .5 + dy);
    c.lineTo(w * .5 + notch, h * .5 + notch);
    c.lineTo(w * .5 + dy, h * .5 + notch);
    c.lineTo(w * .5 + dy, h - dx);
    c.lineTo(w * .5 + dy + arrowHead, h - dx);
    c.lineTo(w * .5, h);
    c.lineTo(w * .5 - dy - arrowHead, h - dx);
    c.lineTo(w * .5 - dy, h - dx);
    c.lineTo(w * .5 - dy, h * .5 + notch);
    c.lineTo(w * .5 - notch, h * .5 + notch);
    c.lineTo(w * .5 - notch, h * .5 + dy);
    c.lineTo(dx, h * .5 + dy);
    c.lineTo(dx, h * .5 + dy + arrowHead);
    c.lineTo(0, h * .5);
    c.lineTo(dx, h * .5 - dy - arrowHead);
    c.lineTo(dx, h * .5 - dy);
    c.lineTo(w * .5 - notch, h * .5 - dy);
    c.lineTo(w * .5 - notch, h * .5 - notch);
    c.lineTo(w * .5 - dy, h * .5 - notch);
    c.lineTo(w * .5 - dy, dx);
    c.lineTo(w * .5 - dy - arrowHead, dx);
    c.lineTo(w * .5, 0);
    c.lineTo(w * .5 + dy + arrowHead, dx);
    c.lineTo(w * .5 + dy, dx);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeArrows2CalloutQuadArrow.prototype.cst.CALLOUT_QUAD_ARROW, mxShapeArrows2CalloutQuadArrow);
mxShapeArrows2CalloutQuadArrow.prototype.constraints = null;
Graph.handleFactory[mxShapeArrows2CalloutQuadArrow.prototype.cst.CALLOUT_QUAD_ARROW] = function(state) {
    var handles = [Graph.createHandle(state, ["dx", "dy"], function(bounds) {
        var arrowHead = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))));
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + bounds.width - dx,bounds.y + bounds.height / 2 - dy)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(Math.min(bounds.width, bounds.height) / 2 - Math.max(parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch)), parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))), bounds.x + bounds.width - pt.x))) / 100;
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch)), bounds.y + bounds.height / 2 - pt.y))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["notch"], function(bounds) {
        var notch = Math.max(parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy)), Math.min(Math.min(bounds.width, bounds.height), parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch))));
        return new mxPoint(bounds.x + bounds.width / 2 + notch,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["notch"] = Math.round(100 * Math.max(parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy)), Math.min(Math.min(bounds.width, bounds.height) / 2 - parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx)), pt.x - bounds.x - bounds.width / 2))) / 100
    });
    handles.push(handle2);
    var handle3 = Graph.createHandle(state, ["arrowHead"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        var arrowHead = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))));
        return new mxPoint(bounds.x + bounds.width - dx,bounds.y + bounds.height / 2 - dy - arrowHead)
    }, function(bounds, pt) {
        this.state.style["arrowHead"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2 - parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy)), bounds.y + bounds.height / 2 - pt.y))) / 100
    });
    handles.push(handle3);
    return handles
}
;
function mxShapeArrows2CalloutDouble90Arrow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy1 = .5;
    this.dx1 = .5;
    this.dx2 = 0;
    this.dy2 = 0;
    this.arrowHead = 0
}
mxUtils.extend(mxShapeArrows2CalloutDouble90Arrow, mxActor);
mxShapeArrows2CalloutDouble90Arrow.prototype.cst = {
    CALLOUT_DOUBLE_90_ARROW: "mxgraph.arrows2.calloutDouble90Arrow"
};
mxShapeArrows2CalloutDouble90Arrow.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dy1 = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dy1", this.dy1))));
    var dx1 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx1", this.dx1))));
    var dx2 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx2", this.dx2))));
    var dy2 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dy2", this.dy2))));
    var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "arrowHead", this.arrowHead))));
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(dx2, 0);
    c.lineTo(dx2, dy2 * .5 - dy1);
    c.lineTo(w - dx1, dy2 * .5 - dy1);
    c.lineTo(w - dx1, dy2 * .5 - dy1 - arrowHead);
    c.lineTo(w, dy2 * .5);
    c.lineTo(w - dx1, dy2 * .5 + dy1 + arrowHead);
    c.lineTo(w - dx1, dy2 * .5 + dy1);
    c.lineTo(dx2, dy2 * .5 + dy1);
    c.lineTo(dx2, dy2);
    c.lineTo(dx2 / 2 + dy1, dy2);
    c.lineTo(dx2 / 2 + dy1, h - dx1);
    c.lineTo(dx2 / 2 + dy1 + arrowHead, h - dx1);
    c.lineTo(dx2 / 2, h);
    c.lineTo(dx2 / 2 - dy1 - arrowHead, h - dx1);
    c.lineTo(dx2 / 2 - dy1, h - dx1);
    c.lineTo(dx2 / 2 - dy1, dy2);
    c.lineTo(0, dy2);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeArrows2CalloutDouble90Arrow.prototype.cst.CALLOUT_DOUBLE_90_ARROW, mxShapeArrows2CalloutDouble90Arrow);
mxShapeArrows2CalloutDouble90Arrow.prototype.constraints = null;
Graph.handleFactory[mxShapeArrows2CalloutDouble90Arrow.prototype.cst.CALLOUT_DOUBLE_90_ARROW] = function(state) {
    var handles = [Graph.createHandle(state, ["dx1", "dy1"], function(bounds) {
        var arrowHead = Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, "dy2", this.dy2)) / 2, parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))));
        var dx1 = Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, "dx2", this.dx2)), parseFloat(mxUtils.getValue(this.state.style, "dx1", this.dx1))));
        var dy1 = Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, "dy2", this.dy2)) / 2 - arrowHead, parseFloat(mxUtils.getValue(this.state.style, "dy1", this.dy1))));
        return new mxPoint(bounds.x + bounds.width - dx1,bounds.y + parseFloat(mxUtils.getValue(this.state.style, "dy2", this.dy2)) / 2 - dy1)
    }, function(bounds, pt) {
        this.state.style["dx1"] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, "dx2", this.dx2)), bounds.height - parseFloat(mxUtils.getValue(this.state.style, "dy2", this.dy2)), bounds.x + bounds.width - pt.x))) / 100;
        this.state.style["dy1"] = Math.round(100 * Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, "dy2", this.dy2)) / 2 - parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead)), bounds.y + parseFloat(mxUtils.getValue(this.state.style, "dy2", this.dy2)) / 2 - pt.y))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["dx2", "dy2"], function(bounds) {
        var dx2 = Math.max(parseFloat(mxUtils.getValue(this.state.style, "dy1", this.dy1)) + parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead)), Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, "dx1", this.dx1)), parseFloat(mxUtils.getValue(this.state.style, "dx2", this.dx2))));
        var dy2 = Math.max(parseFloat(mxUtils.getValue(this.state.style, "dy1", this.dy1)) + parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead)), Math.min(bounds.height - parseFloat(mxUtils.getValue(this.state.style, "dy1", this.dy1)), parseFloat(mxUtils.getValue(this.state.style, "dy2", this.dy2))));
        return new mxPoint(bounds.x + dx2,bounds.y + dy2)
    }, function(bounds, pt) {
        this.state.style["dx2"] = Math.round(100 * Math.max(parseFloat(mxUtils.getValue(this.state.style, "dy1", this.dy1)) + parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead)), Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, "dx1", this.dx1)), pt.x - bounds.x))) / 100;
        this.state.style["dy2"] = Math.round(100 * Math.max(parseFloat(mxUtils.getValue(this.state.style, "dy1", this.dy1)) + parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead)), Math.min(bounds.height - parseFloat(mxUtils.getValue(this.state.style, "dx1", this.dx1)), pt.y - bounds.y))) / 100
    });
    handles.push(handle2);
    var handle3 = Graph.createHandle(state, ["arrowHead"], function(bounds) {
        var dx1 = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx1", this.dx1))));
        var dy1 = Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, "dy2", this.dy2)) / 2, parseFloat(mxUtils.getValue(this.state.style, "dy1", this.dy1))));
        var arrowHead = Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, "dy2", this.dy2)) / 2, parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))));
        return new mxPoint(bounds.x + bounds.width - dx1,bounds.y + parseFloat(mxUtils.getValue(this.state.style, "dy2", this.dy2)) / 2 - dy1 - arrowHead)
    }, function(bounds, pt) {
        this.state.style["arrowHead"] = Math.round(100 * Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, "dy2", this.dy2)) / 2 - parseFloat(mxUtils.getValue(this.state.style, "dy1", this.dy1)), bounds.y + parseFloat(mxUtils.getValue(this.state.style, "dy2", this.dy2)) / 2 - parseFloat(mxUtils.getValue(this.state.style, "dy1", this.dy1)) - pt.y))) / 100
    });
    handles.push(handle3);
    return handles
}
;
function mxShapeArrows2QuadArrow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy = .5;
    this.dx = .5;
    this.notch = 0;
    this.arrowHead = 0
}
mxUtils.extend(mxShapeArrows2QuadArrow, mxActor);
mxShapeArrows2QuadArrow.prototype.cst = {
    QUAD_ARROW: "mxgraph.arrows2.quadArrow"
};
mxShapeArrows2QuadArrow.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "arrowHead", this.arrowHead))));
    c.begin();
    c.moveTo(w * .5 + dy, h * .5 - dy);
    c.lineTo(w - dx, h * .5 - dy);
    c.lineTo(w - dx, h * .5 - dy - arrowHead);
    c.lineTo(w, h * .5);
    c.lineTo(w - dx, h * .5 + dy + arrowHead);
    c.lineTo(w - dx, h * .5 + dy);
    c.lineTo(w * .5 + dy, h * .5 + dy);
    c.lineTo(w * .5 + dy, h - dx);
    c.lineTo(w * .5 + dy + arrowHead, h - dx);
    c.lineTo(w * .5, h);
    c.lineTo(w * .5 - dy - arrowHead, h - dx);
    c.lineTo(w * .5 - dy, h - dx);
    c.lineTo(w * .5 - dy, h * .5 + dy);
    c.lineTo(dx, h * .5 + dy);
    c.lineTo(dx, h * .5 + dy + arrowHead);
    c.lineTo(0, h * .5);
    c.lineTo(dx, h * .5 - dy - arrowHead);
    c.lineTo(dx, h * .5 - dy);
    c.lineTo(w * .5 - dy, h * .5 - dy);
    c.lineTo(w * .5 - dy, dx);
    c.lineTo(w * .5 - dy - arrowHead, dx);
    c.lineTo(w * .5, 0);
    c.lineTo(w * .5 + dy + arrowHead, dx);
    c.lineTo(w * .5 + dy, dx);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeArrows2QuadArrow.prototype.cst.QUAD_ARROW, mxShapeArrows2QuadArrow);
mxShapeArrows2QuadArrow.prototype.constraints = null;
Graph.handleFactory[mxShapeArrows2QuadArrow.prototype.cst.QUAD_ARROW] = function(state) {
    var handles = [Graph.createHandle(state, ["dx", "dy"], function(bounds) {
        var arrowHead = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))));
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + bounds.width - dx,bounds.y + bounds.height / 2 - dy)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(Math.min(bounds.width, bounds.height) / 2 - parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy)) - parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead)), bounds.x + bounds.width - pt.x))) / 100;
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2 - parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead)), bounds.y + bounds.height / 2 - pt.y))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["arrowHead"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        var arrowHead = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))));
        return new mxPoint(bounds.x + bounds.width - dx,bounds.y + bounds.height / 2 - dy - arrowHead)
    }, function(bounds, pt) {
        this.state.style["arrowHead"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2 - parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy)), bounds.y + bounds.height / 2 - pt.y))) / 100
    });
    handles.push(handle2);
    return handles
}
;
function mxShapeArrows2TriadArrow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy = .5;
    this.dx = .5;
    this.arrowHead = 0
}
mxUtils.extend(mxShapeArrows2TriadArrow, mxActor);
mxShapeArrows2TriadArrow.prototype.cst = {
    TRIAD_ARROW: "mxgraph.arrows2.triadArrow"
};
mxShapeArrows2TriadArrow.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "arrowHead", this.arrowHead))));
    c.begin();
    c.moveTo(w * .5 + arrowHead * .5 - dy, h - arrowHead + dy);
    c.lineTo(w - dx, h - arrowHead + dy);
    c.lineTo(w - dx, h - arrowHead);
    c.lineTo(w, h - arrowHead * .5);
    c.lineTo(w - dx, h);
    c.lineTo(w - dx, h - dy);
    c.lineTo(dx, h - dy);
    c.lineTo(dx, h);
    c.lineTo(0, h - arrowHead * .5);
    c.lineTo(dx, h - arrowHead);
    c.lineTo(dx, h - arrowHead + dy);
    c.lineTo(w * .5 - arrowHead * .5 + dy, h - arrowHead + dy);
    c.lineTo(w * .5 - arrowHead * .5 + dy, dx);
    c.lineTo(w * .5 - arrowHead * .5, dx);
    c.lineTo(w * .5, 0);
    c.lineTo(w * .5 + arrowHead * .5, dx);
    c.lineTo(w * .5 + arrowHead * .5 - dy, dx);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeArrows2TriadArrow.prototype.cst.TRIAD_ARROW, mxShapeArrows2TriadArrow);
mxShapeArrows2TriadArrow.prototype.constraints = null;
Graph.handleFactory[mxShapeArrows2TriadArrow.prototype.cst.TRIAD_ARROW] = function(state) {
    var handles = [Graph.createHandle(state, ["dx", "dy"], function(bounds) {
        var arrowHead = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))));
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(arrowHead, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + bounds.width - dx,bounds.y + bounds.height - dy)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(Math.min(bounds.height - parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead)), bounds.width / 2 - parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead)) / 2), bounds.x + bounds.width - pt.x))) / 100;
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead)) / 2, bounds.y + bounds.height - pt.y))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["arrowHead"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        var arrowHead = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))));
        return new mxPoint(bounds.x + bounds.width - dx,bounds.y + bounds.height - arrowHead)
    }, function(bounds, pt) {
        this.state.style["arrowHead"] = Math.round(100 * Math.max(2 * parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy)), Math.min(bounds.height - parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx)), bounds.width - parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx)) * 2, bounds.y + bounds.height - pt.y))) / 100
    });
    handles.push(handle2);
    return handles
}
;
function mxShapeArrows2TailedArrow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy = .5;
    this.dx = .5;
    this.notch = 0;
    this.arrowHead = 0
}
mxUtils.extend(mxShapeArrows2TailedArrow, mxActor);
mxShapeArrows2TailedArrow.prototype.cst = {
    TAILED_ARROW: "mxgraph.arrows2.tailedArrow"
};
mxShapeArrows2TailedArrow.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dy1 = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dy1", this.dy1))));
    var dx1 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx1", this.dx1))));
    var dy2 = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dy2", this.dy2))));
    var dx2 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx2", this.dx2))));
    var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "notch", this.notch))));
    var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "arrowHead", this.arrowHead))));
    var x2 = 0;
    if (dy2 != 0)
        x2 = dx2 + dy2 * (dy2 - dy1) / dy2;
    c.begin();
    c.moveTo(0, h * .5 - dy2);
    c.lineTo(dx2, h * .5 - dy2);
    c.lineTo(x2, h * .5 - dy1);
    c.lineTo(w - dx1, h * .5 - dy1);
    c.lineTo(w - dx1, h * .5 - dy1 - arrowHead);
    c.lineTo(w, h * .5);
    c.lineTo(w - dx1, h * .5 + dy1 + arrowHead);
    c.lineTo(w - dx1, h * .5 + dy1);
    c.lineTo(x2, h * .5 + dy1);
    c.lineTo(dx2, h * .5 + dy2);
    c.lineTo(0, h * .5 + dy2);
    c.lineTo(notch, h * .5);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeArrows2TailedArrow.prototype.cst.TAILED_ARROW, mxShapeArrows2TailedArrow);
mxShapeArrows2TailedArrow.prototype.constraints = null;
Graph.handleFactory[mxShapeArrows2TailedArrow.prototype.cst.TAILED_ARROW] = function(state) {
    var handles = [Graph.createHandle(state, ["dx1", "dy1"], function(bounds) {
        var arrowHead = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))));
        var dx1 = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx1", this.dx1))));
        var dy1 = Math.max(0, Math.min(bounds.height / 2 - arrowHead, parseFloat(mxUtils.getValue(this.state.style, "dy1", this.dy1))));
        return new mxPoint(bounds.x + bounds.width - dx1,bounds.y + bounds.height / 2 - dy1)
    }, function(bounds, pt) {
        this.state.style["dx1"] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch)), bounds.width - parseFloat(mxUtils.getValue(this.state.style, "dx2", this.dx2)), bounds.x + bounds.width - pt.x))) / 100;
        this.state.style["dy1"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2 - parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead)), parseFloat(mxUtils.getValue(this.state.style, "dy2", this.dy2)), bounds.y + bounds.height / 2 - pt.y))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["notch"], function(bounds) {
        var notch = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch))));
        return new mxPoint(bounds.x + notch,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["notch"] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, "dx1", this.dx1)), parseFloat(mxUtils.getValue(this.state.style, "dx2", this.dx2)), pt.x - bounds.x))) / 100
    });
    handles.push(handle2);
    var handle3 = Graph.createHandle(state, ["arrowHead"], function(bounds) {
        var dx1 = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx1", this.dx1))));
        var dy1 = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "dy1", this.dy1))));
        var arrowHead = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))));
        return new mxPoint(bounds.x + bounds.width - dx1,bounds.y + bounds.height / 2 - dy1 - arrowHead)
    }, function(bounds, pt) {
        this.state.style["arrowHead"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2 - parseFloat(mxUtils.getValue(this.state.style, "dy1", this.dy1)), bounds.y + bounds.height / 2 - pt.y))) / 100
    });
    handles.push(handle3);
    var handle4 = Graph.createHandle(state, ["dx2", "dy2"], function(bounds) {
        var dx2 = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx2", this.dx2))));
        var dy2 = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "dy2", this.dy2))));
        return new mxPoint(bounds.x + dx2,bounds.y + bounds.height / 2 - dy2)
    }, function(bounds, pt) {
        this.state.style["dx2"] = Math.round(100 * Math.max(parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch)), Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, "dx1", this.dx1)) - parseFloat(mxUtils.getValue(this.state.style, "dy2", this.dy2)) + parseFloat(mxUtils.getValue(this.state.style, "dy1", this.dy1)) - 1, pt.x - bounds.x))) / 100;
        this.state.style["dy2"] = Math.round(100 * Math.max(parseFloat(mxUtils.getValue(this.state.style, "dy1", this.dy1)), Math.min(bounds.height / 2, bounds.y + bounds.height / 2 - pt.y))) / 100
    });
    handles.push(handle4);
    return handles
}
;
function mxShapeArrows2TailedNotchedArrow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy = .5;
    this.dx = .5;
    this.notch = 0;
    this.arrowHead = 0
}
mxUtils.extend(mxShapeArrows2TailedNotchedArrow, mxActor);
mxShapeArrows2TailedNotchedArrow.prototype.cst = {
    TAILED_NOTCHED_ARROW: "mxgraph.arrows2.tailedNotchedArrow"
};
mxShapeArrows2TailedNotchedArrow.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dy1 = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dy1", this.dy1))));
    var dx1 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx1", this.dx1))));
    var dy2 = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dy2", this.dy2))));
    var dx2 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx2", this.dx2))));
    var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "notch", this.notch))));
    var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "arrowHead", this.arrowHead))));
    var x2 = 0;
    if (dy2 != 0)
        x2 = dx2 + notch * (dy2 - dy1) / dy2;
    c.begin();
    c.moveTo(0, h * .5 - dy2);
    c.lineTo(dx2, h * .5 - dy2);
    c.lineTo(x2, h * .5 - dy1);
    c.lineTo(w - dx1, h * .5 - dy1);
    c.lineTo(w - dx1, h * .5 - dy1 - arrowHead);
    c.lineTo(w, h * .5);
    c.lineTo(w - dx1, h * .5 + dy1 + arrowHead);
    c.lineTo(w - dx1, h * .5 + dy1);
    c.lineTo(x2, h * .5 + dy1);
    c.lineTo(dx2, h * .5 + dy2);
    c.lineTo(0, h * .5 + dy2);
    c.lineTo(notch, h * .5);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeArrows2TailedNotchedArrow.prototype.cst.TAILED_NOTCHED_ARROW, mxShapeArrows2TailedNotchedArrow);
mxShapeArrows2TailedNotchedArrow.prototype.constraints = null;
Graph.handleFactory[mxShapeArrows2TailedNotchedArrow.prototype.cst.TAILED_NOTCHED_ARROW] = function(state) {
    var handles = [Graph.createHandle(state, ["dx1", "dy1"], function(bounds) {
        var arrowHead = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))));
        var dx1 = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx1", this.dx1))));
        var dy1 = Math.max(0, Math.min(bounds.height / 2 - arrowHead, parseFloat(mxUtils.getValue(this.state.style, "dy1", this.dy1))));
        return new mxPoint(bounds.x + bounds.width - dx1,bounds.y + bounds.height / 2 - dy1)
    }, function(bounds, pt) {
        this.state.style["dx1"] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch)) - parseFloat(mxUtils.getValue(this.state.style, "dx2", this.dx2)), bounds.x + bounds.width - pt.x))) / 100;
        this.state.style["dy1"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2 - parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead)), parseFloat(mxUtils.getValue(this.state.style, "dy2", this.dy2)), bounds.y + bounds.height / 2 - pt.y))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["notch"], function(bounds) {
        var notch = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch))));
        return new mxPoint(bounds.x + notch,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["notch"] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, "dx1", this.dx1)), pt.x - bounds.x))) / 100
    });
    handles.push(handle2);
    var handle3 = Graph.createHandle(state, ["arrowHead"], function(bounds) {
        var dx1 = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx1", this.dx1))));
        var dy1 = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "dy1", this.dy1))));
        var arrowHead = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))));
        return new mxPoint(bounds.x + bounds.width - dx1,bounds.y + bounds.height / 2 - dy1 - arrowHead)
    }, function(bounds, pt) {
        this.state.style["arrowHead"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2 - parseFloat(mxUtils.getValue(this.state.style, "dy1", this.dy1)), bounds.y + bounds.height / 2 - pt.y))) / 100
    });
    handles.push(handle3);
    var handle4 = Graph.createHandle(state, ["dx2", "dy2"], function(bounds) {
        var dx2 = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx2", this.dx2))));
        var dy2 = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "dy2", this.dy2))));
        return new mxPoint(bounds.x + dx2,bounds.y + bounds.height / 2 - dy2)
    }, function(bounds, pt) {
        this.state.style["dx2"] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch)) - parseFloat(mxUtils.getValue(this.state.style, "dx1", this.dx1)), pt.x - bounds.x))) / 100;
        this.state.style["dy2"] = Math.round(100 * Math.max(parseFloat(mxUtils.getValue(this.state.style, "dy1", this.dy1)), Math.min(bounds.height / 2, bounds.y + bounds.height / 2 - pt.y))) / 100
    });
    handles.push(handle4);
    return handles
}
;
function mxShapeArrows2StripedArrow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy = .5;
    this.dx = .5;
    this.notch = 0
}
mxUtils.extend(mxShapeArrows2StripedArrow, mxActor);
mxShapeArrows2StripedArrow.prototype.cst = {
    STRIPED_ARROW: "mxgraph.arrows2.stripedArrow"
};
mxShapeArrows2StripedArrow.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dy = h * .5 * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "notch", this.notch))));
    c.begin();
    c.moveTo(notch, dy);
    c.lineTo(w - dx, dy);
    c.lineTo(w - dx, 0);
    c.lineTo(w, h * .5);
    c.lineTo(w - dx, h);
    c.lineTo(w - dx, h - dy);
    c.lineTo(notch, h - dy);
    c.close();
    c.moveTo(0, h - dy);
    c.lineTo(notch * .16, h - dy);
    c.lineTo(notch * .16, dy);
    c.lineTo(0, dy);
    c.close();
    c.moveTo(notch * .32, h - dy);
    c.lineTo(notch * .8, h - dy);
    c.lineTo(notch * .8, dy);
    c.lineTo(notch * .32, dy);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeArrows2StripedArrow.prototype.cst.STRIPED_ARROW, mxShapeArrows2StripedArrow);
mxShapeArrows2StripedArrow.prototype.constraints = null;
Graph.handleFactory[mxShapeArrows2StripedArrow.prototype.cst.STRIPED_ARROW] = function(state) {
    var handles = [Graph.createHandle(state, ["dx", "dy"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + bounds.width - dx,bounds.y + dy * bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch)), bounds.x + bounds.width - pt.x))) / 100;
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height * 2))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["notch"], function(bounds) {
        var notch = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch))));
        return new mxPoint(bounds.x + notch,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["notch"] = Math.round(100 * Math.max(0, Math.min(bounds.width - parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx)), pt.x - bounds.x))) / 100
    });
    handles.push(handle2);
    return handles
}
;
function mxShapeArrows2JumpInArrow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy = .5;
    this.dx = .5;
    this.arrowHead = 40
}
mxUtils.extend(mxShapeArrows2JumpInArrow, mxActor);
mxShapeArrows2JumpInArrow.prototype.cst = {
    JUMP_IN_ARROW: "mxgraph.arrows2.jumpInArrow"
};
mxShapeArrows2JumpInArrow.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "arrowHead", this.arrowHead))));
    c.begin();
    c.moveTo(w - dx, 0);
    c.lineTo(w, arrowHead * .5);
    c.lineTo(w - dx, arrowHead);
    c.lineTo(w - dx, arrowHead / 2 + dy);
    c.arcTo(w - dx, h - arrowHead / 2 - dy, 0, 0, 0, 0, h);
    c.arcTo(w - dx, h - arrowHead / 2 + dy, 0, 0, 1, w - dx, arrowHead / 2 - dy);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeArrows2JumpInArrow.prototype.cst.JUMP_IN_ARROW, mxShapeArrows2JumpInArrow);
mxShapeArrows2JumpInArrow.prototype.constraints = null;
Graph.handleFactory[mxShapeArrows2JumpInArrow.prototype.cst.JUMP_IN_ARROW] = function(state) {
    var handles = [Graph.createHandle(state, ["dx", "dy"], function(bounds) {
        var arrowHead = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))));
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(arrowHead, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + bounds.width - dx,bounds.y + arrowHead / 2 - dy)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.width, bounds.x + bounds.width - pt.x))) / 100;
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead)) / 2, bounds.y + parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead)) / 2 - pt.y))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["arrowHead"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var arrowHead = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))));
        return new mxPoint(bounds.x + bounds.width - dx,bounds.y + arrowHead)
    }, function(bounds, pt) {
        this.state.style["arrowHead"] = Math.round(100 * Math.max(2 * parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy)), Math.min(bounds.height, pt.y - bounds.y))) / 100
    });
    handles.push(handle2);
    return handles
}
;
function mxShapeArrows2UTurnArrow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy = .5;
    this.dx = .5;
    this.arrowHead = 40
}
mxUtils.extend(mxShapeArrows2UTurnArrow, mxActor);
mxShapeArrows2UTurnArrow.prototype.cst = {
    U_TURN_ARROW: "mxgraph.arrows2.uTurnArrow"
};
mxShapeArrows2UTurnArrow.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    var arrowHead = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "arrowHead", this.arrowHead))));
    var dx = (h - arrowHead / 2 + dy) / 2;
    var dx2 = Math.max(0, parseFloat(mxUtils.getValue(this.style, "dx2", this.dx2)));
    c.begin();
    c.moveTo(dx, 0);
    c.lineTo(dx + dx2, arrowHead * .5);
    c.lineTo(dx, arrowHead);
    c.lineTo(dx, arrowHead / 2 + dy);
    c.arcTo(dx - 2 * dy, dx - 2 * dy, 0, 0, 0, dx, h - 2 * dy);
    c.lineTo(Math.max(w, dx), h - 2 * dy);
    c.lineTo(Math.max(w, dx), h);
    c.lineTo(dx, h);
    c.arcTo(dx, dx, 0, 0, 1, dx, arrowHead / 2 - dy);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeArrows2UTurnArrow.prototype.cst.U_TURN_ARROW, mxShapeArrows2UTurnArrow);
mxShapeArrows2UTurnArrow.prototype.constraints = null;
Graph.handleFactory[mxShapeArrows2UTurnArrow.prototype.cst.U_TURN_ARROW] = function(state) {
    var handles = [Graph.createHandle(state, ["dy"], function(bounds) {
        var arrowHead = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))));
        var dy = Math.max(0, Math.min(arrowHead, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        var dx = (bounds.height - arrowHead / 2 + dy) / 2;
        return new mxPoint(bounds.x + dx,bounds.y + arrowHead / 2 - dy)
    }, function(bounds, pt) {
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead)) / 2, bounds.y + parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead)) / 2 - pt.y))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["dx2"], function(bounds) {
        var arrowHead = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))));
        var dy = Math.max(0, Math.min(arrowHead, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        var dx = (bounds.height - arrowHead / 2 + dy) / 2;
        var dx2 = Math.max(0, Math.min(bounds.width - dx, parseFloat(mxUtils.getValue(this.state.style, "dx2", this.dx2))));
        return new mxPoint(bounds.x + dx + dx2,bounds.y + arrowHead / 2)
    }, function(bounds, pt) {
        var arrowHead = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))));
        var dy = Math.max(0, Math.min(arrowHead, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        var dx = (bounds.height - arrowHead / 2 + dy) / 2;
        this.state.style["dx2"] = Math.round(100 * Math.max(0, Math.min(Math.max(bounds.width, dx), pt.x - bounds.x - dx))) / 100
    });
    handles.push(handle2);
    var handle3 = Graph.createHandle(state, ["arrowHead"], function(bounds) {
        var arrowHead = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, "arrowHead", this.arrowHead))));
        var dy = Math.max(0, Math.min(arrowHead, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        var dx = (bounds.height - arrowHead / 2 + dy) / 2;
        return new mxPoint(bounds.x + dx,bounds.y + arrowHead)
    }, function(bounds, pt) {
        this.state.style["arrowHead"] = Math.round(100 * Math.max(2 * parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy)), Math.min(bounds.height / 2, pt.y - bounds.y))) / 100
    });
    handles.push(handle3);
    return handles
}
;
function mxAtlassianJiraIssue(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5
}
mxUtils.extend(mxAtlassianJiraIssue, mxRectangleShape);
mxAtlassianJiraIssue.prototype.cst = {
    ISSUE: "mxgraph.atlassian.issue"
};
mxAtlassianJiraIssue.prototype.paintForeground = function(c, x, y, w, h) {
    c.translate(x, y);
    var issueType = mxUtils.getValue(this.style, "issueType", "task");
    var issuePriority = mxUtils.getValue(this.style, "issuePriority", "minor");
    var issueStatus = mxUtils.getValue(this.style, "issueStatus", "todo");
    c.setStrokeColor("none");
    switch (issueType) {
    case "story":
        var stencil = mxStencilRegistry.getStencil("mxgraph.atlassian.story");
        if (stencil != null) {
            c.setFillColor("#61B659");
            stencil.drawShape(c, this, 5, 5, 10, 10)
        }
        break;
    case "task":
        var stencil = mxStencilRegistry.getStencil("mxgraph.atlassian.task");
        if (stencil != null) {
            c.setFillColor("#5EA3E4");
            stencil.drawShape(c, this, 5, 5, 10, 10)
        }
        break;
    case "subTask":
        var stencil = mxStencilRegistry.getStencil("mxgraph.atlassian.subtask");
        if (stencil != null) {
            c.setFillColor("#5EA3E4");
            stencil.drawShape(c, this, 5, 5, 10, 10)
        }
        break;
    case "feature":
        var stencil = mxStencilRegistry.getStencil("mxgraph.atlassian.new_feature");
        if (stencil != null) {
            c.setFillColor("#61B659");
            stencil.drawShape(c, this, 5, 5, 10, 10)
        }
        break;
    case "bug":
        var stencil = mxStencilRegistry.getStencil("mxgraph.atlassian.bug");
        if (stencil != null) {
            c.setFillColor("#CE0000");
            stencil.drawShape(c, this, 5, 5, 10, 10)
        }
        break;
    case "techTask":
        var stencil = mxStencilRegistry.getStencil("mxgraph.atlassian.tech_task");
        if (stencil != null) {
            c.setFillColor("#999C95");
            stencil.drawShape(c, this, 5, 5, 10, 10)
        }
        break;
    case "epic":
        var stencil = mxStencilRegistry.getStencil("mxgraph.atlassian.epic");
        if (stencil != null) {
            c.setFillColor("#9E4ADD");
            stencil.drawShape(c, this, 5, 5, 10, 10)
        }
        break;
    case "improvement":
        var stencil = mxStencilRegistry.getStencil("mxgraph.atlassian.improvement");
        if (stencil != null) {
            c.setFillColor("#61B659");
            stencil.drawShape(c, this, 5, 5, 10, 10)
        }
        break;
    case "fault":
        var stencil = mxStencilRegistry.getStencil("mxgraph.atlassian.fault");
        if (stencil != null) {
            c.setFillColor("#F8902F");
            stencil.drawShape(c, this, 5, 5, 10, 10)
        }
        break;
    case "change":
        var stencil = mxStencilRegistry.getStencil("mxgraph.atlassian.change");
        if (stencil != null) {
            c.setFillColor("#9E4ADD");
            stencil.drawShape(c, this, 5, 5, 10, 10)
        }
        break;
    case "access":
        var stencil = mxStencilRegistry.getStencil("mxgraph.atlassian.access");
        if (stencil != null) {
            c.setFillColor("#F8902F");
            stencil.drawShape(c, this, 5, 5, 10, 10)
        }
        break;
    case "purchase":
        var stencil = mxStencilRegistry.getStencil("mxgraph.atlassian.purchase");
        if (stencil != null) {
            c.setFillColor("#61B659");
            stencil.drawShape(c, this, 5, 5, 10, 10)
        }
        break;
    case "itHelp":
        var stencil = mxStencilRegistry.getStencil("mxgraph.atlassian.it_help");
        if (stencil != null) {
            c.setFillColor("#5EA3E4");
            stencil.drawShape(c, this, 5, 5, 10, 10)
        }
        break
    }
    switch (issuePriority) {
    case "blocker":
        var stencil = mxStencilRegistry.getStencil("mxgraph.atlassian.no");
        if (stencil != null) {
            c.setFillColor("#CE0000");
            stencil.drawShape(c, this, 85, 5, 10, 10)
        }
        break;
    case "critical":
        var stencil = mxStencilRegistry.getStencil("mxgraph.atlassian.critical");
        if (stencil != null) {
            c.setFillColor("#CE0000");
            stencil.drawShape(c, this, 86, 3, 8, 14)
        }
        break;
    case "major":
        var stencil = mxStencilRegistry.getStencil("mxgraph.atlassian.double_up");
        if (stencil != null) {
            c.setFillColor("#CE0000");
            stencil.drawShape(c, this, 85, 5, 10, 10)
        }
        break;
    case "minor":
        var stencil = mxStencilRegistry.getStencil("mxgraph.atlassian.double");
        if (stencil != null) {
            c.setFillColor("#2A8735");
            stencil.drawShape(c, this, 85, 5, 10, 10)
        }
        break;
    case "trivial":
        var stencil = mxStencilRegistry.getStencil("mxgraph.atlassian.single");
        if (stencil != null) {
            c.setFillColor("#9AA1B2");
            stencil.drawShape(c, this, 85, 5, 10, 10)
        }
        break
    }
    c.setFillColor("#FFFFFD");
    c.setFontColor("#4E6B89");
    switch (issueStatus) {
    case "todo":
        c.rect(w - 45, 5, 40, 20);
        c.fill();
        c.text(w - 25, 15, 0, 0, "TO DO", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
        break;
    case "inProgress":
        c.rect(w - 85, 5, 80, 20);
        c.fill();
        c.text(w - 45, 15, 0, 0, "IN PROGRESS", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
        break;
    case "inReview":
        c.rect(w - 75, 5, 70, 20);
        c.fill();
        c.text(w - 40, 15, 0, 0, "IN REVIEW", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
        break;
    case "done":
        c.rect(w - 45, 5, 40, 20);
        c.fill();
        c.text(w - 25, 15, 0, 0, "DONE", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
        break;
    default:
        var tw = mxUtils.getValue(this.style, "issueStatusWidth", issueStatus.length * 6.5);
        c.rect(w - tw - 5, 5, tw, 20);
        c.fill();
        c.text(w - 7, 15, 0, 0, issueStatus, mxConstants.ALIGN_RIGHT, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
    }
}
;
mxCellRenderer.registerShape(mxAtlassianJiraIssue.prototype.cst.ISSUE, mxAtlassianJiraIssue);
function mxShapeBasicCross(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5
}
mxUtils.extend(mxShapeBasicCross, mxActor);
mxShapeBasicCross.prototype.cst = {
    CROSS: "mxgraph.basic.cross2"
};
mxShapeBasicCross.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    c.begin();
    c.moveTo(w * .5 + dx, 0);
    c.lineTo(w * .5 + dx, h * .5 - dx);
    c.lineTo(w, h * .5 - dx);
    c.lineTo(w, h * .5 + dx);
    c.lineTo(w * .5 + dx, h * .5 + dx);
    c.lineTo(w * .5 + dx, h);
    c.lineTo(w * .5 - dx, h);
    c.lineTo(w * .5 - dx, h * .5 + dx);
    c.lineTo(0, h * .5 + dx);
    c.lineTo(0, h * .5 - dx);
    c.lineTo(w * .5 - dx, h * .5 - dx);
    c.lineTo(w * .5 - dx, 0);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicCross.prototype.cst.CROSS, mxShapeBasicCross);
mxShapeBasicCross.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicCross.prototype.cst.CROSS] = function(state) {
    var handles = [Graph.createHandle(state, ["dx"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width / 2, bounds.width / 2, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        return new mxPoint(bounds.x + bounds.width / 2 + dx,bounds.y + bounds.height / 2 - dx)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, pt.x - bounds.x - bounds.width / 2))) / 100
    })];
    return handles
}
;
function mxShapeBasicRectCallout(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy = .5;
    this.dx = .5
}
mxUtils.extend(mxShapeBasicRectCallout, mxActor);
mxShapeBasicRectCallout.prototype.cst = {
    RECT_CALLOUT: "mxgraph.basic.rectCallout"
};
mxShapeBasicRectCallout.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    c.begin();
    c.moveTo(dx - dy * .5, h - dy);
    c.lineTo(0, h - dy);
    c.lineTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h - dy);
    c.lineTo(dx + dy * .5, h - dy);
    c.lineTo(dx - dy, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapeBasicRectCallout.prototype.getLabelMargins = function() {
    if (mxUtils.getValue(this.style, "boundedLbl", false))
        return new mxRectangle(0,0,0,parseFloat(mxUtils.getValue(this.style, "dy", this.dy)) * this.scale);
    return null
}
;
mxCellRenderer.registerShape(mxShapeBasicRectCallout.prototype.cst.RECT_CALLOUT, mxShapeBasicRectCallout);
mxShapeBasicRectCallout.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicRectCallout.prototype.cst.RECT_CALLOUT] = function(state) {
    var handles = [Graph.createHandle(state, ["dx", "dy"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + dx,bounds.y + bounds.height - dy)
    }, function(bounds, pt) {
        var y = parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy)) * .6;
        this.state.style["dx"] = Math.round(100 * Math.max(y, Math.min(bounds.width - y, pt.x - bounds.x))) / 100;
        this.state.style["dy"] = Math.round(Math.max(0, Math.min(bounds.height, bounds.y + bounds.height - pt.y)))
    })];
    return handles
}
;
function mxShapeBasicRoundRectCallout(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy = .5;
    this.dx = .5;
    this.size = 10
}
mxUtils.extend(mxShapeBasicRoundRectCallout, mxActor);
mxShapeBasicRoundRectCallout.prototype.cst = {
    ROUND_RECT_CALLOUT: "mxgraph.basic.roundRectCallout"
};
mxShapeBasicRoundRectCallout.prototype.getLabelMargins = mxShapeBasicRectCallout.prototype.getLabelMargins;
mxShapeBasicRoundRectCallout.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    var r = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "size", this.size))));
    r = Math.min((h - dy) / 2, w / 2, r);
    dx = Math.max(r + dy * .5, dx);
    dx = Math.min(w - r - dy * .5, dx);
    c.begin();
    c.moveTo(dx - dy * .5, h - dy);
    c.lineTo(r, h - dy);
    c.arcTo(r, r, 0, 0, 1, 0, h - dy - r);
    c.lineTo(0, r);
    c.arcTo(r, r, 0, 0, 1, r, 0);
    c.lineTo(w - r, 0);
    c.arcTo(r, r, 0, 0, 1, w, r);
    c.lineTo(w, h - dy - r);
    c.arcTo(r, r, 0, 0, 1, w - r, h - dy);
    c.lineTo(dx + dy * .5, h - dy);
    c.arcTo(1.9 * dy, 1.4 * dy, 0, 0, 1, dx - dy, h);
    c.arcTo(.9 * dy, 1.4 * dy, 0, 0, 0, dx - dy * .5, h - dy);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicRoundRectCallout.prototype.cst.ROUND_RECT_CALLOUT, mxShapeBasicRoundRectCallout);
mxShapeBasicRoundRectCallout.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicRoundRectCallout.prototype.cst.ROUND_RECT_CALLOUT] = function(state) {
    return [Graph.createHandle(state, ["dx", "dy"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + dx,bounds.y + bounds.height - dy)
    }, function(bounds, pt) {
        var y = parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy)) * .6;
        this.state.style["dx"] = Math.round(100 * Math.max(y, Math.min(bounds.width - y, pt.x - bounds.x))) / 100;
        this.state.style["dy"] = Math.round(Math.max(0, Math.min(bounds.height, bounds.y + bounds.height - pt.y)))
    }), Graph.createHandle(state, ["size"], function(bounds) {
        var size = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "size", this.size))));
        return new mxPoint(bounds.x + bounds.width - size,bounds.y + 10)
    }, function(bounds, pt) {
        var dy = parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy));
        this.state.style["size"] = Math.round(100 * Math.max(0, Math.min(bounds.width / 2, (bounds.height - dy) / 2, bounds.x + bounds.width - pt.x))) / 100
    })]
}
;
function mxShapeBasicWave(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy = .5
}
mxUtils.extend(mxShapeBasicWave, mxActor);
mxShapeBasicWave.prototype.cst = {
    WAVE: "mxgraph.basic.wave2"
};
mxShapeBasicWave.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dy = h * Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    var fy = 1.4;
    c.begin();
    c.moveTo(0, dy / 2);
    c.quadTo(w / 6, dy * (1 - fy), w / 3, dy / 2);
    c.quadTo(w / 2, dy * fy, w * 2 / 3, dy / 2);
    c.quadTo(w * 5 / 6, dy * (1 - fy), w, dy / 2);
    c.lineTo(w, h - dy / 2);
    c.quadTo(w * 5 / 6, h - dy * fy, w * 2 / 3, h - dy / 2);
    c.quadTo(w / 2, h - dy * (1 - fy), w / 3, h - dy / 2);
    c.quadTo(w / 6, h - dy * fy, 0, h - dy / 2);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicWave.prototype.cst.WAVE, mxShapeBasicWave);
mxShapeBasicWave.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicWave.prototype.cst.WAVE] = function(state) {
    var handles = [Graph.createHandle(state, ["dy"], function(bounds) {
        var dy = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + bounds.width / 2,bounds.y + dy * bounds.height)
    }, function(bounds, pt) {
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height))) / 100
    })];
    return handles
}
;
function mxShapeBasicOctagon(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5
}
mxUtils.extend(mxShapeBasicOctagon, mxActor);
mxShapeBasicOctagon.prototype.cst = {
    OCTAGON: "mxgraph.basic.octagon2"
};
mxShapeBasicOctagon.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx)))) * 2;
    dx = Math.min(w * .5, h * .5, dx);
    c.begin();
    c.moveTo(dx, 0);
    c.lineTo(w - dx, 0);
    c.lineTo(w, dx);
    c.lineTo(w, h - dx);
    c.lineTo(w - dx, h);
    c.lineTo(dx, h);
    c.lineTo(0, h - dx);
    c.lineTo(0, dx);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicOctagon.prototype.cst.OCTAGON, mxShapeBasicOctagon);
mxShapeBasicOctagon.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicOctagon.prototype.cst.OCTAGON] = function(state) {
    var handles = [Graph.createHandle(state, ["dx"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width / 4, bounds.width / 4, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        return new mxPoint(bounds.x + dx,bounds.y + dx)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 4, bounds.width / 4, pt.x - bounds.x))) / 100
    })];
    return handles
}
;
function mxShapeBasicIsoCube(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.isoAngle = 15
}
mxUtils.extend(mxShapeBasicIsoCube, mxActor);
mxShapeBasicIsoCube.prototype.cst = {
    ISO_CUBE: "mxgraph.basic.isocube"
};
mxShapeBasicIsoCube.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var isoAngle = Math.max(.01, Math.min(94, parseFloat(mxUtils.getValue(this.style, "isoAngle", this.isoAngle)))) * Math.PI / 200;
    var isoH = Math.min(w * Math.tan(isoAngle), h * .5);
    c.begin();
    c.moveTo(w * .5, 0);
    c.lineTo(w, isoH);
    c.lineTo(w, h - isoH);
    c.lineTo(w * .5, h);
    c.lineTo(0, h - isoH);
    c.lineTo(0, isoH);
    c.close();
    c.fillAndStroke();
    c.setShadow(false);
    c.begin();
    c.moveTo(0, isoH);
    c.lineTo(w * .5, 2 * isoH);
    c.lineTo(w, isoH);
    c.moveTo(w * .5, 2 * isoH);
    c.lineTo(w * .5, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicIsoCube.prototype.cst.ISO_CUBE, mxShapeBasicIsoCube);
mxShapeBasicIsoCube.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicIsoCube.prototype.cst.ISO_CUBE] = function(state) {
    var handles = [Graph.createHandle(state, ["isoAngle"], function(bounds) {
        var isoAngle = Math.max(.01, Math.min(94, parseFloat(mxUtils.getValue(this.state.style, "isoAngle", this.isoAngle)))) * Math.PI / 200;
        var isoH = Math.min(bounds.width * Math.tan(isoAngle), bounds.height * .5);
        return new mxPoint(bounds.x,bounds.y + isoH)
    }, function(bounds, pt) {
        this.state.style["isoAngle"] = Math.round(100 * Math.max(0, Math.min(100, pt.y - bounds.y))) / 100
    })];
    return handles
}
;
function mxShapeBasicTriangleAcute(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5
}
mxUtils.extend(mxShapeBasicTriangleAcute, mxActor);
mxShapeBasicTriangleAcute.prototype.cst = {
    ACUTE_TRIANGLE: "mxgraph.basic.acute_triangle"
};
mxShapeBasicTriangleAcute.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = w * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    c.begin();
    c.moveTo(0, h);
    c.lineTo(dx, 0);
    c.lineTo(w, h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicTriangleAcute.prototype.cst.ACUTE_TRIANGLE, mxShapeBasicTriangleAcute);
mxShapeBasicTriangleAcute.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicTriangleAcute.prototype.cst.ACUTE_TRIANGLE] = function(state) {
    var handles = [Graph.createHandle(state, ["dx"], function(bounds) {
        var dx = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        return new mxPoint(bounds.x + dx * bounds.width,bounds.y + 10)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(1, (pt.x - bounds.x) / bounds.width))) / 100
    })];
    return handles
}
;
function mxShapeBasicTriangleObtuse(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5
}
mxUtils.extend(mxShapeBasicTriangleObtuse, mxActor);
mxShapeBasicTriangleObtuse.prototype.cst = {
    OBTUSE_TRIANGLE: "mxgraph.basic.obtuse_triangle"
};
mxShapeBasicTriangleObtuse.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = w * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    c.begin();
    c.moveTo(dx, h);
    c.lineTo(0, 0);
    c.lineTo(w, h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicTriangleObtuse.prototype.cst.OBTUSE_TRIANGLE, mxShapeBasicTriangleObtuse);
mxShapeBasicTriangleObtuse.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicTriangleObtuse.prototype.cst.OBTUSE_TRIANGLE] = function(state) {
    var handles = [Graph.createHandle(state, ["dx"], function(bounds) {
        var dx = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        return new mxPoint(bounds.x + dx * bounds.width,bounds.y + bounds.height - 10)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(1, (pt.x - bounds.x) / bounds.width))) / 100
    })];
    return handles
}
;
function mxShapeBasicDrop(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeBasicDrop, mxActor);
mxShapeBasicDrop.prototype.cst = {
    DROP: "mxgraph.basic.drop"
};
mxShapeBasicDrop.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var r = Math.min(h, w) * .5;
    var d = h - r;
    var a = Math.sqrt(d * d - r * r);
    var angle = Math.atan(a / r);
    var x1 = r * Math.sin(angle);
    var y1 = r * Math.cos(angle);
    c.begin();
    c.moveTo(w * .5, 0);
    c.lineTo(w * .5 + x1, h - r - y1);
    c.arcTo(r, r, 0, 0, 1, w * .5 + r, h - r);
    c.arcTo(r, r, 0, 0, 1, w * .5, h);
    c.arcTo(r, r, 0, 0, 1, w * .5 - r, h - r);
    c.arcTo(r, r, 0, 0, 1, w * .5 - x1, h - r - y1);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicDrop.prototype.cst.DROP, mxShapeBasicDrop);
mxShapeBasicDrop.prototype.constraints = null;
function mxShapeBasicCone2(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5;
    this.dy = .9
}
mxUtils.extend(mxShapeBasicCone2, mxActor);
mxShapeBasicCone2.prototype.cst = {
    CONE2: "mxgraph.basic.cone2"
};
mxShapeBasicCone2.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = w * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    var dy = h * Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    var ry = h - dy;
    c.begin();
    c.moveTo(dx, 0);
    if (ry > 0) {
        c.lineTo(w, h - ry);
        c.arcTo(w * .5, ry, 0, 0, 1, w * .5, h);
        c.arcTo(w * .5, ry, 0, 0, 1, 0, h - ry)
    } else {
        c.lineTo(w, h);
        c.lineTo(0, h)
    }
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicCone2.prototype.cst.CONE2, mxShapeBasicCone2);
mxShapeBasicCone2.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicCone2.prototype.cst.CONE2] = function(state) {
    var handles = [Graph.createHandle(state, ["dx"], function(bounds) {
        var dx = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        return new mxPoint(bounds.x + dx * bounds.width,bounds.y + 10)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(1, (pt.x - bounds.x) / bounds.width))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["dy"], function(bounds) {
        var dy = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + 10,bounds.y + dy * bounds.height)
    }, function(bounds, pt) {
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height))) / 100
    });
    handles.push(handle2);
    return handles
}
;
function mxShapeBasicPyramid(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx1 = .5;
    this.dx2 = .6;
    this.dy1 = .9;
    this.dy2 = .8
}
mxUtils.extend(mxShapeBasicPyramid, mxActor);
mxShapeBasicPyramid.prototype.cst = {
    PYRAMID: "mxgraph.basic.pyramid"
};
mxShapeBasicPyramid.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx1 = w * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx1", this.dx1))));
    var dx2 = w * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx2", this.dx2))));
    var dy1 = h * Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dy1", this.dy1))));
    var dy2 = h * Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dy2", this.dy2))));
    c.begin();
    c.moveTo(dx1, 0);
    c.lineTo(w, dy2);
    c.lineTo(dx2, h);
    c.lineTo(0, dy1);
    c.close();
    c.fillAndStroke();
    c.setShadow(false);
    c.begin();
    c.moveTo(dx1, 0);
    c.lineTo(dx2, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicPyramid.prototype.cst.PYRAMID, mxShapeBasicPyramid);
mxShapeBasicPyramid.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicPyramid.prototype.cst.PYRAMID] = function(state) {
    var handles = [Graph.createHandle(state, ["dx1"], function(bounds) {
        var dx1 = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "dx1", this.dx1))));
        return new mxPoint(bounds.x + dx1 * bounds.width,bounds.y + 10)
    }, function(bounds, pt) {
        this.state.style["dx1"] = Math.round(100 * Math.max(0, Math.min(1, (pt.x - bounds.x) / bounds.width))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["dx2"], function(bounds) {
        var dx2 = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "dx2", this.dx2))));
        return new mxPoint(bounds.x + dx2 * bounds.width,bounds.y + bounds.height - 10)
    }, function(bounds, pt) {
        this.state.style["dx2"] = Math.round(100 * Math.max(0, Math.min(1, (pt.x - bounds.x) / bounds.width))) / 100
    });
    handles.push(handle2);
    var handle3 = Graph.createHandle(state, ["dy1"], function(bounds) {
        var dy1 = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "dy1", this.dy1))));
        return new mxPoint(bounds.x + 10,bounds.y + dy1 * bounds.height)
    }, function(bounds, pt) {
        this.state.style["dy1"] = Math.round(100 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height))) / 100
    });
    handles.push(handle3);
    var handle4 = Graph.createHandle(state, ["dy2"], function(bounds) {
        var dy2 = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "dy2", this.dy2))));
        return new mxPoint(bounds.x + bounds.width - 10,bounds.y + dy2 * bounds.height)
    }, function(bounds, pt) {
        this.state.style["dy2"] = Math.round(100 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height))) / 100
    });
    handles.push(handle4);
    return handles
}
;
function mxShapeBasic4PointStar2(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .8
}
mxUtils.extend(mxShapeBasic4PointStar2, mxActor);
mxShapeBasic4PointStar2.prototype.cst = {
    FOUR_POINT_STAR_2: "mxgraph.basic.4_point_star_2"
};
mxShapeBasic4PointStar2.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = .5 * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(dx * w, dx * h);
    c.lineTo(w * .5, 0);
    c.lineTo(w - dx * w, dx * h);
    c.lineTo(w, h * .5);
    c.lineTo(w - dx * w, h - dx * h);
    c.lineTo(w * .5, h);
    c.lineTo(dx * w, h - dx * h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBasic4PointStar2.prototype.cst.FOUR_POINT_STAR_2, mxShapeBasic4PointStar2);
mxShapeBasic4PointStar2.prototype.constraints = null;
Graph.handleFactory[mxShapeBasic4PointStar2.prototype.cst.FOUR_POINT_STAR_2] = function(state) {
    var handles = [Graph.createHandle(state, ["dx"], function(bounds) {
        var dx = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        return new mxPoint(bounds.x + dx * bounds.width / 2,bounds.y + dx * bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(1, 2 * (pt.x - bounds.x) / bounds.width))) / 100
    })];
    return handles
}
;
function mxShapeBasicDiagSnipRect(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5
}
mxUtils.extend(mxShapeBasicDiagSnipRect, mxActor);
mxShapeBasicDiagSnipRect.prototype.cst = {
    DIAG_SNIP_RECT: "mxgraph.basic.diag_snip_rect"
};
mxShapeBasicDiagSnipRect.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx)))) * 2;
    dx = Math.min(w * .5, h * .5, dx);
    c.begin();
    c.moveTo(dx, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h - dx);
    c.lineTo(w - dx, h);
    c.lineTo(0, h);
    c.lineTo(0, dx);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicDiagSnipRect.prototype.cst.DIAG_SNIP_RECT, mxShapeBasicDiagSnipRect);
mxShapeBasicDiagSnipRect.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicDiagSnipRect.prototype.cst.DIAG_SNIP_RECT] = function(state) {
    var handles = [Graph.createHandle(state, ["dx"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width / 4, bounds.width / 4, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        return new mxPoint(bounds.x + dx,bounds.y + dx)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 4, bounds.width / 4, pt.x - bounds.x))) / 100
    })];
    return handles
}
;
function mxShapeBasicDiagRoundRect(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5
}
mxUtils.extend(mxShapeBasicDiagRoundRect, mxActor);
mxShapeBasicDiagRoundRect.prototype.cst = {
    DIAG_ROUND_RECT: "mxgraph.basic.diag_round_rect"
};
mxShapeBasicDiagRoundRect.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx)))) * 2;
    dx = Math.min(w * .5, h * .5, dx);
    c.begin();
    c.moveTo(dx, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h - dx);
    c.arcTo(dx, dx, 0, 0, 1, w - dx, h);
    c.lineTo(0, h);
    c.lineTo(0, dx);
    c.arcTo(dx, dx, 0, 0, 1, dx, 0);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicDiagRoundRect.prototype.cst.DIAG_ROUND_RECT, mxShapeBasicDiagRoundRect);
mxShapeBasicDiagRoundRect.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicDiagRoundRect.prototype.cst.DIAG_ROUND_RECT] = function(state) {
    var handles = [Graph.createHandle(state, ["dx"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width / 4, bounds.width / 4, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        return new mxPoint(bounds.x + dx,bounds.y + dx)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 4, bounds.width / 4, pt.x - bounds.x))) / 100
    })];
    return handles
}
;
function mxShapeBasicCornerRoundRect(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5
}
mxUtils.extend(mxShapeBasicCornerRoundRect, mxActor);
mxShapeBasicCornerRoundRect.prototype.cst = {
    CORNER_ROUND_RECT: "mxgraph.basic.corner_round_rect"
};
mxShapeBasicCornerRoundRect.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx)))) * 2;
    dx = Math.min(w * .5, h * .5, dx);
    c.begin();
    c.moveTo(dx, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.lineTo(0, dx);
    c.arcTo(dx, dx, 0, 0, 1, dx, 0);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicCornerRoundRect.prototype.cst.CORNER_ROUND_RECT, mxShapeBasicCornerRoundRect);
mxShapeBasicCornerRoundRect.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicCornerRoundRect.prototype.cst.CORNER_ROUND_RECT] = function(state) {
    var handles = [Graph.createHandle(state, ["dx"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width / 4, bounds.width / 4, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        return new mxPoint(bounds.x + dx,bounds.y + dx)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 4, bounds.width / 4, pt.x - bounds.x))) / 100
    })];
    return handles
}
;
function mxShapeBasicPlaque(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5
}
mxUtils.extend(mxShapeBasicPlaque, mxActor);
mxShapeBasicPlaque.prototype.cst = {
    PLAQUE: "mxgraph.basic.plaque"
};
mxShapeBasicPlaque.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx)))) * 2;
    dx = Math.min(w * .5, h * .5, dx);
    c.begin();
    c.moveTo(w - dx, 0);
    c.arcTo(dx, dx, 0, 0, 0, w, dx);
    c.lineTo(w, h - dx);
    c.arcTo(dx, dx, 0, 0, 0, w - dx, h);
    c.lineTo(dx, h);
    c.arcTo(dx, dx, 0, 0, 0, 0, h - dx);
    c.lineTo(0, dx);
    c.arcTo(dx, dx, 0, 0, 0, dx, 0);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicPlaque.prototype.cst.PLAQUE, mxShapeBasicPlaque);
mxShapeBasicPlaque.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicPlaque.prototype.cst.PLAQUE] = function(state) {
    var handles = [Graph.createHandle(state, ["dx"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width / 4, bounds.width / 4, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        return new mxPoint(bounds.x + dx * 1.41,bounds.y + dx * 1.41)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 4, bounds.width / 4, pt.x - bounds.x))) / 100
    })];
    return handles
}
;
function mxShapeBasicFrame(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5
}
mxUtils.extend(mxShapeBasicFrame, mxActor);
mxShapeBasicFrame.prototype.cst = {
    FRAME: "mxgraph.basic.frame"
};
mxShapeBasicFrame.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    dx = Math.min(w * .5, h * .5, dx);
    c.begin();
    c.moveTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.lineTo(0, 0);
    c.close();
    c.moveTo(dx, dx);
    c.lineTo(dx, h - dx);
    c.lineTo(w - dx, h - dx);
    c.lineTo(w - dx, dx);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicFrame.prototype.cst.FRAME, mxShapeBasicFrame);
mxShapeBasicFrame.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicFrame.prototype.cst.FRAME] = function(state) {
    var handles = [Graph.createHandle(state, ["dx"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width / 2, bounds.width / 2, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        return new mxPoint(bounds.x + dx,bounds.y + dx)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, pt.x - bounds.x))) / 100
    })];
    return handles
}
;
function mxShapeBasicPlaqueFrame(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5
}
mxUtils.extend(mxShapeBasicPlaqueFrame, mxActor);
mxShapeBasicPlaqueFrame.prototype.cst = {
    PLAQUE_FRAME: "mxgraph.basic.plaque_frame"
};
mxShapeBasicPlaqueFrame.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    dx = Math.min(w * .25, h * .25, dx);
    c.begin();
    c.moveTo(w - dx, 0);
    c.arcTo(dx, dx, 0, 0, 0, w, dx);
    c.lineTo(w, h - dx);
    c.arcTo(dx, dx, 0, 0, 0, w - dx, h);
    c.lineTo(dx, h);
    c.arcTo(dx, dx, 0, 0, 0, 0, h - dx);
    c.lineTo(0, dx);
    c.arcTo(dx, dx, 0, 0, 0, dx, 0);
    c.close();
    c.moveTo(dx * 2, dx);
    c.arcTo(dx * 2, dx * 2, 0, 0, 1, dx, dx * 2);
    c.lineTo(dx, h - 2 * dx);
    c.arcTo(dx * 2, dx * 2, 0, 0, 1, dx * 2, h - dx);
    c.lineTo(w - 2 * dx, h - dx);
    c.arcTo(dx * 2, dx * 2, 0, 0, 1, w - dx, h - 2 * dx);
    c.lineTo(w - dx, dx * 2);
    c.arcTo(dx * 2, dx * 2, 0, 0, 1, w - 2 * dx, dx);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicPlaqueFrame.prototype.cst.PLAQUE_FRAME, mxShapeBasicPlaqueFrame);
mxShapeBasicPlaqueFrame.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicPlaqueFrame.prototype.cst.PLAQUE_FRAME] = function(state) {
    var handles = [Graph.createHandle(state, ["dx"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width / 4, bounds.width / 4, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        return new mxPoint(bounds.x + dx,bounds.y + dx)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 4, bounds.width / 4, pt.x - bounds.x))) / 100
    })];
    return handles
}
;
function mxShapeBasicRoundedFrame(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5
}
mxUtils.extend(mxShapeBasicRoundedFrame, mxActor);
mxShapeBasicRoundedFrame.prototype.cst = {
    ROUNDED_FRAME: "mxgraph.basic.rounded_frame"
};
mxShapeBasicRoundedFrame.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    dx = Math.min(w * .25, h * .25, dx);
    c.begin();
    c.moveTo(w - 2 * dx, 0);
    c.arcTo(dx * 2, dx * 2, 0, 0, 1, w, 2 * dx);
    c.lineTo(w, h - 2 * dx);
    c.arcTo(dx * 2, dx * 2, 0, 0, 1, w - 2 * dx, h);
    c.lineTo(dx * 2, h);
    c.arcTo(dx * 2, dx * 2, 0, 0, 1, 0, h - 2 * dx);
    c.lineTo(0, 2 * dx);
    c.arcTo(dx * 2, dx * 2, 0, 0, 1, 2 * dx, 0);
    c.close();
    c.moveTo(dx * 2, dx);
    c.arcTo(dx, dx, 0, 0, 0, dx, dx * 2);
    c.lineTo(dx, h - 2 * dx);
    c.arcTo(dx, dx, 0, 0, 0, dx * 2, h - dx);
    c.lineTo(w - 2 * dx, h - dx);
    c.arcTo(dx, dx, 0, 0, 0, w - dx, h - 2 * dx);
    c.lineTo(w - dx, dx * 2);
    c.arcTo(dx, dx, 0, 0, 0, w - 2 * dx, dx);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicRoundedFrame.prototype.cst.ROUNDED_FRAME, mxShapeBasicRoundedFrame);
mxShapeBasicRoundedFrame.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicRoundedFrame.prototype.cst.ROUNDED_FRAME] = function(state) {
    var handles = [Graph.createHandle(state, ["dx"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width / 4, bounds.width / 4, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        return new mxPoint(bounds.x + dx,bounds.y + dx)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 4, bounds.width / 4, pt.x - bounds.x))) / 100
    })];
    return handles
}
;
function mxShapeBasicFrameCorner(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5
}
mxUtils.extend(mxShapeBasicFrameCorner, mxActor);
mxShapeBasicFrameCorner.prototype.cst = {
    FRAME_CORNER: "mxgraph.basic.frame_corner"
};
mxShapeBasicFrameCorner.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    dx = Math.min(w * .5, h * .5, dx);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w - dx, dx);
    c.lineTo(dx, dx);
    c.lineTo(dx, h - dx);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicFrameCorner.prototype.cst.FRAME_CORNER, mxShapeBasicFrameCorner);
mxShapeBasicFrameCorner.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicFrameCorner.prototype.cst.FRAME_CORNER] = function(state) {
    var handles = [Graph.createHandle(state, ["dx"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width / 2, bounds.width / 2, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        return new mxPoint(bounds.x + dx,bounds.y + dx)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, pt.x - bounds.x))) / 100
    })];
    return handles
}
;
function mxShapeBasicDiagStripe(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5
}
mxUtils.extend(mxShapeBasicDiagStripe, mxActor);
mxShapeBasicDiagStripe.prototype.cst = {
    DIAG_STRIPE: "mxgraph.basic.diag_stripe"
};
mxShapeBasicDiagStripe.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    dx = Math.min(w, h, dx);
    c.begin();
    c.moveTo(0, h);
    c.lineTo(w, 0);
    c.lineTo(w, Math.min(dx * 100 / w, h));
    c.lineTo(Math.min(dx * 100 / h, w), h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicDiagStripe.prototype.cst.DIAG_STRIPE, mxShapeBasicDiagStripe);
mxShapeBasicDiagStripe.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicDiagStripe.prototype.cst.DIAG_STRIPE] = function(state) {
    var handles = [Graph.createHandle(state, ["dx"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width / 2, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        return new mxPoint(bounds.x + dx,bounds.y + bounds.height)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, pt.x - bounds.x))) / 100
    })];
    return handles
}
;
function mxShapeBasicDonut(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5
}
mxUtils.extend(mxShapeBasicDonut, mxActor);
mxShapeBasicDonut.prototype.cst = {
    DONUT: "mxgraph.basic.donut"
};
mxShapeBasicDonut.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    dx = Math.min(w * .5, h * .5, dx);
    c.begin();
    c.moveTo(0, h * .5);
    c.arcTo(w * .5, h * .5, 0, 0, 1, w * .5, 0);
    c.arcTo(w * .5, h * .5, 0, 0, 1, w, h * .5);
    c.arcTo(w * .5, h * .5, 0, 0, 1, w * .5, h);
    c.arcTo(w * .5, h * .5, 0, 0, 1, 0, h * .5);
    c.close();
    c.moveTo(w * .5, dx);
    c.arcTo(w * .5 - dx, h * .5 - dx, 0, 0, 0, dx, h * .5);
    c.arcTo(w * .5 - dx, h * .5 - dx, 0, 0, 0, w * .5, h - dx);
    c.arcTo(w * .5 - dx, h * .5 - dx, 0, 0, 0, w - dx, h * .5);
    c.arcTo(w * .5 - dx, h * .5 - dx, 0, 0, 0, w * .5, dx);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicDonut.prototype.cst.DONUT, mxShapeBasicDonut);
mxShapeBasicDonut.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicDonut.prototype.cst.DONUT] = function(state) {
    var handles = [Graph.createHandle(state, ["dx"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width / 2, bounds.width / 2, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        return new mxPoint(bounds.x + dx,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, pt.x - bounds.x))) / 100
    })];
    return handles
}
;
function mxShapeBasicLayeredRect(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5
}
mxUtils.extend(mxShapeBasicLayeredRect, mxActor);
mxShapeBasicLayeredRect.prototype.cst = {
    LAYERED_RECT: "mxgraph.basic.layered_rect"
};
mxShapeBasicLayeredRect.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    dx = Math.min(w * .5, h * .5, dx);
    c.begin();
    c.moveTo(dx, dx);
    c.lineTo(w, dx);
    c.lineTo(w, h);
    c.lineTo(dx, h);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(dx * .5, dx * .5);
    c.lineTo(w - dx * .5, dx * .5);
    c.lineTo(w - dx * .5, h - dx * .5);
    c.lineTo(dx * .5, h - dx * .5);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w - dx, 0);
    c.lineTo(w - dx, h - dx);
    c.lineTo(0, h - dx);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicLayeredRect.prototype.cst.LAYERED_RECT, mxShapeBasicLayeredRect);
mxShapeBasicLayeredRect.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicLayeredRect.prototype.cst.LAYERED_RECT] = function(state) {
    var handles = [Graph.createHandle(state, ["dx"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width / 2, bounds.width / 2, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        return new mxPoint(bounds.x + bounds.width - dx,bounds.y + bounds.height - dx)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, -pt.x + bounds.width + bounds.x))) / 100
    })];
    return handles
}
;
function mxShapeBasicButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5
}
mxUtils.extend(mxShapeBasicButton, mxActor);
mxShapeBasicButton.prototype.cst = {
    BUTTON: "mxgraph.basic.button"
};
mxShapeBasicButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    dx = Math.min(w * .5, h * .5, dx);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke();
    c.setShadow(false);
    c.setLineJoin("round");
    c.begin();
    c.moveTo(0, h);
    c.lineTo(0, 0);
    c.lineTo(dx, dx);
    c.lineTo(dx, h - dx);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w - dx, dx);
    c.lineTo(dx, dx);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(w - dx, h - dx);
    c.lineTo(w - dx, dx);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(0, h);
    c.lineTo(dx, h - dx);
    c.lineTo(w - dx, h - dx);
    c.lineTo(w, h);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(0, h);
    c.lineTo(0, 0);
    c.lineTo(dx, dx);
    c.lineTo(dx, h - dx);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicButton.prototype.cst.BUTTON, mxShapeBasicButton);
mxShapeBasicButton.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicButton.prototype.cst.BUTTON] = function(state) {
    var handles = [Graph.createHandle(state, ["dx"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width / 2, bounds.width / 2, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        return new mxPoint(bounds.x + dx,bounds.y + dx)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, pt.x - bounds.x))) / 100
    })];
    return handles
}
;
function mxShapeBasicShadedButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5
}
mxUtils.extend(mxShapeBasicShadedButton, mxActor);
mxShapeBasicShadedButton.prototype.cst = {
    SHADED_BUTTON: "mxgraph.basic.shaded_button"
};
mxShapeBasicShadedButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.setShadow(false);
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    dx = Math.min(w * .5, h * .5, dx);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.fill();
    c.setFillColor("#ffffff");
    c.setAlpha(.25);
    c.begin();
    c.moveTo(0, h);
    c.lineTo(0, 0);
    c.lineTo(dx, dx);
    c.lineTo(dx, h - dx);
    c.close();
    c.fill();
    c.setAlpha(.5);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w - dx, dx);
    c.lineTo(dx, dx);
    c.close();
    c.fill();
    c.setFillColor("#000000");
    c.setAlpha(.25);
    c.begin();
    c.moveTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(w - dx, h - dx);
    c.lineTo(w - dx, dx);
    c.close();
    c.fill();
    c.setAlpha(.5);
    c.begin();
    c.moveTo(0, h);
    c.lineTo(dx, h - dx);
    c.lineTo(w - dx, h - dx);
    c.lineTo(w, h);
    c.close();
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeBasicShadedButton.prototype.cst.SHADED_BUTTON, mxShapeBasicShadedButton);
mxShapeBasicShadedButton.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicShadedButton.prototype.cst.SHADED_BUTTON] = function(state) {
    var handles = [Graph.createHandle(state, ["dx"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width / 2, bounds.width / 2, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        return new mxPoint(bounds.x + dx,bounds.y + dx)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, pt.x - bounds.x))) / 100
    })];
    return handles
}
;
function mxShapeBasicPie(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.startAngle = .25;
    this.endAngle = .75
}
mxUtils.extend(mxShapeBasicPie, mxActor);
mxShapeBasicPie.prototype.cst = {
    PIE: "mxgraph.basic.pie"
};
mxShapeBasicPie.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var startAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "startAngle", this.startAngle))));
    var endAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "endAngle", this.endAngle))));
    var rx = w * .5;
    var ry = h * .5;
    var startX = rx + Math.sin(startAngle) * rx;
    var startY = ry - Math.cos(startAngle) * ry;
    var endX = rx + Math.sin(endAngle) * rx;
    var endY = ry - Math.cos(endAngle) * ry;
    var angDiff = endAngle - startAngle;
    if (angDiff < 0)
        angDiff = angDiff + Math.PI * 2;
    var bigArc = 0;
    if (angDiff > Math.PI)
        bigArc = 1;
    c.begin();
    c.moveTo(rx, ry);
    c.lineTo(startX, startY);
    c.arcTo(rx, ry, 0, bigArc, 1, endX, endY);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicPie.prototype.cst.PIE, mxShapeBasicPie);
mxShapeBasicPie.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicPie.prototype.cst.PIE] = function(state) {
    var handles = [Graph.createHandle(state, ["startAngle"], function(bounds) {
        var startAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "startAngle", this.startAngle))));
        return new mxPoint(bounds.x + bounds.width * .5 + Math.sin(startAngle) * bounds.width * .5,bounds.y + bounds.height * .5 - Math.cos(startAngle) * bounds.height * .5)
    }, function(bounds, pt) {
        var handleX = Math.round(100 * Math.max(-1, Math.min(1, (pt.x - bounds.x - bounds.width * .5) / (bounds.width * .5)))) / 100;
        var handleY = -Math.round(100 * Math.max(-1, Math.min(1, (pt.y - bounds.y - bounds.height * .5) / (bounds.height * .5)))) / 100;
        var res = .5 * Math.atan2(handleX, handleY) / Math.PI;
        if (res < 0)
            res = 1 + res;
        this.state.style["startAngle"] = res
    })];
    var handle2 = Graph.createHandle(state, ["endAngle"], function(bounds) {
        var endAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "endAngle", this.endAngle))));
        return new mxPoint(bounds.x + bounds.width * .5 + Math.sin(endAngle) * bounds.width * .5,bounds.y + bounds.height * .5 - Math.cos(endAngle) * bounds.height * .5)
    }, function(bounds, pt) {
        var handleX = Math.round(100 * Math.max(-1, Math.min(1, (pt.x - bounds.x - bounds.width * .5) / (bounds.width * .5)))) / 100;
        var handleY = -Math.round(100 * Math.max(-1, Math.min(1, (pt.y - bounds.y - bounds.height * .5) / (bounds.height * .5)))) / 100;
        var res = .5 * Math.atan2(handleX, handleY) / Math.PI;
        if (res < 0)
            res = 1 + res;
        this.state.style["endAngle"] = res
    });
    handles.push(handle2);
    return handles
}
;
function mxShapeBasicArc(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.startAngle = .25;
    this.endAngle = .75
}
mxUtils.extend(mxShapeBasicArc, mxActor);
mxShapeBasicArc.prototype.cst = {
    ARC: "mxgraph.basic.arc"
};
mxShapeBasicArc.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var startAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "startAngle", this.startAngle))));
    var endAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "endAngle", this.endAngle))));
    var rx = w * .5;
    var ry = h * .5;
    var startX = rx + Math.sin(startAngle) * rx;
    var startY = ry - Math.cos(startAngle) * ry;
    var endX = rx + Math.sin(endAngle) * rx;
    var endY = ry - Math.cos(endAngle) * ry;
    var angDiff = endAngle - startAngle;
    if (angDiff < 0)
        angDiff = angDiff + Math.PI * 2;
    var bigArc = 0;
    if (angDiff > Math.PI)
        bigArc = 1;
    c.begin();
    c.moveTo(startX, startY);
    c.arcTo(rx, ry, 0, bigArc, 1, endX, endY);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicArc.prototype.cst.ARC, mxShapeBasicArc);
mxShapeBasicArc.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicArc.prototype.cst.ARC] = function(state) {
    var handles = [Graph.createHandle(state, ["startAngle"], function(bounds) {
        var startAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "startAngle", this.startAngle))));
        return new mxPoint(bounds.x + bounds.width * .5 + Math.sin(startAngle) * bounds.width * .5,bounds.y + bounds.height * .5 - Math.cos(startAngle) * bounds.height * .5)
    }, function(bounds, pt) {
        var handleX = Math.round(100 * Math.max(-1, Math.min(1, (pt.x - bounds.x - bounds.width * .5) / (bounds.width * .5)))) / 100;
        var handleY = -Math.round(100 * Math.max(-1, Math.min(1, (pt.y - bounds.y - bounds.height * .5) / (bounds.height * .5)))) / 100;
        var res = .5 * Math.atan2(handleX, handleY) / Math.PI;
        if (res < 0)
            res = 1 + res;
        this.state.style["startAngle"] = res
    })];
    var handle2 = Graph.createHandle(state, ["endAngle"], function(bounds) {
        var endAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "endAngle", this.endAngle))));
        return new mxPoint(bounds.x + bounds.width * .5 + Math.sin(endAngle) * bounds.width * .5,bounds.y + bounds.height * .5 - Math.cos(endAngle) * bounds.height * .5)
    }, function(bounds, pt) {
        var handleX = Math.round(100 * Math.max(-1, Math.min(1, (pt.x - bounds.x - bounds.width * .5) / (bounds.width * .5)))) / 100;
        var handleY = -Math.round(100 * Math.max(-1, Math.min(1, (pt.y - bounds.y - bounds.height * .5) / (bounds.height * .5)))) / 100;
        var res = .5 * Math.atan2(handleX, handleY) / Math.PI;
        if (res < 0)
            res = 1 + res;
        this.state.style["endAngle"] = res
    });
    handles.push(handle2);
    return handles
}
;
function mxShapeBasicPartConcEllipse(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.startAngle = .25;
    this.endAngle = .75;
    this.arcWidth = .5
}
mxUtils.extend(mxShapeBasicPartConcEllipse, mxActor);
mxShapeBasicPartConcEllipse.prototype.cst = {
    PART_CONC_ELLIPSE: "mxgraph.basic.partConcEllipse"
};
mxShapeBasicPartConcEllipse.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var startAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "startAngle", this.startAngle))));
    var endAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "endAngle", this.endAngle))));
    var arcWidth = 1 - Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "arcWidth", this.arcWidth))));
    var rx = w * .5;
    var ry = h * .5;
    var rx2 = rx * arcWidth;
    var ry2 = ry * arcWidth;
    var angDiff = endAngle - startAngle;
    if (angDiff < 0)
        angDiff = angDiff + Math.PI * 2;
    else if (angDiff == Math.PI)
        endAngle = endAngle + 1E-5;
    var startX = rx + Math.sin(startAngle) * rx;
    var startY = ry - Math.cos(startAngle) * ry;
    var innerStartX = rx + Math.sin(startAngle) * rx2;
    var innerStartY = ry - Math.cos(startAngle) * ry2;
    var endX = rx + Math.sin(endAngle) * rx;
    var endY = ry - Math.cos(endAngle) * ry;
    var innerEndX = rx + Math.sin(endAngle) * rx2;
    var innerEndY = ry - Math.cos(endAngle) * ry2;
    var bigArc = 0;
    if (angDiff >= Math.PI)
        bigArc = 1;
    c.begin();
    c.moveTo(startX, startY);
    c.arcTo(rx, ry, 0, bigArc, 1, endX, endY);
    c.lineTo(innerEndX, innerEndY);
    c.arcTo(rx2, ry2, 0, bigArc, 0, innerStartX, innerStartY);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicPartConcEllipse.prototype.cst.PART_CONC_ELLIPSE, mxShapeBasicPartConcEllipse);
mxShapeBasicPartConcEllipse.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicPartConcEllipse.prototype.cst.PART_CONC_ELLIPSE] = function(state) {
    var handles = [Graph.createHandle(state, ["startAngle"], function(bounds) {
        var startAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "startAngle", this.startAngle))));
        return new mxPoint(bounds.x + bounds.width * .5 + Math.sin(startAngle) * bounds.width * .5,bounds.y + bounds.height * .5 - Math.cos(startAngle) * bounds.height * .5)
    }, function(bounds, pt) {
        var handleX = Math.round(100 * Math.max(-1, Math.min(1, (pt.x - bounds.x - bounds.width * .5) / (bounds.width * .5)))) / 100;
        var handleY = -Math.round(100 * Math.max(-1, Math.min(1, (pt.y - bounds.y - bounds.height * .5) / (bounds.height * .5)))) / 100;
        var res = .5 * Math.atan2(handleX, handleY) / Math.PI;
        if (res < 0)
            res = 1 + res;
        this.state.style["startAngle"] = res
    })];
    var handle2 = Graph.createHandle(state, ["endAngle"], function(bounds) {
        var endAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "endAngle", this.endAngle))));
        return new mxPoint(bounds.x + bounds.width * .5 + Math.sin(endAngle) * bounds.width * .5,bounds.y + bounds.height * .5 - Math.cos(endAngle) * bounds.height * .5)
    }, function(bounds, pt) {
        var handleX = Math.round(100 * Math.max(-1, Math.min(1, (pt.x - bounds.x - bounds.width * .5) / (bounds.width * .5)))) / 100;
        var handleY = -Math.round(100 * Math.max(-1, Math.min(1, (pt.y - bounds.y - bounds.height * .5) / (bounds.height * .5)))) / 100;
        var res = .5 * Math.atan2(handleX, handleY) / Math.PI;
        if (res < 0)
            res = 1 + res;
        this.state.style["endAngle"] = res
    });
    handles.push(handle2);
    var handle3 = Graph.createHandle(state, ["arcWidth"], function(bounds) {
        var arcWidth = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "arcWidth", this.arcWidth))));
        return new mxPoint(bounds.x + bounds.width / 2,bounds.y + arcWidth * bounds.height * .5)
    }, function(bounds, pt) {
        this.state.style["arcWidth"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, (pt.y - bounds.y) / (bounds.height * .5)))) / 100
    });
    handles.push(handle3);
    return handles
}
;
function mxShapeBasicNumEntryVert(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy = .5
}
mxUtils.extend(mxShapeBasicNumEntryVert, mxActor);
mxShapeBasicNumEntryVert.prototype.cst = {
    NUM_ENTRY_VERT: "mxgraph.basic.numberedEntryVert"
};
mxShapeBasicNumEntryVert.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dy = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    var inset = 5;
    var d = Math.min(dy, w - 2 * inset, h - inset);
    c.ellipse(w * .5 - d * .5, 0, d, d);
    c.fillAndStroke();
    c.begin();
    c.moveTo(0, d * .5);
    c.lineTo(w * .5 - d * .5 - inset, d * .5);
    c.arcTo(d * .5 + inset, d * .5 + inset, 0, 0, 0, w * .5 + d * .5 + inset, d * .5);
    c.lineTo(w, d * .5);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicNumEntryVert.prototype.cst.NUM_ENTRY_VERT, mxShapeBasicNumEntryVert);
mxShapeBasicNumEntryVert.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicNumEntryVert.prototype.cst.NUM_ENTRY_VERT] = function(state) {
    var handles = [Graph.createHandle(state, ["dy"], function(bounds) {
        var dy = Math.max(0, Math.min(bounds.width, bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + bounds.width / 2,bounds.y + dy)
    }, function(bounds, pt) {
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(bounds.height, bounds.width, pt.y - bounds.y))) / 100
    })];
    return handles
}
;
function mxShapeBasicBendingArch(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.startAngle = .25;
    this.endAngle = .75;
    this.arcWidth = .5
}
mxUtils.extend(mxShapeBasicBendingArch, mxActor);
mxShapeBasicBendingArch.prototype.cst = {
    BENDING_ARCH: "mxgraph.basic.bendingArch"
};
mxShapeBasicBendingArch.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var startAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "startAngle", this.startAngle))));
    var endAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "endAngle", this.endAngle))));
    var arcWidth = 1 - Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "arcWidth", this.arcWidth))));
    var rx = w * .5;
    var ry = h * .5;
    var rx2 = rx * arcWidth;
    var ry2 = ry * arcWidth;
    var startX = rx + Math.sin(startAngle) * rx;
    var startY = ry - Math.cos(startAngle) * ry;
    var innerStartX = rx + Math.sin(startAngle) * rx2;
    var innerStartY = ry - Math.cos(startAngle) * ry2;
    var endX = rx + Math.sin(endAngle) * rx;
    var endY = ry - Math.cos(endAngle) * ry;
    var innerEndX = rx + Math.sin(endAngle) * rx2;
    var innerEndY = ry - Math.cos(endAngle) * ry2;
    var angDiff = endAngle - startAngle;
    if (angDiff < 0)
        angDiff = angDiff + Math.PI * 2;
    var bigArc = 0;
    if (angDiff > Math.PI)
        bigArc = 1;
    var rx3 = rx2 - 5;
    var ry3 = ry2 - 5;
    c.ellipse(w * .5 - rx3, h * .5 - ry3, 2 * rx3, 2 * ry3);
    c.fillAndStroke();
    c.begin();
    c.moveTo(startX, startY);
    c.arcTo(rx, ry, 0, bigArc, 1, endX, endY);
    c.lineTo(innerEndX, innerEndY);
    c.arcTo(rx2, ry2, 0, bigArc, 0, innerStartX, innerStartY);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicBendingArch.prototype.cst.BENDING_ARCH, mxShapeBasicBendingArch);
mxShapeBasicBendingArch.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicBendingArch.prototype.cst.BENDING_ARCH] = function(state) {
    var handles = [Graph.createHandle(state, ["startAngle"], function(bounds) {
        var startAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "startAngle", this.startAngle))));
        return new mxPoint(bounds.x + bounds.width * .5 + Math.sin(startAngle) * bounds.width * .5,bounds.y + bounds.height * .5 - Math.cos(startAngle) * bounds.height * .5)
    }, function(bounds, pt) {
        var handleX = Math.round(100 * Math.max(-1, Math.min(1, (pt.x - bounds.x - bounds.width * .5) / (bounds.width * .5)))) / 100;
        var handleY = -Math.round(100 * Math.max(-1, Math.min(1, (pt.y - bounds.y - bounds.height * .5) / (bounds.height * .5)))) / 100;
        var res = .5 * Math.atan2(handleX, handleY) / Math.PI;
        if (res < 0)
            res = 1 + res;
        this.state.style["startAngle"] = res
    })];
    var handle2 = Graph.createHandle(state, ["endAngle"], function(bounds) {
        var endAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "endAngle", this.endAngle))));
        return new mxPoint(bounds.x + bounds.width * .5 + Math.sin(endAngle) * bounds.width * .5,bounds.y + bounds.height * .5 - Math.cos(endAngle) * bounds.height * .5)
    }, function(bounds, pt) {
        var handleX = Math.round(100 * Math.max(-1, Math.min(1, (pt.x - bounds.x - bounds.width * .5) / (bounds.width * .5)))) / 100;
        var handleY = -Math.round(100 * Math.max(-1, Math.min(1, (pt.y - bounds.y - bounds.height * .5) / (bounds.height * .5)))) / 100;
        var res = .5 * Math.atan2(handleX, handleY) / Math.PI;
        if (res < 0)
            res = 1 + res;
        this.state.style["endAngle"] = res
    });
    handles.push(handle2);
    var handle3 = Graph.createHandle(state, ["arcWidth"], function(bounds) {
        var arcWidth = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "arcWidth", this.arcWidth))));
        return new mxPoint(bounds.x + bounds.width / 2,bounds.y + arcWidth * bounds.height * .5)
    }, function(bounds, pt) {
        this.state.style["arcWidth"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, (pt.y - bounds.y) / (bounds.height * .5)))) / 100
    });
    handles.push(handle3);
    return handles
}
;
function mxShapeBasicThreeCornerRoundRect(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5
}
mxUtils.extend(mxShapeBasicThreeCornerRoundRect, mxActor);
mxShapeBasicThreeCornerRoundRect.prototype.cst = {
    THREE_CORNER_ROUND_RECT: "mxgraph.basic.three_corner_round_rect"
};
mxShapeBasicThreeCornerRoundRect.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx)))) * 2;
    dx = Math.min(w * .5, h * .5, dx);
    c.begin();
    c.moveTo(dx, 0);
    c.lineTo(w - dx, 0);
    c.arcTo(dx, dx, 0, 0, 1, w, dx);
    c.lineTo(w, h - dx);
    c.arcTo(dx, dx, 0, 0, 1, w - dx, h);
    c.lineTo(0, h);
    c.lineTo(0, dx);
    c.arcTo(dx, dx, 0, 0, 1, dx, 0);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBasicThreeCornerRoundRect.prototype.cst.THREE_CORNER_ROUND_RECT, mxShapeBasicThreeCornerRoundRect);
mxShapeBasicThreeCornerRoundRect.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicThreeCornerRoundRect.prototype.cst.THREE_CORNER_ROUND_RECT] = function(state) {
    var handles = [Graph.createHandle(state, ["dx"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width / 4, bounds.width / 4, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        return new mxPoint(bounds.x + dx,bounds.y + dx)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 4, bounds.width / 4, pt.x - bounds.x))) / 100
    })];
    return handles
}
;
function mxShapeBootstrapRRect(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeBootstrapRRect, mxShape);
mxShapeBootstrapRRect.prototype.cst = {
    PACKAGE: "mxgraph.bootstrap.rrect",
    R_SIZE: "rSize"
};
mxShapeBootstrapRRect.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeBootstrapRRect.prototype.cst.R_SIZE, "10"));
    c.roundrect(0, 0, w, h, rSize);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBootstrapRRect.prototype.cst.PACKAGE, mxShapeBootstrapRRect);
function mxShapeBootstrapTopButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeBootstrapTopButton, mxShape);
mxShapeBootstrapTopButton.prototype.cst = {
    TOP_BUTTON: "mxgraph.bootstrap.topButton",
    R_SIZE: "rSize"
};
mxShapeBootstrapTopButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeBootstrapTopButton.prototype.cst.R_SIZE, "10"));
    c.begin();
    c.moveTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBootstrapTopButton.prototype.cst.TOP_BUTTON, mxShapeBootstrapTopButton);
function mxShapeBootstrapBottomButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeBootstrapBottomButton, mxShape);
mxShapeBootstrapBottomButton.prototype.cst = {
    BOTTOM_BUTTON: "mxgraph.bootstrap.bottomButton",
    R_SIZE: "rSize"
};
mxShapeBootstrapBottomButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeBootstrapBottomButton.prototype.cst.R_SIZE, "10"));
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h - rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
    c.lineTo(rSize, h);
    c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBootstrapBottomButton.prototype.cst.BOTTOM_BUTTON, mxShapeBootstrapBottomButton);
function mxShapeBootstrapRightButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeBootstrapRightButton, mxShape);
mxShapeBootstrapRightButton.prototype.cst = {
    RIGHT_BUTTON: "mxgraph.bootstrap.rightButton",
    R_SIZE: "rSize"
};
mxShapeBootstrapRightButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeBootstrapRightButton.prototype.cst.R_SIZE, "10"));
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, h - rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBootstrapRightButton.prototype.cst.RIGHT_BUTTON, mxShapeBootstrapRightButton);
function mxShapeBootstrapLeftButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeBootstrapLeftButton, mxShape);
mxShapeBootstrapLeftButton.prototype.cst = {
    LEFT_BUTTON: "mxgraph.bootstrap.leftButton",
    R_SIZE: "rSize"
};
mxShapeBootstrapLeftButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeBootstrapLeftButton.prototype.cst.R_SIZE, "10"));
    c.begin();
    c.moveTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(rSize, h);
    c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
    c.lineTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeBootstrapLeftButton.prototype.cst.LEFT_BUTTON, mxShapeBootstrapLeftButton);
function mxShapeBootstrapLeftButtonStriped(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeBootstrapLeftButtonStriped, mxShape);
mxShapeBootstrapLeftButtonStriped.prototype.cst = {
    LEFT_BUTTON_STRIPED: "mxgraph.bootstrap.leftButtonStriped"
};
mxShapeBootstrapLeftButtonStriped.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    rSize = 5;
    c.begin();
    c.moveTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(rSize, h);
    c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
    c.lineTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.close();
    c.fill();
    var fillColor = "#ffffff";
    c.setAlpha("0.2");
    var stripeW = h * .5;
    c.setFillColor(fillColor);
    c.begin();
    c.moveTo(0, h * .75);
    c.lineTo(0, h * .25);
    c.lineTo(h * .75, h);
    c.lineTo(h * .25, h);
    c.close();
    c.fill();
    var end = false;
    var startX = stripeW * .5;
    while (!end) {
        c.begin();
        c.moveTo(startX, 0);
        if (startX + stripeW >= w) {
            c.lineTo(w, 0);
            c.lineTo(w, w - startX)
        } else {
            c.lineTo(startX + stripeW, 0);
            if (startX + stripeW + h > w) {
                c.lineTo(w, w - startX - stripeW);
                if (w - startX > h) {
                    c.lineTo(w, h);
                    c.lineTo(startX + h, h)
                } else
                    c.lineTo(w, w - startX)
            } else {
                c.lineTo(startX + stripeW + h, h);
                c.lineTo(startX + h, h)
            }
        }
        c.close();
        c.fill();
        startX = startX + 2 * stripeW;
        if (startX > w)
            end = true
    }
}
;
mxCellRenderer.registerShape(mxShapeBootstrapLeftButtonStriped.prototype.cst.LEFT_BUTTON_STRIPED, mxShapeBootstrapLeftButtonStriped);
function mxShapeBootstrapRoundedButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeBootstrapRoundedButton, mxShape);
mxShapeBootstrapRoundedButton.prototype.cst = {
    ROUNDED_BUTTON: "mxgraph.bootstrap.roundedButton"
};
mxShapeBootstrapRoundedButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    if (w > h) {
        var r = h * .5;
        c.begin();
        c.moveTo(w - r, 0);
        c.arcTo(r, r, 0, 0, 1, w - r, h);
        c.lineTo(r, h);
        c.arcTo(r, r, 0, 0, 1, r, 0);
        c.close();
        c.fillAndStroke()
    } else {
        var r = w * .5;
        c.begin();
        c.moveTo(0, h - r);
        c.arcTo(r, r, 0, 0, 0, w, h - r);
        c.lineTo(w, r);
        c.arcTo(r, r, 0, 0, 0, 0, r);
        c.close();
        c.fillAndStroke()
    }
}
;
mxCellRenderer.registerShape(mxShapeBootstrapRoundedButton.prototype.cst.ROUNDED_BUTTON, mxShapeBootstrapRoundedButton);
function mxShapeBootstrapArrow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeBootstrapArrow, mxShape);
mxShapeBootstrapArrow.prototype.cst = {
    ARROW: "mxgraph.bootstrap.arrow"
};
mxShapeBootstrapArrow.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(w, h * .5);
    c.moveTo(w * .9, 0);
    c.lineTo(w, h * .5);
    c.lineTo(w * .9, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeBootstrapArrow.prototype.cst.ARROW, mxShapeBootstrapArrow);
function mxShapeBootstrapTabTop(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeBootstrapTabTop, mxShape);
mxShapeBootstrapTabTop.prototype.cst = {
    TAB_TOP: "mxgraph.bootstrap.tabTop",
    R_SIZE: "rSize"
};
mxShapeBootstrapTabTop.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = parseInt(mxUtils.getValue(this.style, mxShapeBootstrapTopButton.prototype.cst.R_SIZE, "10"));
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    c.setStrokeColor(fillColor);
    c.begin();
    c.moveTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke();
    c.setStrokeColor(strokeColor);
    c.begin();
    c.moveTo(0, h);
    c.lineTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeBootstrapTabTop.prototype.cst.TAB_TOP, mxShapeBootstrapTabTop);
function mxShapeBootstrapImage(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeBootstrapImage, mxShape);
mxShapeBootstrapImage.prototype.cst = {
    IMAGE: "mxgraph.bootstrap.image",
    R_SIZE: "rSize"
};
mxShapeBootstrapImage.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = Math.max(0, parseInt(mxUtils.getValue(this.style, mxShapeBootstrapTopButton.prototype.cst.R_SIZE, "10")));
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    c.begin();
    c.moveTo(0, rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, rSize, 0);
    c.lineTo(w - rSize, 0);
    c.arcTo(rSize, rSize, 0, 0, 1, w, rSize);
    c.lineTo(w, h - rSize);
    c.arcTo(rSize, rSize, 0, 0, 1, w - rSize, h);
    c.lineTo(rSize, h);
    c.arcTo(rSize, rSize, 0, 0, 1, 0, h - rSize);
    c.close();
    c.stroke();
    var rsHalf = rSize * .5;
    c.translate(rsHalf, rsHalf);
    w = Math.max(0, w - rSize);
    h = Math.max(0, h - rSize);
    c.begin();
    c.moveTo(0, rsHalf);
    c.arcTo(rsHalf, rsHalf, 0, 0, 1, rsHalf, 0);
    c.lineTo(w - rsHalf, 0);
    c.arcTo(rsHalf, rsHalf, 0, 0, 1, w, rsHalf);
    c.lineTo(w, h - rsHalf);
    c.arcTo(rsHalf, rsHalf, 0, 0, 1, w - rsHalf, h);
    c.lineTo(rsHalf, h);
    c.arcTo(rsHalf, rsHalf, 0, 0, 1, 0, h - rsHalf);
    c.close();
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeBootstrapImage.prototype.cst.IMAGE, mxShapeBootstrapImage);
function mxShapeBootstrapCheckbox(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeBootstrapCheckbox, mxShape);
mxShapeBootstrapCheckbox.prototype.cst = {
    CHECKBOX: "mxgraph.bootstrap.checkbox"
};
mxShapeBootstrapCheckbox.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var rSize = 3;
    c.roundrect(0, 0, w, h, rSize, rSize);
    c.fillAndStroke();
    c.setStrokeWidth("3");
    c.begin();
    c.moveTo(w * .8, h * .2);
    c.lineTo(w * .4, h * .8);
    c.lineTo(w * .25, h * .6);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeBootstrapCheckbox.prototype.cst.CHECKBOX, mxShapeBootstrapCheckbox);
function mxShapeBootstrapRadioButton(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeBootstrapRadioButton, mxShape);
mxShapeBootstrapRadioButton.prototype.cst = {
    RADIO_BUTTON: "mxgraph.bootstrap.radioButton"
};
mxShapeBootstrapRadioButton.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    c.ellipse(0, 0, w, h);
    c.fillAndStroke();
    c.setFillColor(strokeColor);
    c.ellipse(w * .25, h * .25, w * .5, h * .5);
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeBootstrapRadioButton.prototype.cst.RADIO_BUTTON, mxShapeBootstrapRadioButton);
function mxShapeBootstrapHorLines(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeBootstrapHorLines, mxShape);
mxShapeBootstrapHorLines.prototype.cst = {
    HOR_LINES: "mxgraph.bootstrap.horLines"
};
mxShapeBootstrapHorLines.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.rect(0, 0, w, h);
    c.fill();
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.moveTo(0, h);
    c.lineTo(w, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeBootstrapHorLines.prototype.cst.HOR_LINES, mxShapeBootstrapHorLines);
function mxShapeBootstrapUserTwo(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeBootstrapUserTwo, mxShape);
mxShapeBootstrapUserTwo.prototype.cst = {
    USER2: "mxgraph.bootstrap.user2"
};
mxShapeBootstrapUserTwo.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.moveTo(0, h * .95);
    c.arcTo(w * .3, h * .3, 0, 0, 1, w * .02, h * .87);
    c.arcTo(w * .1, h * .1, 0, 0, 1, w * .08, h * .812);
    c.arcTo(w * 3, h * 3, 0, 0, 1, w * .29, h * .732);
    c.arcTo(w * .15, h * .15, 0, 0, 0, w * .385, h * .607);
    c.arcTo(w * .11, h * .11, 0, 0, 0, w * .355, h * .53);
    c.arcTo(w * .3, h * .3, 0, 0, 1, w * .305, h * .44);
    c.arcTo(w * .33, h * .38, 0, 0, 1, w * .312, h * .15);
    c.arcTo(w * .218, h * .218, 0, 0, 1, w * .688, h * .15);
    c.arcTo(w * .33, h * .38, 0, 0, 1, w * .693, h * .44);
    c.arcTo(w * .25, h * .25, 0, 0, 1, w * .645, h * .53);
    c.arcTo(w * .1, h * .1, 0, 0, 0, w * .612, h * .6);
    c.arcTo(w * .15, h * .15, 0, 0, 0, w * .7, h * .726);
    c.arcTo(w * 3, h * 3, 0, 0, 1, w * .92, h * .812);
    c.arcTo(w * .1, h * .1, 0, 0, 1, w * .97, h * .865);
    c.arcTo(w * .2, h * .2, 0, 0, 1, w * .995, h * .952);
    c.close();
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeBootstrapUserTwo.prototype.cst.USER2, mxShapeBootstrapUserTwo);
function mxShapeBootstrapRating(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeBootstrapRating, mxShape);
mxShapeBootstrapRating.prototype.cst = {
    RATING: "mxgraph.bootstrap.rating",
    RATING_STYLE: "ratingStyle",
    RATING_SCALE: "ratingScale",
    RATING_HEART: "heart",
    RATING_STAR: "star",
    EMPTY_FILL_COLOR: "emptyFillColor",
    GRADE: "grade"
};
mxShapeBootstrapRating.prototype.paintVertexShape = function(c, x, y, w, h) {
    var ratingStyle = mxUtils.getValue(this.style, mxShapeBootstrapRating.prototype.cst.RATING_STYLE, mxShapeBootstrapRating.prototype.cst.RATING_STAR);
    var grade = mxUtils.getValue(this.style, mxShapeBootstrapRating.prototype.cst.GRADE, "5");
    var ratingScale = mxUtils.getValue(this.style, mxShapeBootstrapRating.prototype.cst.RATING_SCALE, "10");
    c.translate(x, y);
    if (ratingStyle === mxShapeBootstrapRating.prototype.cst.RATING_STAR)
        for (var i = 0; i < grade; i++) {
            c.begin();
            c.moveTo(i * h * 1.2, .33 * h);
            c.lineTo(i * h * 1.2 + .364 * h, .33 * h);
            c.lineTo(i * h * 1.2 + .475 * h, 0);
            c.lineTo(i * h * 1.2 + .586 * h, .33 * h);
            c.lineTo(i * h * 1.2 + .95 * h, .33 * h);
            c.lineTo(i * h * 1.2 + .66 * h, .551 * h);
            c.lineTo(i * h * 1.2 + .775 * h, .9 * h);
            c.lineTo(i * h * 1.2 + .475 * h, .684 * h);
            c.lineTo(i * h * 1.2 + .175 * h, .9 * h);
            c.lineTo(i * h * 1.2 + .29 * h, .551 * h);
            c.close();
            c.fillAndStroke()
        }
    else if (ratingStyle === mxShapeBootstrapRating.prototype.cst.RATING_HEART)
        for (var i = 0; i < grade; i++) {
            c.begin();
            c.moveTo(i * h * 1.2 + h * .519, h * .947);
            c.curveTo(i * h * 1.2 + h * .558, h * .908, i * h * 1.5 + h * .778, h * .682, i * h * 1.5 + h * .916, h * .54);
            c.curveTo(i * h * 1.2 + h * 1.039, h * .414, i * h * 1.5 + h * 1.036, h * .229, i * h * 1.5 + h * .924, h * .115);
            c.curveTo(i * h * 1.2 + h * .812, 0, i * h * 1.5 + h * .631, 0, i * h * 1.5 + h * .519, h * .115);
            c.curveTo(i * h * 1.2 + h * .408, 0, i * h * 1.5 + h * .227, 0, i * h * 1.5 + h * .115, h * .115);
            c.curveTo(i * h * 1.2 + h * .03, h * .229, i * h * 1.5, h * .414, i * h * 1.5 + h * .123, h * .54);
            c.close();
            c.fillAndStroke()
        }
    var emptyFillColor = mxUtils.getValue(this.style, mxShapeBootstrapRating.prototype.cst.EMPTY_FILL_COLOR, "#ffffff");
    c.setFillColor(emptyFillColor);
    if (ratingStyle === mxShapeBootstrapRating.prototype.cst.RATING_STAR)
        for (var i = grade; i < ratingScale; i++) {
            c.begin();
            c.moveTo(i * h * 1.2, .33 * h);
            c.lineTo(i * h * 1.2 + .364 * h, .33 * h);
            c.lineTo(i * h * 1.2 + .475 * h, 0);
            c.lineTo(i * h * 1.2 + .586 * h, .33 * h);
            c.lineTo(i * h * 1.2 + .95 * h, .33 * h);
            c.lineTo(i * h * 1.2 + .66 * h, .551 * h);
            c.lineTo(i * h * 1.2 + .775 * h, .9 * h);
            c.lineTo(i * h * 1.2 + .475 * h, .684 * h);
            c.lineTo(i * h * 1.2 + .175 * h, .9 * h);
            c.lineTo(i * h * 1.2 + .29 * h, .551 * h);
            c.close();
            c.fillAndStroke()
        }
    else if (ratingStyle === mxShapeBootstrapRating.prototype.cst.RATING_HEART)
        for (var i = grade; i < ratingScale; i++) {
            c.begin();
            c.moveTo(i * h * 1.2 + h * .519, h * .947);
            c.curveTo(i * h * 1.2 + h * .558, h * .908, i * h * 1.5 + h * .778, h * .682, i * h * 1.5 + h * .916, h * .54);
            c.curveTo(i * h * 1.2 + h * 1.039, h * .414, i * h * 1.5 + h * 1.036, h * .229, i * h * 1.5 + h * .924, h * .115);
            c.curveTo(i * h * 1.2 + h * .812, 0, i * h * 1.5 + h * .631, 0, i * h * 1.5 + h * .519, h * .115);
            c.curveTo(i * h * 1.2 + h * .408, 0, i * h * 1.5 + h * .227, 0, i * h * 1.5 + h * .115, h * .115);
            c.curveTo(i * h * 1.2 + h * .03, h * .229, i * h * 1.5, h * .414, i * h * 1.5 + h * .123, h * .54);
            c.close();
            c.fillAndStroke()
        }
}
;
mxCellRenderer.registerShape(mxShapeBootstrapRating.prototype.cst.RATING, mxShapeBootstrapRating);
function mxShapeBoostrapAnchor(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds
}
mxUtils.extend(mxShapeBoostrapAnchor, mxShape);
mxShapeBoostrapAnchor.prototype.cst = {
    ANCHOR: "mxgraph.bootstrap.anchor"
};
mxShapeBoostrapAnchor.prototype.paintVertexShape = function(c, x, y, w, h) {}
;
mxCellRenderer.registerShape(mxShapeBoostrapAnchor.prototype.cst.ANCHOR, mxShapeBoostrapAnchor);
function mxCabinetsCabinet(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxCabinetsCabinet, mxShape);
mxCabinetsCabinet.prototype.cst = {
    HAS_STAND: "hasStand",
    CABINET: "mxgraph.cabinets.cabinet"
};
mxCabinetsCabinet.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h)
}
;
mxCabinetsCabinet.prototype.background = function(c, x, y, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxCabinetsCabinet.prototype.foreground = function(c, x, y, w, h) {
    var wallTh = 15;
    c.rect(0, 0, w, wallTh);
    c.stroke();
    c.begin();
    c.moveTo(wallTh, wallTh);
    c.lineTo(wallTh, h);
    c.moveTo(w - wallTh, wallTh);
    c.lineTo(w - wallTh, h);
    c.stroke();
    var hasStand = mxUtils.getValue(this.style, mxCabinetsCabinet.prototype.cst.HAS_STAND, "1");
    if (hasStand === 1) {
        c.rect(0, h - 40, w, 40);
        c.fillAndStroke()
    } else {
        c.rect(0, h - wallTh, w, wallTh);
        c.fillAndStroke()
    }
}
;
mxCellRenderer.registerShape(mxCabinetsCabinet.prototype.cst.CABINET, mxCabinetsCabinet);
function mxCabinetsCoverPlate(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxCabinetsCoverPlate, mxShape);
mxCabinetsCoverPlate.prototype.cst = {
    COVER_PLATE: "mxgraph.cabinets.coverPlate"
};
mxCabinetsCoverPlate.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, 0, 0, w, h);
    c.setShadow(false);
    this.foreground(c, 0, 0, w, h)
}
;
mxCabinetsCoverPlate.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.moveTo(10, h * .5 - 12.5);
    c.lineTo(10, h * .5 + 12.5);
    c.lineTo(w - 10, h * .5 + 12.5);
    c.lineTo(w - 10, h * .5 - 12.5);
    c.close();
    c.fillAndStroke()
}
;
mxCabinetsCoverPlate.prototype.foreground = function(c, x, y, w, h) {}
;
mxCellRenderer.registerShape(mxCabinetsCoverPlate.prototype.cst.COVER_PLATE, mxCabinetsCoverPlate);
function mxCabinetsDimension(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxCabinetsDimension, mxShape);
mxCabinetsDimension.prototype.cst = {
    DIMENSION: "mxgraph.cabinets.dimension"
};
mxCabinetsDimension.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h)
}
;
mxCabinetsDimension.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(0, 20);
    c.lineTo(w, 20);
    c.moveTo(10, 15);
    c.lineTo(0, 20);
    c.lineTo(10, 25);
    c.moveTo(w - 10, 15);
    c.lineTo(w, 20);
    c.lineTo(w - 10, 25);
    c.moveTo(0, 15);
    c.lineTo(0, h);
    c.moveTo(w, 15);
    c.lineTo(w, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxCabinetsDimension.prototype.cst.DIMENSION, mxCabinetsDimension);
function mxCabinetsDimensionBottom(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxCabinetsDimensionBottom, mxShape);
mxCabinetsDimensionBottom.prototype.cst = {
    DIMENSION: "mxgraph.cabinets.dimensionBottom"
};
mxCabinetsDimensionBottom.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h)
}
;
mxCabinetsDimensionBottom.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(0, h - 20);
    c.lineTo(w, h - 20);
    c.moveTo(10, h - 15);
    c.lineTo(0, h - 20);
    c.lineTo(10, h - 25);
    c.moveTo(w - 10, h - 15);
    c.lineTo(w, h - 20);
    c.lineTo(w - 10, h - 25);
    c.moveTo(0, h - 15);
    c.lineTo(0, 0);
    c.moveTo(w, h - 15);
    c.lineTo(w, 0);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxCabinetsDimensionBottom.prototype.cst.DIMENSION, mxCabinetsDimensionBottom);
function mxShapeEipMessageExpiration(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeEipMessageExpiration, mxShape);
mxShapeEipMessageExpiration.prototype.cst = {
    SHAPE_MESS_EXP: "mxgraph.eip.messExp"
};
mxShapeEipMessageExpiration.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h)
}
;
mxShapeEipMessageExpiration.prototype.background = function(c, x, y, w, h) {
    c.ellipse(0, 0, w, h);
    c.stroke();
    c.setStrokeColor("#808080");
    c.begin();
    c.moveTo(w * .5, h * .1);
    c.lineTo(w * .5, h * .5);
    c.lineTo(w * .6, h * .8);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeEipMessageExpiration.prototype.cst.SHAPE_MESS_EXP, mxShapeEipMessageExpiration);
function mxShapeEipReturnAddress(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeEipReturnAddress, mxShape);
mxShapeEipReturnAddress.prototype.cst = {
    SHAPE_RET_ADDR: "mxgraph.eip.retAddr"
};
mxShapeEipReturnAddress.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeEipReturnAddress.prototype.background = function(c, x, y, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeEipReturnAddress.prototype.foreground = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(w * .05, h * .11);
    c.lineTo(w * .25, h * .11);
    c.moveTo(w * .05, h * .18);
    c.lineTo(w * .25, h * .18);
    c.moveTo(w * .05, h * .25);
    c.lineTo(w * .25, h * .25);
    c.setStrokeWidth(2);
    c.moveTo(w * .3, h * .63);
    c.lineTo(w * .8, h * .63);
    c.moveTo(w * .3, h * .72);
    c.lineTo(w * .8, h * .72);
    c.moveTo(w * .3, h * .8);
    c.lineTo(w * .8, h * .8);
    c.stroke();
    c.setFillColor("#EDEDED");
    c.rect(w * .8, h * .1, w * .12, h * .19);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeEipReturnAddress.prototype.cst.SHAPE_RET_ADDR, mxShapeEipReturnAddress);
function mxShapeEipAnchor(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeEipAnchor, mxShape);
mxShapeEipAnchor.prototype.cst = {
    SHAPE_ANCHOR: "mxgraph.eip.anchor"
};
mxShapeEipAnchor.prototype.paintVertexShape = function(c, x, y, w, h) {}
;
mxCellRenderer.registerShape(mxShapeEipAnchor.prototype.cst.SHAPE_ANCHOR, mxShapeEipAnchor);
function mxShapeEipMessageChannel(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeEipMessageChannel, mxShape);
mxShapeEipMessageChannel.prototype.cst = {
    SHAPE_MESSAGE_CHANNEL: "mxgraph.eip.messageChannel"
};
mxShapeEipMessageChannel.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeEipMessageChannel.prototype.background = function(c, x, y, w, h) {
    c.setGradient("#e6e6e6", "#808080", 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.begin();
    c.moveTo(8, h * .5 + 10);
    c.arcTo(12, 12, 0, 0, 1, 8, h * .5 - 10);
    c.lineTo(w - 8, h * .5 - 10);
    c.arcTo(12, 12, 0, 0, 1, w - 8, h * .5 + 10);
    c.close();
    c.fillAndStroke()
}
;
mxShapeEipMessageChannel.prototype.foreground = function(c, x, y, w, h) {
    c.setFillColor("#e6e6e6");
    c.begin();
    c.moveTo(w - 8, h * .5 - 10);
    c.arcTo(12, 12, 0, 0, 1, w - 8, h * .5 + 10);
    c.arcTo(12, 12, 0, 0, 1, w - 8, h * .5 - 10);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeEipMessageChannel.prototype.cst.SHAPE_MESSAGE_CHANNEL, mxShapeEipMessageChannel);
mxShapeEipMessageChannel.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(.05,0),true), new mxConnectionConstraint(new mxPoint(.1,0),true), new mxConnectionConstraint(new mxPoint(.15,0),true), new mxConnectionConstraint(new mxPoint(.2,0),true), new mxConnectionConstraint(new mxPoint(.25,0),true), new mxConnectionConstraint(new mxPoint(.3,0),true), new mxConnectionConstraint(new mxPoint(.35,0),true), new mxConnectionConstraint(new mxPoint(.4,0),true), new mxConnectionConstraint(new mxPoint(.45,0),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.55,0),true), new mxConnectionConstraint(new mxPoint(.6,0),true), new mxConnectionConstraint(new mxPoint(.65,0),true), new mxConnectionConstraint(new mxPoint(.7,0),true), new mxConnectionConstraint(new mxPoint(.75,0),true), new mxConnectionConstraint(new mxPoint(.8,0),true), new mxConnectionConstraint(new mxPoint(.85,0),true), new mxConnectionConstraint(new mxPoint(.9,0),true), new mxConnectionConstraint(new mxPoint(.95,0),true), new mxConnectionConstraint(new mxPoint(.05,1),true), new mxConnectionConstraint(new mxPoint(.1,1),true), new mxConnectionConstraint(new mxPoint(.15,1),true), new mxConnectionConstraint(new mxPoint(.2,1),true), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.3,1),true), new mxConnectionConstraint(new mxPoint(.35,1),true), new mxConnectionConstraint(new mxPoint(.4,1),true), new mxConnectionConstraint(new mxPoint(.45,1),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(.55,1),true), new mxConnectionConstraint(new mxPoint(.6,1),true), new mxConnectionConstraint(new mxPoint(.65,1),true), new mxConnectionConstraint(new mxPoint(.7,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true), new mxConnectionConstraint(new mxPoint(.8,1),true), new mxConnectionConstraint(new mxPoint(.85,1),true), new mxConnectionConstraint(new mxPoint(.9,1),true), new mxConnectionConstraint(new mxPoint(.95,1),true)];
function mxShapeEipDatatypeChannel(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeEipDatatypeChannel, mxShape);
mxShapeEipDatatypeChannel.prototype.cst = {
    SHAPE_DATATYPE_CHANNEL: "mxgraph.eip.dataChannel"
};
mxShapeEipDatatypeChannel.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeEipDatatypeChannel.prototype.background = function(c, x, y, w, h) {
    c.setGradient("#e6e6e6", "#808080", 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.begin();
    c.moveTo(8, h * .5 + 10);
    c.arcTo(12, 12, 0, 0, 1, 8, h * .5 - 10);
    c.lineTo(w - 8, h * .5 - 10);
    c.arcTo(12, 12, 0, 0, 1, w - 8, h * .5 + 10);
    c.close();
    c.fillAndStroke()
}
;
mxShapeEipDatatypeChannel.prototype.foreground = function(c, x, y, w, h) {
    c.setFillColor("#e6e6e6");
    c.begin();
    c.moveTo(w - 8, h * .5 - 10);
    c.arcTo(12, 12, 0, 0, 1, w - 8, h * .5 + 10);
    c.arcTo(12, 12, 0, 0, 1, w - 8, h * .5 - 10);
    c.fillAndStroke();
    c.setFillColor("#fffbc0");
    c.setStrokeWidth("1");
    for (var i = 1; i * 20 + 10 < w - 14; i++) {
        c.rect(i * 20, h * .5 - 5, 10, 10);
        c.fillAndStroke()
    }
}
;
mxCellRenderer.registerShape(mxShapeEipDatatypeChannel.prototype.cst.SHAPE_DATATYPE_CHANNEL, mxShapeEipDatatypeChannel);
mxShapeEipDatatypeChannel.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(.05,0),true), new mxConnectionConstraint(new mxPoint(.1,0),true), new mxConnectionConstraint(new mxPoint(.15,0),true), new mxConnectionConstraint(new mxPoint(.2,0),true), new mxConnectionConstraint(new mxPoint(.25,0),true), new mxConnectionConstraint(new mxPoint(.3,0),true), new mxConnectionConstraint(new mxPoint(.35,0),true), new mxConnectionConstraint(new mxPoint(.4,0),true), new mxConnectionConstraint(new mxPoint(.45,0),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.55,0),true), new mxConnectionConstraint(new mxPoint(.6,0),true), new mxConnectionConstraint(new mxPoint(.65,0),true), new mxConnectionConstraint(new mxPoint(.7,0),true), new mxConnectionConstraint(new mxPoint(.75,0),true), new mxConnectionConstraint(new mxPoint(.8,0),true), new mxConnectionConstraint(new mxPoint(.85,0),true), new mxConnectionConstraint(new mxPoint(.9,0),true), new mxConnectionConstraint(new mxPoint(.95,0),true), new mxConnectionConstraint(new mxPoint(.05,1),true), new mxConnectionConstraint(new mxPoint(.1,1),true), new mxConnectionConstraint(new mxPoint(.15,1),true), new mxConnectionConstraint(new mxPoint(.2,1),true), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.3,1),true), new mxConnectionConstraint(new mxPoint(.35,1),true), new mxConnectionConstraint(new mxPoint(.4,1),true), new mxConnectionConstraint(new mxPoint(.45,1),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(.55,1),true), new mxConnectionConstraint(new mxPoint(.6,1),true), new mxConnectionConstraint(new mxPoint(.65,1),true), new mxConnectionConstraint(new mxPoint(.7,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true), new mxConnectionConstraint(new mxPoint(.8,1),true), new mxConnectionConstraint(new mxPoint(.85,1),true), new mxConnectionConstraint(new mxPoint(.9,1),true), new mxConnectionConstraint(new mxPoint(.95,1),true)];
function mxShapeEipDeadLetterChannel(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeEipDeadLetterChannel, mxShape);
mxShapeEipDeadLetterChannel.prototype.cst = {
    SHAPE_DEAD_LETTER_CHANNEL: "mxgraph.eip.deadLetterChannel"
};
mxShapeEipDeadLetterChannel.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeEipDeadLetterChannel.prototype.background = function(c, x, y, w, h) {
    c.setGradient("#e6e6e6", "#808080", 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.begin();
    c.moveTo(8, h * .5 + 10);
    c.arcTo(12, 12, 0, 0, 1, 8, h * .5 - 10);
    c.lineTo(w - 8, h * .5 - 10);
    c.arcTo(12, 12, 0, 0, 1, w - 8, h * .5 + 10);
    c.close();
    c.fillAndStroke()
}
;
mxShapeEipDeadLetterChannel.prototype.foreground = function(c, x, y, w, h) {
    c.setFillColor("#e6e6e6");
    c.begin();
    c.moveTo(w - 8, h * .5 - 10);
    c.arcTo(12, 12, 0, 0, 1, w - 8, h * .5 + 10);
    c.arcTo(12, 12, 0, 0, 1, w - 8, h * .5 - 10);
    c.fillAndStroke();
    c.setFillColor("#ff0000");
    c.setStrokeWidth("1");
    c.begin();
    c.moveTo(w * .5 - 6, h * .5 - 3);
    c.lineTo(w * .5 - 3, h * .5 - 6);
    c.lineTo(w * .5 + 3, h * .5 - 6);
    c.lineTo(w * .5 + 6, h * .5 - 3);
    c.lineTo(w * .5 + 6, h * .5 + 3);
    c.lineTo(w * .5 + 3, h * .5 + 6);
    c.lineTo(w * .5 - 3, h * .5 + 6);
    c.lineTo(w * .5 - 6, h * .5 + 3);
    c.close();
    c.fillAndStroke();
    c.setStrokeWidth("2");
    c.setStrokeColor("#ffffff");
    c.begin();
    c.moveTo(w * .5 - 4, h * .5);
    c.lineTo(w * .5 + 4, h * .5);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeEipDeadLetterChannel.prototype.cst.SHAPE_DEAD_LETTER_CHANNEL, mxShapeEipDeadLetterChannel);
mxShapeEipDeadLetterChannel.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(.05,0),true), new mxConnectionConstraint(new mxPoint(.1,0),true), new mxConnectionConstraint(new mxPoint(.15,0),true), new mxConnectionConstraint(new mxPoint(.2,0),true), new mxConnectionConstraint(new mxPoint(.25,0),true), new mxConnectionConstraint(new mxPoint(.3,0),true), new mxConnectionConstraint(new mxPoint(.35,0),true), new mxConnectionConstraint(new mxPoint(.4,0),true), new mxConnectionConstraint(new mxPoint(.45,0),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.55,0),true), new mxConnectionConstraint(new mxPoint(.6,0),true), new mxConnectionConstraint(new mxPoint(.65,0),true), new mxConnectionConstraint(new mxPoint(.7,0),true), new mxConnectionConstraint(new mxPoint(.75,0),true), new mxConnectionConstraint(new mxPoint(.8,0),true), new mxConnectionConstraint(new mxPoint(.85,0),true), new mxConnectionConstraint(new mxPoint(.9,0),true), new mxConnectionConstraint(new mxPoint(.95,0),true), new mxConnectionConstraint(new mxPoint(.05,1),true), new mxConnectionConstraint(new mxPoint(.1,1),true), new mxConnectionConstraint(new mxPoint(.15,1),true), new mxConnectionConstraint(new mxPoint(.2,1),true), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.3,1),true), new mxConnectionConstraint(new mxPoint(.35,1),true), new mxConnectionConstraint(new mxPoint(.4,1),true), new mxConnectionConstraint(new mxPoint(.45,1),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(.55,1),true), new mxConnectionConstraint(new mxPoint(.6,1),true), new mxConnectionConstraint(new mxPoint(.65,1),true), new mxConnectionConstraint(new mxPoint(.7,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true), new mxConnectionConstraint(new mxPoint(.8,1),true), new mxConnectionConstraint(new mxPoint(.85,1),true), new mxConnectionConstraint(new mxPoint(.9,1),true), new mxConnectionConstraint(new mxPoint(.95,1),true)];
function mxShapeEipInvalidMessageChannel(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeEipInvalidMessageChannel, mxShape);
mxShapeEipInvalidMessageChannel.prototype.cst = {
    SHAPE_INVALID_MESSAGE_CHANNEL: "mxgraph.eip.invalidMessageChannel"
};
mxShapeEipInvalidMessageChannel.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeEipInvalidMessageChannel.prototype.background = function(c, x, y, w, h) {
    c.setGradient("#e6e6e6", "#808080", 0, 0, w, h, mxConstants.DIRECTION_SOUTH, 1, 1);
    c.begin();
    c.moveTo(8, h * .5 + 10);
    c.arcTo(12, 12, 0, 0, 1, 8, h * .5 - 10);
    c.lineTo(w - 8, h * .5 - 10);
    c.arcTo(12, 12, 0, 0, 1, w - 8, h * .5 + 10);
    c.close();
    c.fillAndStroke()
}
;
mxShapeEipInvalidMessageChannel.prototype.foreground = function(c, x, y, w, h) {
    c.setFillColor("#e6e6e6");
    c.begin();
    c.moveTo(w - 8, h * .5 - 10);
    c.arcTo(12, 12, 0, 0, 1, w - 8, h * .5 + 10);
    c.arcTo(12, 12, 0, 0, 1, w - 8, h * .5 - 10);
    c.fillAndStroke();
    c.setFillColor("#ffe040");
    c.setStrokeWidth("1");
    c.begin();
    c.moveTo(w * .5 - 6, h * .5 + 5);
    c.lineTo(w * .5, h * .5 - 5);
    c.lineTo(w * .5 + 6, h * .5 + 5);
    c.close();
    c.fillAndStroke();
    c.setStrokeWidth("1");
    c.begin();
    c.moveTo(w * .5, h * .5 - 2);
    c.lineTo(w * .5, h * .5 + 2);
    c.moveTo(w * .5, h * .5 + 3);
    c.lineTo(w * .5, h * .5 + 4);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeEipInvalidMessageChannel.prototype.cst.SHAPE_INVALID_MESSAGE_CHANNEL, mxShapeEipInvalidMessageChannel);
mxShapeEipInvalidMessageChannel.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(.05,0),true), new mxConnectionConstraint(new mxPoint(.1,0),true), new mxConnectionConstraint(new mxPoint(.15,0),true), new mxConnectionConstraint(new mxPoint(.2,0),true), new mxConnectionConstraint(new mxPoint(.25,0),true), new mxConnectionConstraint(new mxPoint(.3,0),true), new mxConnectionConstraint(new mxPoint(.35,0),true), new mxConnectionConstraint(new mxPoint(.4,0),true), new mxConnectionConstraint(new mxPoint(.45,0),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.55,0),true), new mxConnectionConstraint(new mxPoint(.6,0),true), new mxConnectionConstraint(new mxPoint(.65,0),true), new mxConnectionConstraint(new mxPoint(.7,0),true), new mxConnectionConstraint(new mxPoint(.75,0),true), new mxConnectionConstraint(new mxPoint(.8,0),true), new mxConnectionConstraint(new mxPoint(.85,0),true), new mxConnectionConstraint(new mxPoint(.9,0),true), new mxConnectionConstraint(new mxPoint(.95,0),true), new mxConnectionConstraint(new mxPoint(.05,1),true), new mxConnectionConstraint(new mxPoint(.1,1),true), new mxConnectionConstraint(new mxPoint(.15,1),true), new mxConnectionConstraint(new mxPoint(.2,1),true), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.3,1),true), new mxConnectionConstraint(new mxPoint(.35,1),true), new mxConnectionConstraint(new mxPoint(.4,1),true), new mxConnectionConstraint(new mxPoint(.45,1),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(.55,1),true), new mxConnectionConstraint(new mxPoint(.6,1),true), new mxConnectionConstraint(new mxPoint(.65,1),true), new mxConnectionConstraint(new mxPoint(.7,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true), new mxConnectionConstraint(new mxPoint(.8,1),true), new mxConnectionConstraint(new mxPoint(.85,1),true), new mxConnectionConstraint(new mxPoint(.9,1),true), new mxConnectionConstraint(new mxPoint(.95,1),true)];
function mxShapeElectricalTestPoint(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeElectricalTestPoint, mxShape);
mxShapeElectricalTestPoint.prototype.cst = {
    SHAPE_TEST_POINT: "mxgraph.electrical.transmission.testPoint"
};
mxShapeElectricalTestPoint.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    var size = Math.min(w, h);
    c.setFillColor(strokeColor);
    c.begin();
    c.ellipse(w * .5 - size / 2, 0, size, size);
    c.fillAndStroke();
    if (h > w) {
        c.begin();
        c.moveTo(w * .5, size);
        c.lineTo(w * .5, h);
        c.stroke()
    }
}
;
mxCellRenderer.registerShape(mxShapeElectricalTestPoint.prototype.cst.SHAPE_TEST_POINT, mxShapeElectricalTestPoint);
mxShapeElectricalTestPoint.prototype.constraints = [new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.5,1),true)];
function mxShapeElectricalStraightBus(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeElectricalStraightBus, mxShape);
mxShapeElectricalStraightBus.prototype.cst = {
    SHAPE_STRAIGHT_BUS: "mxgraph.electrical.transmission.straightBus"
};
mxShapeElectricalStraightBus.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var size = Math.min(w, h);
    var x1 = w * .2;
    var y1 = 0;
    if (w > h)
        y1 = h * .5;
    else
        y1 = w / 2;
    c.begin();
    c.moveTo(w - x1, 0);
    c.lineTo(w - x1, h - y1);
    c.lineTo(w, h - y1);
    c.lineTo(w * .5, h);
    c.lineTo(0, h - y1);
    c.lineTo(x1, h - y1);
    c.lineTo(x1, 0);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeElectricalStraightBus.prototype.cst.SHAPE_STRAIGHT_BUS, mxShapeElectricalStraightBus);
mxShapeElectricalStraightBus.prototype.constraints = [new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.5,1),true)];
function mxShapeElectricalTwoLineBusElbow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.notch = 0
}
mxUtils.extend(mxShapeElectricalTwoLineBusElbow, mxShape);
mxShapeElectricalTwoLineBusElbow.prototype.cst = {
    SHAPE_TWO_LINE_BUS_ELBOW: "mxgraph.electrical.transmission.twoLineBusElbow"
};
mxShapeElectricalTwoLineBusElbow.prototype.paintVertexShape = function(c, x, y, w, h) {
    var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "notch", this.notch))));
    c.translate(x, y);
    c.begin();
    c.moveTo(0, h);
    c.lineTo(w, h);
    c.lineTo(w, 0);
    c.stroke();
    var wn = Math.min(w, notch);
    var hn = Math.min(h, notch);
    c.begin();
    c.moveTo(0, h - hn);
    c.lineTo(w - wn, h - hn);
    c.lineTo(w - wn, 0);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeElectricalTwoLineBusElbow.prototype.cst.SHAPE_TWO_LINE_BUS_ELBOW, mxShapeElectricalTwoLineBusElbow);
mxShapeElectricalTwoLineBusElbow.prototype.constraints = null;
Graph.handleFactory[mxShapeElectricalTwoLineBusElbow.prototype.cst.SHAPE_TWO_LINE_BUS_ELBOW] = function(state) {
    var handles = [Graph.createHandle(state, ["notch"], function(bounds) {
        var notch = Math.max(Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch))), 0);
        return new mxPoint(bounds.x + bounds.width / 4,bounds.y + bounds.height - notch)
    }, function(bounds, pt) {
        this.state.style["notch"] = Math.round(.2 * Math.max(0, bounds.width - pt.y + bounds.y)) / .2
    })];
    return handles
}
;
function mxShapeElectricalThreeLineBusElbow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.notch = 0
}
mxUtils.extend(mxShapeElectricalThreeLineBusElbow, mxShape);
mxShapeElectricalThreeLineBusElbow.prototype.cst = {
    SHAPE_THREE_LINE_BUS_ELBOW: "mxgraph.electrical.transmission.threeLineBusElbow"
};
mxShapeElectricalThreeLineBusElbow.prototype.paintVertexShape = function(c, x, y, w, h) {
    var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "notch", this.notch))));
    c.translate(x, y);
    c.begin();
    c.moveTo(0, h);
    c.lineTo(w, h);
    c.lineTo(w, 0);
    c.stroke();
    var wn = Math.min(w, notch);
    var hn = Math.min(h, notch);
    c.begin();
    c.moveTo(0, h - hn);
    c.lineTo(w - wn, h - hn);
    c.lineTo(w - wn, 0);
    c.stroke();
    c.begin();
    c.moveTo(0, h - hn / 2);
    c.lineTo(w - wn / 2, h - hn / 2);
    c.lineTo(w - wn / 2, 0);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeElectricalThreeLineBusElbow.prototype.cst.SHAPE_THREE_LINE_BUS_ELBOW, mxShapeElectricalThreeLineBusElbow);
mxShapeElectricalThreeLineBusElbow.prototype.constraints = null;
Graph.handleFactory[mxShapeElectricalThreeLineBusElbow.prototype.cst.SHAPE_THREE_LINE_BUS_ELBOW] = function(state) {
    var handles = [Graph.createHandle(state, ["notch"], function(bounds) {
        var notch = Math.max(Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch))), 0);
        return new mxPoint(bounds.x + bounds.width / 4,bounds.y + bounds.height - notch)
    }, function(bounds, pt) {
        this.state.style["notch"] = Math.round(.2 * Math.max(0, bounds.width - pt.y + bounds.y)) / .2
    })];
    return handles
}
;
function mxShapeElectricalFourLineBusElbow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.notch = 0
}
mxUtils.extend(mxShapeElectricalFourLineBusElbow, mxShape);
mxShapeElectricalFourLineBusElbow.prototype.cst = {
    SHAPE_FOUR_LINE_BUS_ELBOW: "mxgraph.electrical.transmission.fourLineBusElbow"
};
mxShapeElectricalFourLineBusElbow.prototype.paintVertexShape = function(c, x, y, w, h) {
    var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "notch", this.notch))));
    c.translate(x, y);
    c.begin();
    c.moveTo(0, h);
    c.lineTo(w, h);
    c.lineTo(w, 0);
    c.stroke();
    var wn = Math.min(w, notch);
    var hn = Math.min(h, notch);
    c.begin();
    c.moveTo(0, h - hn);
    c.lineTo(w - wn, h - hn);
    c.lineTo(w - wn, 0);
    c.stroke();
    c.begin();
    c.moveTo(0, h - hn / 3);
    c.lineTo(w - wn / 3, h - hn / 3);
    c.lineTo(w - wn / 3, 0);
    c.stroke();
    c.begin();
    c.moveTo(0, h - hn * 2 / 3);
    c.lineTo(w - wn * 2 / 3, h - hn * 2 / 3);
    c.lineTo(w - wn * 2 / 3, 0);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeElectricalFourLineBusElbow.prototype.cst.SHAPE_FOUR_LINE_BUS_ELBOW, mxShapeElectricalFourLineBusElbow);
mxShapeElectricalFourLineBusElbow.prototype.constraints = null;
Graph.handleFactory[mxShapeElectricalFourLineBusElbow.prototype.cst.SHAPE_FOUR_LINE_BUS_ELBOW] = function(state) {
    var handles = [Graph.createHandle(state, ["notch"], function(bounds) {
        var notch = Math.max(Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch))), 0);
        return new mxPoint(bounds.x + bounds.width / 4,bounds.y + bounds.height - notch)
    }, function(bounds, pt) {
        this.state.style["notch"] = Math.round(.2 * Math.max(0, bounds.width - pt.y + bounds.y)) / .2
    })];
    return handles
}
;
function mxShapeElectricalEightLineBusElbow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.notch = 0
}
mxUtils.extend(mxShapeElectricalEightLineBusElbow, mxShape);
mxShapeElectricalEightLineBusElbow.prototype.cst = {
    SHAPE_EIGHT_LINE_BUS_ELBOW: "mxgraph.electrical.transmission.eightLineBusElbow"
};
mxShapeElectricalEightLineBusElbow.prototype.paintVertexShape = function(c, x, y, w, h) {
    var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "notch", this.notch))));
    c.translate(x, y);
    c.begin();
    c.moveTo(0, h);
    c.lineTo(w, h);
    c.lineTo(w, 0);
    c.stroke();
    var wn = Math.min(w, notch);
    var hn = Math.min(h, notch);
    c.begin();
    c.moveTo(0, h - hn);
    c.lineTo(w - wn, h - hn);
    c.lineTo(w - wn, 0);
    c.stroke();
    c.begin();
    c.moveTo(0, h - hn / 7);
    c.lineTo(w - wn / 7, h - hn / 7);
    c.lineTo(w - wn / 7, 0);
    c.stroke();
    c.begin();
    c.moveTo(0, h - hn * 2 / 7);
    c.lineTo(w - wn * 2 / 7, h - hn * 2 / 7);
    c.lineTo(w - wn * 2 / 7, 0);
    c.stroke();
    c.begin();
    c.moveTo(0, h - hn * 3 / 7);
    c.lineTo(w - wn * 3 / 7, h - hn * 3 / 7);
    c.lineTo(w - wn * 3 / 7, 0);
    c.stroke();
    c.begin();
    c.moveTo(0, h - hn * 4 / 7);
    c.lineTo(w - wn * 4 / 7, h - hn * 4 / 7);
    c.lineTo(w - wn * 4 / 7, 0);
    c.stroke();
    c.begin();
    c.moveTo(0, h - hn * 5 / 7);
    c.lineTo(w - wn * 5 / 7, h - hn * 5 / 7);
    c.lineTo(w - wn * 5 / 7, 0);
    c.stroke();
    c.begin();
    c.moveTo(0, h - hn * 6 / 7);
    c.lineTo(w - wn * 6 / 7, h - hn * 6 / 7);
    c.lineTo(w - wn * 6 / 7, 0);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeElectricalEightLineBusElbow.prototype.cst.SHAPE_EIGHT_LINE_BUS_ELBOW, mxShapeElectricalEightLineBusElbow);
mxShapeElectricalEightLineBusElbow.prototype.constraints = null;
Graph.handleFactory[mxShapeElectricalEightLineBusElbow.prototype.cst.SHAPE_EIGHT_LINE_BUS_ELBOW] = function(state) {
    var handles = [Graph.createHandle(state, ["notch"], function(bounds) {
        var notch = Math.max(Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch))), 0);
        return new mxPoint(bounds.x + bounds.width / 4,bounds.y + bounds.height - notch)
    }, function(bounds, pt) {
        this.state.style["notch"] = Math.round(.2 * Math.max(0, bounds.width - pt.y + bounds.y)) / .2
    })];
    return handles
}
;
function mxFloorplanWall(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxFloorplanWall, mxShape);
mxFloorplanWall.prototype.cst = {
    WALL: "mxgraph.floorplan.wall",
    WALL_THICKNESS: "wallThickness"
};
mxFloorplanWall.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h)
}
;
mxFloorplanWall.prototype.background = function(c, x, y, w, h) {
    var wallTh = parseFloat(mxUtils.getValue(this.style, mxFloorplanWall.prototype.cst.WALL_THICKNESS, "10"));
    c.rect(0, h * .5 - wallTh * .5, w, wallTh);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxFloorplanWall.prototype.cst.WALL, mxFloorplanWall);
function mxFloorplanWallCorner(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxFloorplanWallCorner, mxShape);
mxFloorplanWallCorner.prototype.cst = {
    WALL_CORNER: "mxgraph.floorplan.wallCorner",
    WALL_THICKNESS: "wallThickness"
};
mxFloorplanWallCorner.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h)
}
;
mxFloorplanWallCorner.prototype.background = function(c, x, y, w, h) {
    var wallTh = parseFloat(mxUtils.getValue(this.style, mxFloorplanWallCorner.prototype.cst.WALL_THICKNESS, "10"));
    c.begin();
    c.moveTo(0, h);
    c.lineTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, wallTh);
    c.lineTo(wallTh, wallTh);
    c.lineTo(wallTh, h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxFloorplanWallCorner.prototype.cst.WALL_CORNER, mxFloorplanWallCorner);
function mxFloorplanWallU(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxFloorplanWallU, mxShape);
mxFloorplanWallU.prototype.cst = {
    WALL_U: "mxgraph.floorplan.wallU",
    WALL_THICKNESS: "wallThickness"
};
mxFloorplanWallU.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h)
}
;
mxFloorplanWallU.prototype.background = function(c, x, y, w, h) {
    var wallTh = parseFloat(mxUtils.getValue(this.style, mxFloorplanWallU.prototype.cst.WALL_THICKNESS, "10"));
    c.begin();
    c.moveTo(0, h);
    c.lineTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(w - wallTh, h);
    c.lineTo(w - wallTh, wallTh);
    c.lineTo(wallTh, wallTh);
    c.lineTo(wallTh, h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxFloorplanWallU.prototype.cst.WALL_U, mxFloorplanWallU);
function mxFloorplanRoom(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxFloorplanRoom, mxShape);
mxFloorplanRoom.prototype.cst = {
    ROOM: "mxgraph.floorplan.room",
    WALL_THICKNESS: "wallThickness"
};
mxFloorplanRoom.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h)
}
;
mxFloorplanRoom.prototype.background = function(c, x, y, w, h) {
    var wallTh = parseFloat(mxUtils.getValue(this.style, mxFloorplanRoom.prototype.cst.WALL_THICKNESS, "10"));
    c.begin();
    c.moveTo(0, h);
    c.lineTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h);
    c.close();
    c.moveTo(wallTh, wallTh);
    c.lineTo(wallTh, h - wallTh);
    c.lineTo(w - wallTh, h - wallTh);
    c.lineTo(w - wallTh, wallTh);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxFloorplanRoom.prototype.cst.ROOM, mxFloorplanRoom);
function mxFloorplanWindow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxFloorplanWindow, mxShape);
mxFloorplanWindow.prototype.cst = {
    WINDOW: "mxgraph.floorplan.window",
    WALL_THICKNESS: "wallThickness"
};
mxFloorplanWindow.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h)
}
;
mxFloorplanWindow.prototype.background = function(c, x, y, w, h) {
    var wallTh = parseFloat(mxUtils.getValue(this.style, mxFloorplanWindow.prototype.cst.WALL_THICKNESS, "10"));
    c.rect(0, h * .5 - wallTh * .5, w, wallTh);
    c.fillAndStroke();
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(w, h * .5);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxFloorplanWindow.prototype.cst.WINDOW, mxFloorplanWindow);
function mxFloorplanDimension(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxFloorplanDimension, mxShape);
mxFloorplanDimension.prototype.cst = {
    DIMENSION: "mxgraph.floorplan.dimension"
};
mxFloorplanDimension.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h)
}
;
mxFloorplanDimension.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(0, 20);
    c.lineTo(w, 20);
    c.moveTo(10, 15);
    c.lineTo(0, 20);
    c.lineTo(10, 25);
    c.moveTo(w - 10, 15);
    c.lineTo(w, 20);
    c.lineTo(w - 10, 25);
    c.moveTo(0, 15);
    c.lineTo(0, h);
    c.moveTo(w, 15);
    c.lineTo(w, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxFloorplanDimension.prototype.cst.DIMENSION, mxFloorplanDimension);
function mxFloorplanDimensionBottom(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxFloorplanDimensionBottom, mxShape);
mxFloorplanDimensionBottom.prototype.cst = {
    DIMENSION: "mxgraph.floorplan.dimensionBottom"
};
mxFloorplanDimensionBottom.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h)
}
;
mxFloorplanDimensionBottom.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(0, h - 20);
    c.lineTo(w, h - 20);
    c.moveTo(10, h - 15);
    c.lineTo(0, h - 20);
    c.lineTo(10, h - 25);
    c.moveTo(w - 10, h - 15);
    c.lineTo(w, h - 20);
    c.lineTo(w - 10, h - 25);
    c.moveTo(0, h - 15);
    c.lineTo(0, 0);
    c.moveTo(w, h - 15);
    c.lineTo(w, 0);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxFloorplanDimensionBottom.prototype.cst.DIMENSION, mxFloorplanDimensionBottom);
function mxFloorplanStairs(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxFloorplanStairs, mxShape);
mxFloorplanStairs.prototype.cst = {
    STAIRS: "mxgraph.floorplan.stairs"
};
mxFloorplanStairs.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var minW = Math.max(w, 50);
    this.background(c, x, y, minW, h)
}
;
mxFloorplanStairs.prototype.background = function(c, x, y, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke();
    var step = 25;
    c.setShadow(false);
    c.begin();
    for (var i = 25; i < w; i = i + step) {
        c.moveTo(i, 0);
        c.lineTo(i, h)
    }
    c.stroke();
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(w, h * .5);
    c.moveTo(w - step, 0);
    c.lineTo(w, h * .5);
    c.lineTo(w - step, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxFloorplanStairs.prototype.cst.STAIRS, mxFloorplanStairs);
function mxFloorplanStairsRest(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxFloorplanStairsRest, mxShape);
mxFloorplanStairsRest.prototype.cst = {
    STAIRS: "mxgraph.floorplan.stairsRest"
};
mxFloorplanStairsRest.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var minW = Math.max(w, 50, h);
    var minH = Math.min(w, h);
    this.background(c, x, y, minW, h)
}
;
mxFloorplanStairsRest.prototype.background = function(c, x, y, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke();
    var step = 25;
    c.setShadow(false);
    c.begin();
    for (var i = 25; i < w - h * .5; i = i + step) {
        c.moveTo(i, 0);
        c.lineTo(i, h)
    }
    c.stroke();
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(w, h * .5);
    c.moveTo(w, 0);
    c.lineTo(w - h * .5, h * .5);
    c.lineTo(w, h);
    c.moveTo(w - h * .5, 0);
    c.lineTo(w - h * .5, h);
    c.moveTo(0, h * .5);
    c.lineTo(w, h * .5);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxFloorplanStairsRest.prototype.cst.STAIRS, mxFloorplanStairsRest);
function mxFloorplanStairsRest(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxFloorplanStairsRest, mxShape);
mxFloorplanStairsRest.prototype.cst = {
    STAIRS: "mxgraph.floorplan.stairsRest"
};
mxFloorplanStairsRest.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var minW = Math.max(w, 50, h);
    var minH = Math.min(w, h);
    this.background(c, x, y, minW, h)
}
;
mxFloorplanStairsRest.prototype.background = function(c, x, y, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke();
    var step = 25;
    c.setShadow(false);
    c.begin();
    for (var i = 25; i < w - h * .5; i = i + step) {
        c.moveTo(i, 0);
        c.lineTo(i, h)
    }
    c.stroke();
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(w, h * .5);
    c.moveTo(w, 0);
    c.lineTo(w - h * .5, h * .5);
    c.lineTo(w, h);
    c.moveTo(w - h * .5, 0);
    c.lineTo(w - h * .5, h);
    c.moveTo(0, h * .5);
    c.lineTo(w, h * .5);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxFloorplanStairsRest.prototype.cst.STAIRS, mxFloorplanStairsRest);
function mxFloorplanDoorLeft(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxFloorplanDoorLeft, mxShape);
mxFloorplanDoorLeft.prototype.cst = {
    DOOR_LEFT: "mxgraph.floorplan.doorLeft"
};
mxFloorplanDoorLeft.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h)
}
;
mxFloorplanDoorLeft.prototype.background = function(c, x, y, w, h) {
    c.rect(0, 0, w, 5);
    c.fillAndStroke();
    c.begin();
    c.moveTo(w, 5);
    c.arcTo(w, w, 0, 0, 1, 0, 5 + w);
    c.lineTo(0, 5);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxFloorplanDoorLeft.prototype.cst.DOOR_LEFT, mxFloorplanDoorLeft);
function mxFloorplanDoorRight(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxFloorplanDoorRight, mxShape);
mxFloorplanDoorRight.prototype.cst = {
    DOOR_RIGHT: "mxgraph.floorplan.doorRight"
};
mxFloorplanDoorRight.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h)
}
;
mxFloorplanDoorRight.prototype.background = function(c, x, y, w, h) {
    c.rect(0, 0, w, 5);
    c.fillAndStroke();
    c.begin();
    c.moveTo(0, 5);
    c.arcTo(w, w, 0, 0, 0, w, 5 + w);
    c.lineTo(w, 5);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxFloorplanDoorRight.prototype.cst.DOOR_RIGHT, mxFloorplanDoorRight);
function mxFloorplanDoorDouble(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxFloorplanDoorDouble, mxShape);
mxFloorplanDoorDouble.prototype.cst = {
    DOOR_DOUBLE: "mxgraph.floorplan.doorDouble"
};
mxFloorplanDoorDouble.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h)
}
;
mxFloorplanDoorDouble.prototype.background = function(c, x, y, w, h) {
    var halfW = w * .5;
    c.rect(0, 0, w, 5);
    c.fillAndStroke();
    c.begin();
    c.moveTo(halfW, 0);
    c.lineTo(halfW, 5);
    c.moveTo(halfW, 5);
    c.arcTo(halfW, halfW, 0, 0, 1, 0, 5 + halfW);
    c.lineTo(0, 5);
    c.moveTo(halfW, 5);
    c.arcTo(halfW, halfW, 0, 0, 0, w, 5 + halfW);
    c.lineTo(w, 5);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxFloorplanDoorDouble.prototype.cst.DOOR_DOUBLE, mxFloorplanDoorDouble);
function mxShapeFlowchartDocument2(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.size = .5
}
mxUtils.extend(mxShapeFlowchartDocument2, mxActor);
mxShapeFlowchartDocument2.prototype.cst = {
    DOCUMENT2: "mxgraph.flowchart.document2"
};
mxShapeFlowchartDocument2.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dy = h * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "size", this.size))));
    var fy = 1.4;
    var r = 5;
    c.begin();
    c.moveTo(w - r, 0);
    c.arcTo(r, r, 0, 0, 1, w, r);
    c.lineTo(w, h - dy / 2);
    c.quadTo(w * 3 / 4, h - dy * fy, w / 2, h - dy / 2);
    c.quadTo(w / 4, h - dy * (1 - fy), 0, h - dy / 2);
    c.lineTo(0, dy / 2);
    c.lineTo(0, r);
    c.arcTo(r, r, 0, 0, 1, r, 0);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeFlowchartDocument2.prototype.cst.DOCUMENT2, mxShapeFlowchartDocument2);
mxShapeFlowchartDocument2.prototype.constraints = null;
Graph.handleFactory[mxShapeFlowchartDocument2.prototype.cst.DOCUMENT2] = function(state) {
    var handles = [Graph.createHandle(state, ["size"], function(bounds) {
        var size = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "size", this.size))));
        return new mxPoint(bounds.x + 3 * bounds.width / 4,bounds.y + (1 - size) * bounds.height)
    }, function(bounds, pt) {
        this.state.style["size"] = Math.max(0, Math.min(1, (bounds.y + bounds.height - pt.y) / bounds.height))
    })];
    return handles
}
;
function mxShapeGCP2DoubleRect(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeGCP2DoubleRect, mxShape);
mxShapeGCP2DoubleRect.prototype.cst = {
    SHAPE_DOUBLE_RECT: "mxgraph.gcp2.doubleRect"
};
mxShapeGCP2DoubleRect.prototype.paintVertexShape = function(c, x, y, w, h) {
    var dx = 8;
    var dy = 8;
    w = w - dx;
    h = h - dy;
    c.translate(x, y);
    c.begin();
    c.roundrect(dx, dy, w, h, 1, 1);
    c.fillAndStroke();
    c.roundrect(0, 0, w, h, 1, 1);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeGCP2DoubleRect.prototype.cst.SHAPE_DOUBLE_RECT, mxShapeGCP2DoubleRect);
mxShapeGCP2DoubleRect.prototype.constraints = mxRectangleShape.prototype.constraints;
function mxShapeGmdlPlayer(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeGmdlPlayer, mxShape);
mxShapeGmdlPlayer.prototype.cst = {
    SHAPE_PLAYER: "mxgraph.gmdl.player"
};
mxShapeGmdlPlayer.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.rect(0, 0, w, h);
    c.fill();
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeGmdlPlayer.prototype.foreground = function(c, x, y, w, h) {
    if (h >= 4) {
        c.setFillColor("#FFED00");
        c.begin();
        c.rect(0, 0, w * .8, 4);
        c.fill()
    }
    if (h >= 14 && w >= 33) {
        c.setFillColor("#717171");
        c.begin();
        c.rect(w - 33, h * .5 - 7, 4, 14);
        c.fill();
        c.begin();
        c.rect(w - 25, h * .5 - 7, 4, 14);
        c.fill()
    }
}
;
mxCellRenderer.registerShape(mxShapeGmdlPlayer.prototype.cst.SHAPE_PLAYER, mxShapeGmdlPlayer);
function mxShapeGmdlSwitch(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeGmdlSwitch, mxShape);
mxShapeGmdlSwitch.prototype.cst = {
    SHAPE_SWITCH: "mxgraph.gmdl.switch",
    STATE: "switchState",
    STATE_ON: "on",
    STATE_OFF: "off"
};
mxShapeGmdlSwitch.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var state = mxUtils.getValue(this.style, mxShapeGmdlSwitch.prototype.cst.STATE, mxShapeGmdlSwitch.prototype.cst.STATE_ON);
    this.background(c, x, y, w, h, state);
    c.setShadow(true);
    this.foreground(c, x, y, w, h, state)
}
;
mxShapeGmdlSwitch.prototype.background = function(c, x, y, w, h, state) {
    c.begin();
    if (state === mxShapeGmdlSwitch.prototype.cst.STATE_ON) {
        c.save();
        c.setAlpha("0.5");
        c.moveTo(w * .135, h * .8);
        c.arcTo(w * .135, h * .3, 0, 0, 1, w * .135, h * .2);
        c.lineTo(w * .675, h * .2);
        c.arcTo(w * .135, h * .3, 0, 0, 1, w * .675, h * .8);
        c.close();
        c.fillAndStroke();
        c.restore()
    } else {
        c.setFillColor("#BCBBBB");
        c.moveTo(w * .225, h * .8);
        c.arcTo(w * .135, h * .3, 0, 0, 1, w * .225, h * .2);
        c.lineTo(w * .865, h * .2);
        c.arcTo(w * .135, h * .3, 0, 0, 1, w * .865, h * .8);
        c.close();
        c.fillAndStroke()
    }
}
;
mxShapeGmdlSwitch.prototype.foreground = function(c, x, y, w, h, state) {
    c.begin();
    if (state === mxShapeGmdlSwitch.prototype.cst.STATE_ON)
        c.ellipse(w * .36, 0, w * .64, h);
    else {
        c.setFillColor("#F1F1F1");
        c.ellipse(0, 0, w * .64, h)
    }
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeGmdlSwitch.prototype.cst.SHAPE_SWITCH, mxShapeGmdlSwitch);
function mxShapeGmdlMarginRect(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeGmdlMarginRect, mxShape);
mxShapeGmdlMarginRect.prototype.cst = {
    SHAPE_MARGIN_RECT: "mxgraph.gmdl.marginRect",
    MARGIN: "rectMargin",
    MARGIN_TOP: "rectMarginTop",
    MARGIN_LEFT: "rectMarginLeft",
    MARGIN_BOTTOM: "rectMarginBottom",
    MARGIN_RIGHT: "rectMarginRight"
};
mxShapeGmdlMarginRect.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h)
}
;
mxShapeGmdlMarginRect.prototype.background = function(c, x, y, w, h, state) {
    var margin = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlMarginRect.prototype.cst.MARGIN, "0"));
    var marginTop = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlMarginRect.prototype.cst.MARGIN_TOP, "0"));
    var marginLeft = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlMarginRect.prototype.cst.MARGIN_LEFT, "0"));
    var marginBottom = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlMarginRect.prototype.cst.MARGIN_BOTTOM, "0"));
    var marginRight = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlMarginRect.prototype.cst.MARGIN_RIGHT, "0"));
    var x1 = margin + marginLeft;
    var y1 = margin + marginTop;
    var w1 = w - marginRight - x1 - margin;
    var h1 = h - marginBottom - y1 - margin;
    if (w1 > 0 && h1 > 0) {
        c.begin();
        c.rect(x1, y1, w1, h1);
        c.fillAndStroke()
    }
}
;
mxCellRenderer.registerShape(mxShapeGmdlMarginRect.prototype.cst.SHAPE_MARGIN_RECT, mxShapeGmdlMarginRect);
function mxShapeGmdlSliderNormal(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeGmdlSliderNormal, mxShape);
mxShapeGmdlSliderNormal.prototype.cst = {
    SHAPE_SLIDER_NORMAL: "mxgraph.gmdl.sliderNormal",
    HANDLE_SIZE: "handleSize"
};
mxShapeGmdlSliderNormal.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(true)
}
;
mxShapeGmdlSliderNormal.prototype.background = function(c, x, y, w, h) {
    var hSize = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlSliderNormal.prototype.cst.HANDLE_SIZE, "10"));
    c.ellipse(0, h * .5 - hSize * .5, hSize, hSize);
    c.stroke();
    c.begin();
    c.moveTo(hSize, h * .5);
    c.lineTo(w, h * .5);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeGmdlSliderNormal.prototype.cst.SHAPE_SLIDER_NORMAL, mxShapeGmdlSliderNormal);
function mxShapeGmdlSlider2(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeGmdlSlider2, mxShape);
mxShapeGmdlSlider2.prototype.cst = {
    SHAPE_SLIDER: "mxgraph.gmdl.slider2",
    BAR_POS: "barPos",
    HANDLE_SIZE: "handleSize"
};
mxShapeGmdlSlider2.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(true)
}
;
mxShapeGmdlSlider2.prototype.background = function(c, x, y, w, h) {
    var hSize = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlSlider2.prototype.cst.HANDLE_SIZE, "10"));
    var barPos = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlSlider2.prototype.cst.BAR_POS, "40")) / 100;
    barPos = Math.max(0, Math.min(1, barPos));
    c.save();
    c.setStrokeColor("#bbbbbb");
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(w, h * .5);
    c.fillAndStroke();
    c.restore();
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(barPos * w, h * .5);
    c.fillAndStroke();
    c.begin();
    c.ellipse(barPos * w - hSize * .5, h * .5 - hSize * .5, hSize, hSize);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeGmdlSlider2.prototype.cst.SHAPE_SLIDER, mxShapeGmdlSlider2);
mxShapeGmdlSlider2.prototype.constraints = null;
Graph.handleFactory[mxShapeGmdlSlider2.prototype.cst.SHAPE_SLIDER] = function(state) {
    var handles = [Graph.createHandle(state, ["barPos"], function(bounds) {
        var barPos = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "barPos", .4))));
        return new mxPoint(bounds.x + barPos * bounds.width / 100,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["barPos"] = Math.round(100 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 100
    })];
    return handles
}
;
function mxShapeGmdlSliderFocused(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeGmdlSliderFocused, mxShape);
mxShapeGmdlSliderFocused.prototype.cst = {
    SHAPE_SLIDER_FOCUSED: "mxgraph.gmdl.sliderFocused",
    BAR_POS: "barPos",
    HANDLE_SIZE: "handleSize"
};
mxShapeGmdlSliderFocused.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(true)
}
;
mxShapeGmdlSliderFocused.prototype.background = function(c, x, y, w, h) {
    var hSize = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlSliderFocused.prototype.cst.HANDLE_SIZE, "10"));
    var barPos = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlSliderFocused.prototype.cst.BAR_POS, "40")) / 100;
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#ffffff");
    barPos = Math.max(0, Math.min(1, barPos));
    c.save();
    c.setStrokeColor("#bbbbbb");
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(w, h * .5);
    c.fillAndStroke();
    c.restore();
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(barPos * w, h * .5);
    c.fillAndStroke();
    c.begin();
    c.ellipse(barPos * w - hSize * .167, h * .5 - hSize * .167, hSize * .33, hSize * .33);
    c.fillAndStroke();
    c.setFillColor(strokeColor);
    c.setAlpha(.15);
    c.begin();
    c.ellipse(barPos * w - hSize * .5, h * .5 - hSize * .5, hSize, hSize);
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeGmdlSliderFocused.prototype.cst.SHAPE_SLIDER_FOCUSED, mxShapeGmdlSliderFocused);
mxShapeGmdlSliderFocused.prototype.constraints = null;
Graph.handleFactory[mxShapeGmdlSliderFocused.prototype.cst.SHAPE_SLIDER_FOCUSED] = function(state) {
    var handles = [Graph.createHandle(state, ["barPos"], function(bounds) {
        var barPos = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "barPos", .4))));
        return new mxPoint(bounds.x + barPos * bounds.width / 100,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["barPos"] = Math.round(100 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 100
    })];
    return handles
}
;
function mxShapeGmdlSliderDisabled(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeGmdlSliderDisabled, mxShape);
mxShapeGmdlSliderDisabled.prototype.cst = {
    SHAPE_SLIDER_DISABLED: "mxgraph.gmdl.sliderDisabled",
    HANDLE_POSITION: "hPos",
    HANDLE_SIZE: "handleSize"
};
mxShapeGmdlSliderDisabled.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(true)
}
;
mxShapeGmdlSliderDisabled.prototype.background = function(c, x, y, w, h) {
    var hSize = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlSliderDisabled.prototype.cst.HANDLE_SIZE, "10"));
    var hPos = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlSliderDisabled.prototype.cst.HANDLE_POSITION, "50")) / 100;
    hPos = Math.max(hPos, 0);
    hPos = Math.min(hPos, 1);
    c.ellipse(w * hPos - hSize * .5, (h - hSize) * .5, hSize, hSize);
    c.fillAndStroke();
    var endL = w * hPos - 7;
    var startR = w * hPos + 7;
    if (endL > 0) {
        c.begin();
        c.moveTo(0, h * .5);
        c.lineTo(endL, h * .5);
        c.stroke()
    }
    if (startR < w) {
        c.begin();
        c.moveTo(startR, h * .5);
        c.lineTo(w, h * .5);
        c.stroke()
    }
}
;
mxCellRenderer.registerShape(mxShapeGmdlSliderDisabled.prototype.cst.SHAPE_SLIDER_DISABLED, mxShapeGmdlSliderDisabled);
function mxShapeGmdlSliderDisabled2(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeGmdlSliderDisabled2, mxShape);
mxShapeGmdlSliderDisabled2.prototype.cst = {
    SHAPE_SLIDER_DISABLED: "mxgraph.gmdl.sliderDisabled2",
    HANDLE_POSITION: "hPos",
    HANDLE_SIZE: "handleSize"
};
mxShapeGmdlSliderDisabled2.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(true)
}
;
mxShapeGmdlSliderDisabled2.prototype.background = function(c, x, y, w, h) {
    var hSize = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlSliderDisabled2.prototype.cst.HANDLE_SIZE, "10"));
    var hPos = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlSliderDisabled2.prototype.cst.HANDLE_POSITION, "50")) / 100;
    hPos = Math.min(Math.max(hPos, 0), 1);
    c.ellipse(w * hPos - hSize * .5, (h - hSize) * .5, hSize, hSize);
    c.fillAndStroke();
    var endL = w * hPos - 7;
    var startR = w * hPos + 7;
    if (endL > 0) {
        c.begin();
        c.moveTo(0, h * .5);
        c.lineTo(endL, h * .5);
        c.stroke()
    }
    if (startR < w) {
        c.begin();
        c.moveTo(startR, h * .5);
        c.lineTo(w, h * .5);
        c.stroke()
    }
}
;
mxCellRenderer.registerShape(mxShapeGmdlSliderDisabled2.prototype.cst.SHAPE_SLIDER_DISABLED, mxShapeGmdlSliderDisabled2);
mxShapeGmdlSlider2.prototype.constraints = null;
Graph.handleFactory[mxShapeGmdlSliderDisabled2.prototype.cst.SHAPE_SLIDER_DISABLED] = function(state) {
    var handles = [Graph.createHandle(state, ["hPos"], function(bounds) {
        var hPos = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "hPos", .4))));
        return new mxPoint(bounds.x + hPos * bounds.width / 100,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["hPos"] = Math.round(100 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 100
    })];
    return handles
}
;
function mxShapeGmdlSliderDiscrete(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeGmdlSliderDiscrete, mxShape);
mxShapeGmdlSliderDiscrete.prototype.cst = {
    SHAPE_DISCRETE: "mxgraph.gmdl.sliderDiscrete",
    BAR_POS: "barPos",
    HANDLE_SIZE: "handleSize"
};
mxShapeGmdlSliderDiscrete.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(true)
}
;
mxShapeGmdlSliderDiscrete.prototype.background = function(c, x, y, w, h) {
    var hSize = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlSliderDiscrete.prototype.cst.HANDLE_SIZE, "10"));
    var barPos = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlSliderDiscrete.prototype.cst.BAR_POS, "40")) / 100;
    var fontSize = parseFloat(mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "12"));
    var fontColor = mxUtils.getValue(this.style, mxConstants.STYLE_FONTCOLOR, "#000000");
    barPos = Math.max(0, Math.min(1, barPos));
    c.save();
    c.setStrokeColor("#bbbbbb");
    c.begin();
    c.moveTo(0, h * .5 + 22.5);
    c.lineTo(w, h * .5 + 22.5);
    c.fillAndStroke();
    c.restore();
    c.begin();
    c.moveTo(0, h * .5 + 22.5);
    c.lineTo(barPos * w, h * .5 + 22.5);
    c.fillAndStroke();
    c.begin();
    c.moveTo(barPos * w, h * .5 + 15.5);
    c.lineTo(barPos * w - 10.5, h * .5 + 2.5);
    c.arcTo(15, 15, 0, 0, 1, barPos * w, h * .5 - 22.5);
    c.arcTo(15, 15, 0, 0, 1, barPos * w + 10.5, h * .5 + 2.5);
    c.close();
    c.fillAndStroke();
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    var p = Math.round(barPos * 100);
    c.text(barPos * w, h * .5 - 9, 0, 0, p.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxShapeGmdlSliderDiscrete.prototype.cst.SHAPE_DISCRETE, mxShapeGmdlSliderDiscrete);
mxShapeGmdlSliderDiscrete.prototype.constraints = null;
Graph.handleFactory[mxShapeGmdlSliderDiscrete.prototype.cst.SHAPE_DISCRETE] = function(state) {
    var handles = [Graph.createHandle(state, ["barPos"], function(bounds) {
        var barPos = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "barPos", .4))));
        return new mxPoint(bounds.x + barPos * bounds.width / 100,bounds.y + bounds.height / 2 + 22.5)
    }, function(bounds, pt) {
        this.state.style["barPos"] = Math.round(100 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / 100
    })];
    return handles
}
;
function mxShapeGmdlSliderDiscreteDots(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeGmdlSliderDiscreteDots, mxShape);
mxShapeGmdlSliderDiscreteDots.prototype.cst = {
    SHAPE_DISCRETE_DOTS: "mxgraph.gmdl.sliderDiscreteDots",
    BAR_POS: "barPos",
    HANDLE_SIZE: "handleSize"
};
mxShapeGmdlSliderDiscreteDots.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(true)
}
;
mxShapeGmdlSliderDiscreteDots.prototype.background = function(c, x, y, w, h) {
    var hSize = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlSliderDiscreteDots.prototype.cst.HANDLE_SIZE, "10"));
    var barPos = parseFloat(mxUtils.getValue(this.style, mxShapeGmdlSliderDiscreteDots.prototype.cst.BAR_POS, "40")) / 100;
    var fontSize = parseFloat(mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "12"));
    var fontColor = mxUtils.getValue(this.style, mxConstants.STYLE_FONTCOLOR, "#000000");
    var bright = mxUtils.getValue(this.style, "bright", "1");
    barPos = Math.max(0, Math.min(1, barPos));
    c.save();
    c.setStrokeColor("#bebebe");
    c.begin();
    c.moveTo(0, h * .5 + 22.5);
    c.lineTo(w, h * .5 + 22.5);
    c.fillAndStroke();
    c.restore();
    if (barPos <= .1)
        c.setFillColor("#bebebe");
    c.begin();
    c.moveTo(0, h * .5 + 22.5);
    c.lineTo(barPos * w, h * .5 + 22.5);
    c.fillAndStroke();
    c.begin();
    c.moveTo(barPos * w, h * .5 + 15.5);
    c.lineTo(barPos * w - 10.5, h * .5 + 2.5);
    c.arcTo(15, 15, 0, 0, 1, barPos * w, h * .5 - 22.5);
    c.arcTo(15, 15, 0, 0, 1, barPos * w + 10.5, h * .5 + 2.5);
    c.close();
    c.fill();
    if (bright == "1")
        c.setFillColor("#000000");
    else
        c.setFillColor("#ffffff");
    c.ellipse(-1.5, h * .5 + 21, 3, 3);
    c.fill();
    c.ellipse(w * .2 - 1.5, h * .5 + 21, 3, 3);
    c.fill();
    c.ellipse(w * .4 - 1.5, h * .5 + 21, 3, 3);
    c.fill();
    c.ellipse(w * .6 - 1.5, h * .5 + 21, 3, 3);
    c.fill();
    c.ellipse(w * .8 - 1.5, h * .5 + 21, 3, 3);
    c.fill();
    c.ellipse(w - 1.5, h * .5 + 21, 3, 3);
    c.fill();
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    var p = Math.round(barPos * 100);
    c.text(barPos * w, h * .5 - 9, 0, 0, p.toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxCellRenderer.registerShape(mxShapeGmdlSliderDiscreteDots.prototype.cst.SHAPE_DISCRETE_DOTS, mxShapeGmdlSliderDiscreteDots);
mxShapeGmdlSliderDiscreteDots.prototype.constraints = null;
Graph.handleFactory[mxShapeGmdlSliderDiscreteDots.prototype.cst.SHAPE_DISCRETE_DOTS] = function(state) {
    var handles = [Graph.createHandle(state, ["barPos"], function(bounds) {
        var barPos = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "barPos", .4))));
        return new mxPoint(bounds.x + barPos * bounds.width / 100,bounds.y + bounds.height / 2 + 22.5)
    }, function(bounds, pt) {
        this.state.style["barPos"] = Math.round(.05 * Math.max(0, Math.min(100, (pt.x - bounds.x) * 100 / bounds.width))) / .05
    })];
    return handles
}
;
function mxShapeGmdlProgressBar(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx1 = .8
}
mxUtils.extend(mxShapeGmdlProgressBar, mxShape);
mxShapeGmdlProgressBar.prototype.cst = {
    PROGRESS_BAR: "mxgraph.gmdl.progressBar"
};
mxShapeGmdlProgressBar.prototype.paintVertexShape = function(c, x, y, w, h) {
    var dx1 = w * Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx1", this.dx1))));
    c.translate(x, y);
    c.save();
    c.setStrokeColor("#aaaaaa");
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(w, h * .5);
    c.stroke();
    c.restore();
    c.setShadow(false);
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(dx1, h * .5);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeGmdlProgressBar.prototype.cst.PROGRESS_BAR, mxShapeGmdlProgressBar);
mxShapeGmdlProgressBar.prototype.constraints = null;
Graph.handleFactory[mxShapeGmdlProgressBar.prototype.cst.PROGRESS_BAR] = function(state) {
    var handles = [Graph.createHandle(state, ["dx1"], function(bounds) {
        var dx1 = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "dx1", this.dx1))));
        return new mxPoint(bounds.x + dx1 * bounds.width,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["dx1"] = Math.round(100 * Math.max(0, Math.min(1, (pt.x - bounds.x) / bounds.width))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["dx2"], function(bounds) {
        var dx2 = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "dx2", this.dx1))));
        return new mxPoint(bounds.x + dx2 * bounds.width,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["dx2"] = Math.round(100 * Math.max(0, Math.min(1, (pt.x - bounds.x) / bounds.width))) / 100
    });
    handles.push(handle2);
    return handles
}
;
function mxShapeInfographicNumEntryVert(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy = .5
}
mxUtils.extend(mxShapeInfographicNumEntryVert, mxActor);
mxShapeInfographicNumEntryVert.prototype.cst = {
    NUM_ENTRY_VERT: "mxgraph.infographic.numberedEntryVert"
};
mxShapeInfographicNumEntryVert.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dy = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    var inset = 5;
    var d = Math.min(dy, w - 2 * inset, h - inset);
    c.ellipse(w * .5 - d * .5, 0, d, d);
    c.fillAndStroke();
    c.begin();
    c.moveTo(0, d * .5);
    c.lineTo(w * .5 - d * .5 - inset, d * .5);
    c.arcTo(d * .5 + inset, d * .5 + inset, 0, 0, 0, w * .5 + d * .5 + inset, d * .5);
    c.lineTo(w, d * .5);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeInfographicNumEntryVert.prototype.cst.NUM_ENTRY_VERT, mxShapeInfographicNumEntryVert);
mxShapeInfographicNumEntryVert.prototype.constraints = null;
Graph.handleFactory[mxShapeInfographicNumEntryVert.prototype.cst.NUM_ENTRY_VERT] = function(state) {
    var handles = [Graph.createHandle(state, ["dy"], function(bounds) {
        var dy = Math.max(0, Math.min(bounds.width, bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + bounds.width / 2,bounds.y + dy)
    }, function(bounds, pt) {
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(bounds.height, bounds.width, pt.y - bounds.y))) / 100
    })];
    return handles
}
;
function mxShapeInfographicBendingArch(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.startAngle = .25;
    this.endAngle = .75;
    this.arcWidth = .5
}
mxUtils.extend(mxShapeInfographicBendingArch, mxActor);
mxShapeInfographicBendingArch.prototype.cst = {
    BENDING_ARCH: "mxgraph.infographic.bendingArch"
};
mxShapeInfographicBendingArch.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var startAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "startAngle", this.startAngle))));
    var endAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "endAngle", this.endAngle))));
    var arcWidth = 1 - Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "arcWidth", this.arcWidth))));
    var rx = w * .5;
    var ry = h * .5;
    var rx2 = rx * arcWidth;
    var ry2 = ry * arcWidth;
    var startX = rx + Math.sin(startAngle) * rx;
    var startY = ry - Math.cos(startAngle) * ry;
    var innerStartX = rx + Math.sin(startAngle) * rx2;
    var innerStartY = ry - Math.cos(startAngle) * ry2;
    var endX = rx + Math.sin(endAngle) * rx;
    var endY = ry - Math.cos(endAngle) * ry;
    var innerEndX = rx + Math.sin(endAngle) * rx2;
    var innerEndY = ry - Math.cos(endAngle) * ry2;
    var angDiff = endAngle - startAngle;
    if (angDiff < 0)
        angDiff = angDiff + Math.PI * 2;
    var bigArc = 0;
    if (angDiff > Math.PI)
        bigArc = 1;
    var rx3 = rx2 - 5;
    var ry3 = ry2 - 5;
    c.ellipse(w * .5 - rx3, h * .5 - ry3, 2 * rx3, 2 * ry3);
    c.fillAndStroke();
    c.begin();
    c.moveTo(startX, startY);
    c.arcTo(rx, ry, 0, bigArc, 1, endX, endY);
    c.lineTo(innerEndX, innerEndY);
    c.arcTo(rx2, ry2, 0, bigArc, 0, innerStartX, innerStartY);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeInfographicBendingArch.prototype.cst.BENDING_ARCH, mxShapeInfographicBendingArch);
mxShapeInfographicBendingArch.prototype.constraints = null;
Graph.handleFactory[mxShapeInfographicBendingArch.prototype.cst.BENDING_ARCH] = function(state) {
    var handles = [Graph.createHandle(state, ["startAngle"], function(bounds) {
        var startAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "startAngle", this.startAngle))));
        return new mxPoint(bounds.x + bounds.width * .5 + Math.sin(startAngle) * bounds.width * .5,bounds.y + bounds.height * .5 - Math.cos(startAngle) * bounds.height * .5)
    }, function(bounds, pt) {
        var handleX = Math.round(100 * Math.max(-1, Math.min(1, (pt.x - bounds.x - bounds.width * .5) / (bounds.width * .5)))) / 100;
        var handleY = -Math.round(100 * Math.max(-1, Math.min(1, (pt.y - bounds.y - bounds.height * .5) / (bounds.height * .5)))) / 100;
        var res = .5 * Math.atan2(handleX, handleY) / Math.PI;
        if (res < 0)
            res = 1 + res;
        this.state.style["startAngle"] = res
    })];
    var handle2 = Graph.createHandle(state, ["endAngle"], function(bounds) {
        var endAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "endAngle", this.endAngle))));
        return new mxPoint(bounds.x + bounds.width * .5 + Math.sin(endAngle) * bounds.width * .5,bounds.y + bounds.height * .5 - Math.cos(endAngle) * bounds.height * .5)
    }, function(bounds, pt) {
        var handleX = Math.round(100 * Math.max(-1, Math.min(1, (pt.x - bounds.x - bounds.width * .5) / (bounds.width * .5)))) / 100;
        var handleY = -Math.round(100 * Math.max(-1, Math.min(1, (pt.y - bounds.y - bounds.height * .5) / (bounds.height * .5)))) / 100;
        var res = .5 * Math.atan2(handleX, handleY) / Math.PI;
        if (res < 0)
            res = 1 + res;
        this.state.style["endAngle"] = res
    });
    handles.push(handle2);
    var handle3 = Graph.createHandle(state, ["arcWidth"], function(bounds) {
        var arcWidth = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "arcWidth", this.arcWidth))));
        return new mxPoint(bounds.x + bounds.width / 2,bounds.y + arcWidth * bounds.height * .5)
    }, function(bounds, pt) {
        this.state.style["arcWidth"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, (pt.y - bounds.y) / (bounds.height * .5)))) / 100
    });
    handles.push(handle3);
    return handles
}
;
function mxShapeInfographicParallelogram(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = 10
}
mxUtils.extend(mxShapeInfographicParallelogram, mxActor);
mxShapeInfographicParallelogram.prototype.cst = {
    PARALLELOGRAM: "mxgraph.infographic.parallelogram"
};
mxShapeInfographicParallelogram.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w * .5, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    c.begin();
    c.moveTo(0, h);
    c.lineTo(2 * dx, 0);
    c.lineTo(w, 0);
    c.lineTo(w - 2 * dx, h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeInfographicParallelogram.prototype.cst.PARALLELOGRAM, mxShapeInfographicParallelogram);
mxShapeInfographicParallelogram.prototype.constraints = null;
Graph.handleFactory[mxShapeInfographicParallelogram.prototype.cst.PARALLELOGRAM] = function(state) {
    var handles = [Graph.createHandle(state, ["dx"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width / 2, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        return new mxPoint(bounds.x + dx,bounds.y + bounds.height / 2)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.width / 2, pt.x - bounds.x))) / 100
    })];
    return handles
}
;
function mxShapeInfographicRibbonRolled(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5;
    this.dy = .5
}
mxUtils.extend(mxShapeInfographicRibbonRolled, mxActor);
mxShapeInfographicRibbonRolled.prototype.cst = {
    RIBBON_ROLLED: "mxgraph.infographic.ribbonRolled"
};
mxShapeInfographicRibbonRolled.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    var dy = Math.max(0, Math.min(h * .5, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    c.begin();
    c.moveTo(0, dy);
    c.lineTo(dx, 0);
    c.lineTo(dx, dy);
    c.lineTo(w, dy);
    c.lineTo(w, h - dy);
    c.lineTo(w - dx, h);
    c.lineTo(w - dx, h - dy);
    c.lineTo(0, h - dy);
    c.close();
    c.fillAndStroke();
    c.setShadow(false);
    c.setFillAlpha("0.2");
    c.setFillColor("#000000");
    c.begin();
    c.moveTo(0, dy);
    c.lineTo(dx, 0);
    c.lineTo(dx, dy);
    c.close();
    c.moveTo(w, h - dy);
    c.lineTo(w - dx, h);
    c.lineTo(w - dx, h - dy);
    c.close();
    c.fill();
    c.begin();
    c.moveTo(0, dy);
    c.lineTo(dx, 0);
    c.lineTo(dx, dy);
    c.lineTo(w, dy);
    c.lineTo(w, h - dy);
    c.lineTo(w - dx, h);
    c.lineTo(w - dx, h - dy);
    c.lineTo(0, h - dy);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeInfographicRibbonRolled.prototype.cst.RIBBON_ROLLED, mxShapeInfographicRibbonRolled);
mxShapeInfographicRibbonRolled.prototype.constraints = null;
Graph.handleFactory[mxShapeInfographicRibbonRolled.prototype.cst.RIBBON_ROLLED] = function(state) {
    var handles = [Graph.createHandle(state, ["dx", "dy"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + dx,bounds.y + dy)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.width, pt.x - bounds.x))) / 100;
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, pt.y - bounds.y))) / 100
    })];
    return handles
}
;
function mxShapeInfographicRibbonDoubleFolded(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5;
    this.dy = .5
}
mxUtils.extend(mxShapeInfographicRibbonDoubleFolded, mxActor);
mxShapeInfographicRibbonDoubleFolded.prototype.cst = {
    RIBBON_DOUBLE_FOLDED: "mxgraph.infographic.ribbonDoubleFolded"
};
mxShapeInfographicRibbonDoubleFolded.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    var dy = Math.max(0, Math.min(h * .5, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    c.begin();
    c.moveTo(0, dy);
    c.lineTo(dx, 0);
    c.lineTo(dx, dy);
    c.lineTo(w, dy);
    c.lineTo(w, h - dy);
    c.lineTo(w - dx, h);
    c.lineTo(w - dx, h - dy);
    c.lineTo(0, h - dy);
    c.close();
    c.fillAndStroke();
    c.setShadow(false);
    c.setFillAlpha("0.2");
    c.setFillColor("#000000");
    c.begin();
    c.moveTo(0, dy);
    c.lineTo(dx, 0);
    c.lineTo(dx, h - 2 * dy);
    c.lineTo(0, h - dy);
    c.close();
    c.moveTo(w, h - dy);
    c.lineTo(w - dx, h);
    c.lineTo(w - dx, h - dy);
    c.close();
    c.fill();
    c.begin();
    c.moveTo(0, dy);
    c.lineTo(dx, 0);
    c.lineTo(dx, dy);
    c.lineTo(w, dy);
    c.lineTo(w, h - dy);
    c.lineTo(w - dx, h);
    c.lineTo(w - dx, h - dy);
    c.lineTo(0, h - dy);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeInfographicRibbonDoubleFolded.prototype.cst.RIBBON_DOUBLE_FOLDED, mxShapeInfographicRibbonDoubleFolded);
mxShapeInfographicRibbonDoubleFolded.prototype.constraints = null;
Graph.handleFactory[mxShapeInfographicRibbonDoubleFolded.prototype.cst.RIBBON_DOUBLE_FOLDED] = function(state) {
    var handles = [Graph.createHandle(state, ["dx", "dy"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + dx,bounds.y + dy)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.width, pt.x - bounds.x))) / 100;
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, pt.y - bounds.y))) / 100
    })];
    return handles
}
;
function mxShapeInfographicRibbonFrontFolded(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5;
    this.dy = .5;
    this.notch = .5
}
mxUtils.extend(mxShapeInfographicRibbonFrontFolded, mxActor);
mxShapeInfographicRibbonFrontFolded.prototype.cst = {
    RIBBON_FRONT_FOLDED: "mxgraph.infographic.ribbonFrontFolded"
};
mxShapeInfographicRibbonFrontFolded.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    var dy = Math.max(0, Math.min(h * .5, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    var notch = Math.max(0, Math.min(w - dx, parseFloat(mxUtils.getValue(this.style, "notch", this.notch))));
    c.begin();
    c.moveTo(0, dy);
    c.lineTo(dx, 0);
    c.lineTo(dx, dy);
    c.lineTo(w, dy);
    c.lineTo(w - notch, (h - dy) / 2 + dy);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke();
    c.setShadow(false);
    c.setFillAlpha("0.2");
    c.setFillColor("#000000");
    c.begin();
    c.moveTo(0, dy);
    c.lineTo(dx, 0);
    c.lineTo(dx, h - dy);
    c.lineTo(0, h);
    c.close();
    c.fill();
    c.begin();
    c.moveTo(0, dy);
    c.lineTo(dx, 0);
    c.lineTo(dx, dy);
    c.lineTo(w, dy);
    c.lineTo(w - notch, (h - dy) / 2 + dy);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeInfographicRibbonFrontFolded.prototype.cst.RIBBON_FRONT_FOLDED, mxShapeInfographicRibbonFrontFolded);
mxShapeInfographicRibbonFrontFolded.prototype.constraints = null;
Graph.handleFactory[mxShapeInfographicRibbonFrontFolded.prototype.cst.RIBBON_FRONT_FOLDED] = function(state) {
    var handles = [Graph.createHandle(state, ["dx", "dy"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + dx,bounds.y + dy)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.width, pt.x - bounds.x))) / 100;
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, pt.y - bounds.y))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["notch"], function(bounds) {
        var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        var notch = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch))));
        return new mxPoint(bounds.x + bounds.width - notch,bounds.y + dy + (bounds.height - dy) * .5)
    }, function(bounds, pt) {
        this.state.style["notch"] = Math.round(100 * Math.max(0, Math.min(bounds.width, bounds.width + bounds.x - pt.x))) / 100
    });
    handles.push(handle2);
    return handles
}
;
function mxShapeInfographicRibbonBackFolded(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5;
    this.dy = .5;
    this.notch = .5
}
mxUtils.extend(mxShapeInfographicRibbonBackFolded, mxActor);
mxShapeInfographicRibbonBackFolded.prototype.cst = {
    RIBBON_BACK_FOLDED: "mxgraph.infographic.ribbonBackFolded"
};
mxShapeInfographicRibbonBackFolded.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    var dy = Math.max(0, Math.min(h * .5, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    var notch = Math.max(0, Math.min(w - dx, parseFloat(mxUtils.getValue(this.style, "notch", this.notch))));
    c.begin();
    c.moveTo(0, dy);
    c.lineTo(dx, 0);
    c.lineTo(dx, dy);
    c.lineTo(w, dy);
    c.lineTo(w - notch, (h - dy) / 2 + dy);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke();
    c.setShadow(false);
    c.setFillAlpha("0.2");
    c.setFillColor("#000000");
    c.begin();
    c.moveTo(0, dy);
    c.lineTo(dx, 0);
    c.lineTo(dx, dy);
    c.close();
    c.fill();
    c.begin();
    c.moveTo(0, dy);
    c.lineTo(dx, 0);
    c.lineTo(dx, dy);
    c.lineTo(w, dy);
    c.lineTo(w - notch, (h - dy) / 2 + dy);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeInfographicRibbonBackFolded.prototype.cst.RIBBON_BACK_FOLDED, mxShapeInfographicRibbonBackFolded);
mxShapeInfographicRibbonBackFolded.prototype.constraints = null;
Graph.handleFactory[mxShapeInfographicRibbonBackFolded.prototype.cst.RIBBON_BACK_FOLDED] = function(state) {
    var handles = [Graph.createHandle(state, ["dx", "dy"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + dx,bounds.y + dy)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.width, pt.x - bounds.x))) / 100;
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, pt.y - bounds.y))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["notch"], function(bounds) {
        var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        var notch = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch))));
        return new mxPoint(bounds.x + bounds.width - notch,bounds.y + dy + (bounds.height - dy) * .5)
    }, function(bounds, pt) {
        this.state.style["notch"] = Math.round(100 * Math.max(0, Math.min(bounds.width, bounds.width + bounds.x - pt.x))) / 100
    });
    handles.push(handle2);
    return handles
}
;
function mxShapeInfographicBanner(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5;
    this.dy = .5;
    this.notch = .5
}
mxUtils.extend(mxShapeInfographicBanner, mxActor);
mxShapeInfographicBanner.prototype.cst = {
    BANNER: "mxgraph.infographic.banner"
};
mxShapeInfographicBanner.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w / 2, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    var dy = Math.max(0, Math.min(h * .5, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "notch", this.notch))));
    dx = Math.min(w / 2 - 2 * dy, dx);
    notch = Math.min(dx, notch);
    c.begin();
    c.moveTo(0, dy);
    c.lineTo(dx, dy);
    c.lineTo(dx, 0);
    c.lineTo(w - dx, 0);
    c.lineTo(w - dx, dy);
    c.lineTo(w, dy);
    c.lineTo(w - notch, (h - dy) * .5 + dy);
    c.lineTo(w, h);
    c.lineTo(w - dx - 2 * dy, h);
    c.lineTo(w - dx - 2 * dy, h - dy);
    c.lineTo(dx + 2 * dy, h - dy);
    c.lineTo(dx + 2 * dy, h);
    c.lineTo(0, h);
    c.lineTo(notch, (h - dy) * .5 + dy);
    c.close();
    c.fillAndStroke();
    c.setShadow(false);
    c.setFillAlpha("0.2");
    c.setFillColor("#000000");
    c.begin();
    c.moveTo(0, dy);
    c.lineTo(dx, dy);
    c.lineTo(dx, h - dy);
    c.lineTo(dx + 2 * dy, h);
    c.lineTo(0, h);
    c.lineTo(notch, (h - dy) * .5 + dy);
    c.close();
    c.moveTo(w, dy);
    c.lineTo(w - dx, dy);
    c.lineTo(w - dx, h - dy);
    c.lineTo(w - dx - 2 * dy, h);
    c.lineTo(w, h);
    c.lineTo(w - notch, (h - dy) * .5 + dy);
    c.close();
    c.fill();
    c.setFillAlpha("0.4");
    c.begin();
    c.moveTo(dx, h - dy);
    c.lineTo(dx + 2 * dy, h - dy);
    c.lineTo(dx + 2 * dy, h);
    c.close();
    c.moveTo(w - dx, h - dy);
    c.lineTo(w - dx - 2 * dy, h - dy);
    c.lineTo(w - dx - 2 * dy, h);
    c.close();
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeInfographicBanner.prototype.cst.BANNER, mxShapeInfographicBanner);
mxShapeInfographicBanner.prototype.constraints = null;
Graph.handleFactory[mxShapeInfographicBanner.prototype.cst.BANNER] = function(state) {
    var handles = [Graph.createHandle(state, ["dx", "dy"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width / 2, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + bounds.width - dx,bounds.y + dy)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.width / 2, bounds.x + bounds.width - pt.x))) / 100;
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, pt.y - bounds.y))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["notch"], function(bounds) {
        var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        var dx = Math.max(0, Math.min(bounds.width / 2, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var notch = Math.max(0, Math.min(dx, parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch))));
        return new mxPoint(bounds.x + bounds.width - notch,bounds.y + dy + (bounds.height - dy) * .5)
    }, function(bounds, pt) {
        this.state.style["notch"] = Math.round(100 * Math.max(0, Math.min(bounds.width, bounds.width + bounds.x - pt.x))) / 100
    });
    handles.push(handle2);
    return handles
}
;
function mxShapeInfographicCircularCallout(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy = .5
}
mxUtils.extend(mxShapeInfographicCircularCallout, mxActor);
mxShapeInfographicCircularCallout.prototype.cst = {
    CIRCULAR_CALLOUT: "mxgraph.infographic.circularCallout"
};
mxShapeInfographicCircularCallout.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dy = Math.max(0, Math.min(h * .5, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    var rx = Math.max(0, Math.min(w * .5, w * .5 - dy));
    var ry = Math.max(0, Math.min(h * .5, h * .5 - dy));
    c.begin();
    c.moveTo(w, h * .5);
    c.arcTo(w * .5, h * .5, 0, 0, 1, w * .5, h);
    c.arcTo(w * .5, h * .5, 0, 0, 1, 0, h * .5);
    c.arcTo(w * .5, h * .5, 0, 0, 1, w * .5, 0);
    c.lineTo(w, 0);
    c.close();
    c.moveTo(w * .5, dy);
    c.arcTo(rx, ry, 0, 0, 0, w * .5 - rx, h * .5);
    c.arcTo(rx, ry, 0, 0, 0, w * .5, h * .5 + ry);
    c.arcTo(rx, ry, 0, 0, 0, w * .5 + rx, h * .5);
    c.arcTo(rx, ry, 0, 0, 0, w * .5, h * .5 - ry);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeInfographicCircularCallout.prototype.cst.CIRCULAR_CALLOUT, mxShapeInfographicCircularCallout);
mxShapeInfographicCircularCallout.prototype.constraints = null;
Graph.handleFactory[mxShapeInfographicCircularCallout.prototype.cst.CIRCULAR_CALLOUT] = function(state) {
    var handles = [Graph.createHandle(state, ["dy"], function(bounds) {
        var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + bounds.width * .5,bounds.y + dy)
    }, function(bounds, pt) {
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, pt.y - bounds.y))) / 100
    })];
    return handles
}
;
function mxShapeInfographicShadedTriangle(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeInfographicShadedTriangle, mxActor);
mxShapeInfographicShadedTriangle.prototype.cst = {
    SHADED_TRIANGLE: "mxgraph.infographic.shadedTriangle"
};
mxShapeInfographicShadedTriangle.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.moveTo(0, h);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h);
    c.close();
    c.fillAndStroke();
    c.setShadow(false);
    c.setFillColor("#ffffff");
    c.setFillAlpha("0.2");
    c.begin();
    c.moveTo(0, h);
    c.lineTo(w * .5, 0);
    c.lineTo(w * .5, h * .67);
    c.close();
    c.fill();
    c.setFillColor("#000000");
    c.begin();
    c.moveTo(w, h);
    c.lineTo(w * .5, h * .67);
    c.lineTo(w * .5, 0);
    c.close();
    c.fill();
    c.begin();
    c.moveTo(0, h);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeInfographicShadedTriangle.prototype.cst.SHADED_TRIANGLE, mxShapeInfographicShadedTriangle);
mxShapeInfographicShadedTriangle.prototype.constraints = null;
function mxShapeInfographicShadedPyramid(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeInfographicShadedPyramid, mxActor);
mxShapeInfographicShadedPyramid.prototype.cst = {
    SHADED_PYRAMID: "mxgraph.infographic.shadedPyramid"
};
mxShapeInfographicShadedPyramid.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var h1 = Math.max(h - w * .3, 0);
    c.begin();
    c.moveTo(0, h1);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h1);
    c.lineTo(w * .5, h);
    c.close();
    c.fillAndStroke();
    c.setShadow(false);
    c.setFillColor("#ffffff");
    c.setFillAlpha("0.2");
    c.begin();
    c.moveTo(0, h1);
    c.lineTo(w * .5, 0);
    c.lineTo(w * .5, h);
    c.close();
    c.fill();
    c.setFillColor("#000000");
    c.begin();
    c.moveTo(w, h1);
    c.lineTo(w * .5, h);
    c.lineTo(w * .5, 0);
    c.close();
    c.fill();
    c.begin();
    c.moveTo(0, h1);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h1);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeInfographicShadedPyramid.prototype.cst.SHADED_PYRAMID, mxShapeInfographicShadedPyramid);
mxShapeInfographicShadedPyramid.prototype.constraints = null;
function mxShapeInfographicPyramidStep(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeInfographicPyramidStep, mxActor);
mxShapeInfographicPyramidStep.prototype.cst = {
    PYRAMID_STEP: "mxgraph.infographic.pyramidStep"
};
mxShapeInfographicPyramidStep.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var h1 = Math.max(w * .1, 0);
    c.begin();
    c.moveTo(0, h1);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h1);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke();
    c.setShadow(false);
    c.setFillColor("#ffffff");
    c.setFillAlpha("0.2");
    c.begin();
    c.moveTo(0, h1);
    c.lineTo(w * .5, 0);
    c.lineTo(w * .5, h);
    c.lineTo(0, h);
    c.close();
    c.fill();
    c.setFillColor("#000000");
    c.begin();
    c.moveTo(w, h1);
    c.lineTo(w, h);
    c.lineTo(w * .5, h);
    c.lineTo(w * .5, 0);
    c.close();
    c.fill();
    c.begin();
    c.moveTo(0, h1);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h1);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeInfographicPyramidStep.prototype.cst.PYRAMID_STEP, mxShapeInfographicPyramidStep);
mxShapeInfographicPyramidStep.prototype.constraints = null;
function mxShapeInfographicCylinder(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeInfographicCylinder, mxActor);
mxShapeInfographicCylinder.prototype.cst = {
    CYLINDER: "mxgraph.infographic.cylinder"
};
mxShapeInfographicCylinder.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dy = 20;
    var rx = w * .5;
    var ry = dy * .5;
    c.begin();
    c.moveTo(0, dy * .5);
    c.arcTo(rx, ry, 0, 0, 1, w, ry);
    c.lineTo(w, h - ry);
    c.arcTo(rx, ry, 0, 0, 1, 0, h - ry);
    c.close();
    c.fillAndStroke();
    c.setShadow(false);
    c.setGradient("#000000", "#ffffff", 0, 0, w, h, mxConstants.DIRECTION_EAST, .4, .4);
    c.begin();
    c.moveTo(0, dy * .5);
    c.arcTo(rx, ry, 0, 0, 0, w, ry);
    c.lineTo(w, h - ry);
    c.arcTo(rx, ry, 0, 0, 1, 0, h - ry);
    c.close();
    c.fill();
    c.begin();
    c.moveTo(0, dy * .5);
    c.arcTo(rx, ry, 0, 0, 1, w, ry);
    c.lineTo(w, h - ry);
    c.arcTo(rx, ry, 0, 0, 1, 0, h - ry);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeInfographicCylinder.prototype.cst.CYLINDER, mxShapeInfographicCylinder);
mxShapeInfographicCylinder.prototype.constraints = null;
function mxShapeInfographicCircularCallout2(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy = .5
}
mxUtils.extend(mxShapeInfographicCircularCallout2, mxActor);
mxShapeInfographicCircularCallout2.prototype.cst = {
    CIRCULAR_CALLOUT_2: "mxgraph.infographic.circularCallout2"
};
mxShapeInfographicCircularCallout2.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "none");
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "none");
    c.setFillColor(strokeColor);
    var rx = Math.max(0, Math.min(w * .5, h * .4, h * .5 - 7));
    c.begin();
    c.moveTo(w * .5 - 2, 2.15 * rx);
    c.arcTo(rx * .23, rx * .23, 0, 0, 0, w * .5 - rx * .2, rx * 1.97);
    c.arcTo(rx, rx, 0, 0, 1, w * .5 - rx, rx);
    c.arcTo(rx, rx, 0, 0, 1, w * .5, 0);
    c.arcTo(rx, rx, 0, 0, 1, w * .5 + rx, rx);
    c.arcTo(rx, rx, 0, 0, 1, w * .5 + rx * .2, rx * 1.97);
    c.arcTo(rx * .23, rx * .23, 0, 0, 0, w * .5 + 2, 2.15 * rx);
    var rxMin = Math.max(rx * .1, 6);
    if (rx * .04 > 4) {
        c.lineTo(w * .5 + 2, h - rx * .22);
        c.arcTo(rx * .05, rx * .05, 0, 0, 0, w * .5 + rx * .04, h - rx * .19)
    } else
        c.lineTo(w * .5 + 2, h - 2 * rxMin);
    c.arcTo(rxMin, rxMin, 0, 0, 1, w * .5 + rxMin, h - rxMin);
    c.arcTo(rxMin, rxMin, 0, 0, 1, w * .5, h);
    c.arcTo(rxMin, rxMin, 0, 0, 1, w * .5 - rxMin, h - rxMin);
    if (rx * .04 > 4) {
        c.arcTo(rxMin, rxMin, 0, 0, 1, w * .5 - rx * .04, h - rx * .19);
        c.arcTo(rxMin * .5, rxMin * .5, 0, 0, 0, w * .5 - 2, h - rx * .22)
    } else
        c.arcTo(rxMin, rxMin, 0, 0, 1, w * .5 - 2, h - 2 * rxMin);
    c.close();
    c.moveTo(w * .5, rx * .2);
    c.arcTo(rx * .8, rx * .8, 0, 0, 0, w * .5 - rx * .8, rx * .8);
    c.arcTo(rx * .8, rx * .8, 0, 0, 0, w * .5, rx * 1.8);
    c.arcTo(rx * .8, rx * .8, 0, 0, 0, w * .5 + rx * .8, rx * .8);
    c.arcTo(rx * .8, rx * .8, 0, 0, 0, w * .5, rx * .2);
    c.close();
    c.moveTo(w * .5, h - rxMin * 1.75);
    c.arcTo(rxMin * .75, rxMin * .75, 0, 0, 0, w * .5 - rxMin * .75, h - rxMin);
    c.arcTo(rxMin * .75, rxMin * .75, 0, 0, 0, w * .5, h - rxMin * .25);
    c.arcTo(rxMin * .75, rxMin * .75, 0, 0, 0, w * .5 + rxMin * .75, h - rxMin);
    c.arcTo(rxMin * .75, rxMin * .75, 0, 0, 0, w * .5, h - rxMin * 1.75);
    c.close();
    c.fill();
    c.setFillColor(fillColor);
    c.setShadow(false);
    c.begin();
    c.moveTo(w * .5, rx * .2);
    c.arcTo(rx * .8, rx * .8, 0, 0, 0, w * .5 - rx * .8, rx * .8);
    c.arcTo(rx * .8, rx * .8, 0, 0, 0, w * .5, rx * 1.8);
    c.arcTo(rx * .8, rx * .8, 0, 0, 0, w * .5 + rx * .8, rx * .8);
    c.arcTo(rx * .8, rx * .8, 0, 0, 0, w * .5, rx * .2);
    c.close();
    c.moveTo(w * .5, h - rxMin * 1.75);
    c.arcTo(rxMin * .75, rxMin * .75, 0, 0, 0, w * .5 - rxMin * .75, h - rxMin);
    c.arcTo(rxMin * .75, rxMin * .75, 0, 0, 0, w * .5, h - rxMin * .25);
    c.arcTo(rxMin * .75, rxMin * .75, 0, 0, 0, w * .5 + rxMin * .75, h - rxMin);
    c.arcTo(rxMin * .75, rxMin * .75, 0, 0, 0, w * .5, h - rxMin * 1.75);
    c.close();
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeInfographicCircularCallout2.prototype.cst.CIRCULAR_CALLOUT_2, mxShapeInfographicCircularCallout2);
mxShapeInfographicCircularCallout2.prototype.constraints = null;
function mxShapeInfographicBannerSingleFold(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5;
    this.dy = .5;
    this.dx2 = .5;
    this.notch = .5
}
mxUtils.extend(mxShapeInfographicBannerSingleFold, mxActor);
mxShapeInfographicBannerSingleFold.prototype.cst = {
    BANNER_SINGLE_FOLD: "mxgraph.infographic.bannerSingleFold"
};
mxShapeInfographicBannerSingleFold.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    var dy = Math.max(0, Math.min(h * .5, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    var notch = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "notch", this.notch))));
    dx = Math.min(w - 2 * dy, dx);
    var dx2 = Math.max(0, Math.min(w - dx - 2 * dy, parseFloat(mxUtils.getValue(this.style, "dx2", this.dx2))));
    notch = Math.min(dx, notch);
    c.begin();
    c.moveTo(dx2, 0);
    c.lineTo(w - dx, 0);
    c.lineTo(w - dx, dy);
    c.lineTo(w, dy);
    c.lineTo(w - notch, (h - dy) * .5 + dy);
    c.lineTo(w, h);
    c.lineTo(w - dx - 2 * dy, h);
    c.lineTo(w - dx - 2 * dy, h - dy);
    c.lineTo(dx2, h - dy);
    c.lineTo(0, (h - dy) * .5);
    c.close();
    c.fillAndStroke();
    c.setShadow(false);
    c.setFillAlpha("0.05");
    c.setFillColor("#000000");
    c.begin();
    c.moveTo(w, dy);
    c.lineTo(w - dx, dy);
    c.lineTo(w - dx, h - dy);
    c.lineTo(w - dx - 2 * dy, h);
    c.lineTo(w, h);
    c.lineTo(w - notch, (h - dy) * .5 + dy);
    c.close();
    c.fill();
    c.setFillAlpha("0.4");
    c.begin();
    c.moveTo(w - dx, h - dy);
    c.lineTo(w - dx - 2 * dy, h - dy);
    c.lineTo(w - dx - 2 * dy, h);
    c.close();
    c.fill();
    c.begin();
    c.moveTo(dx2, 0);
    c.lineTo(w - dx, 0);
    c.lineTo(w - dx, dy);
    c.lineTo(w, dy);
    c.lineTo(w - notch, (h - dy) * .5 + dy);
    c.lineTo(w, h);
    c.lineTo(w - dx - 2 * dy, h);
    c.lineTo(w - dx - 2 * dy, h - dy);
    c.lineTo(dx2, h - dy);
    c.lineTo(0, (h - dy) * .5);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeInfographicBannerSingleFold.prototype.cst.BANNER_SINGLE_FOLD, mxShapeInfographicBannerSingleFold);
mxShapeInfographicBannerSingleFold.prototype.constraints = null;
Graph.handleFactory[mxShapeInfographicBannerSingleFold.prototype.cst.BANNER_SINGLE_FOLD] = function(state) {
    var handles = [Graph.createHandle(state, ["dx", "dy"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + bounds.width - dx,bounds.y + dy)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.width, bounds.x + bounds.width - pt.x))) / 100;
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, pt.y - bounds.y))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["notch"], function(bounds) {
        var dy = Math.max(0, Math.min(bounds.height / 2, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var notch = Math.max(0, Math.min(dx, parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch))));
        return new mxPoint(bounds.x + bounds.width - notch,bounds.y + dy + (bounds.height - dy) * .5)
    }, function(bounds, pt) {
        this.state.style["notch"] = Math.round(100 * Math.max(0, Math.min(bounds.width, bounds.width + bounds.x - pt.x))) / 100
    });
    handles.push(handle2);
    var handle3 = Graph.createHandle(state, ["dx2"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        var dx2 = Math.max(0, Math.min(bounds.width - dx, parseFloat(mxUtils.getValue(this.state.style, "dx2", this.dx2))));
        return new mxPoint(bounds.x + dx2,bounds.y + (bounds.height - dy) * .5)
    }, function(bounds, pt) {
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        this.state.style["dx2"] = Math.round(100 * Math.max(0, Math.min(bounds.width - dx - 2 * dy, pt.x - bounds.x))) / 100
    });
    handles.push(handle3);
    return handles
}
;
function mxShapeBasicShadedCube(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.isoAngle = 15
}
mxUtils.extend(mxShapeBasicShadedCube, mxActor);
mxShapeBasicShadedCube.prototype.cst = {
    SHADED_CUBE: "mxgraph.infographic.shadedCube"
};
mxShapeBasicShadedCube.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var isoAngle = Math.max(.01, Math.min(94, parseFloat(mxUtils.getValue(this.style, "isoAngle", this.isoAngle)))) * Math.PI / 200;
    var isoH = Math.min(w * Math.tan(isoAngle), h * .5);
    c.begin();
    c.moveTo(w * .5, 0);
    c.lineTo(w, isoH);
    c.lineTo(w, h - isoH);
    c.lineTo(w * .5, h);
    c.lineTo(0, h - isoH);
    c.lineTo(0, isoH);
    c.close();
    c.fillAndStroke();
    c.setShadow(false);
    c.setFillAlpha("0.2");
    c.setFillColor("#000000");
    c.begin();
    c.moveTo(w * .5, 2 * isoH);
    c.lineTo(w, isoH);
    c.lineTo(w, h - isoH);
    c.lineTo(w * .5, h);
    c.close();
    c.fill();
    c.setFillColor("#ffffff");
    c.begin();
    c.moveTo(w * .5, 2 * isoH);
    c.lineTo(0, isoH);
    c.lineTo(0, h - isoH);
    c.lineTo(w * .5, h);
    c.close();
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeBasicShadedCube.prototype.cst.SHADED_CUBE, mxShapeBasicShadedCube);
mxShapeBasicShadedCube.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicShadedCube.prototype.cst.SHADED_CUBE] = function(state) {
    var handles = [Graph.createHandle(state, ["isoAngle"], function(bounds) {
        var isoAngle = Math.max(.01, Math.min(94, parseFloat(mxUtils.getValue(this.state.style, "isoAngle", this.isoAngle)))) * Math.PI / 200;
        var isoH = Math.min(bounds.width * Math.tan(isoAngle), bounds.height * .5);
        return new mxPoint(bounds.x,bounds.y + isoH)
    }, function(bounds, pt) {
        this.state.style["isoAngle"] = Math.round(100 * Math.max(0, Math.min(100, pt.y - bounds.y))) / 100
    })];
    return handles
}
;
function mxShapeBasicPartConcEllipse(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.startAngle = .25;
    this.endAngle = .75;
    this.arcWidth = .5
}
mxUtils.extend(mxShapeBasicPartConcEllipse, mxActor);
mxShapeBasicPartConcEllipse.prototype.cst = {
    PART_CONC_ELLIPSE: "mxgraph.infographic.partConcEllipse"
};
mxShapeBasicPartConcEllipse.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var startAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "startAngle", this.startAngle))));
    var endAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "endAngle", this.endAngle))));
    var arcWidth = 1 - Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, "arcWidth", this.arcWidth))));
    var rx = w * .5;
    var ry = h * .5;
    var rx2 = rx * arcWidth;
    var ry2 = ry * arcWidth;
    var angDiff = endAngle - startAngle;
    if (angDiff < 0)
        angDiff = angDiff + Math.PI * 2;
    else if (angDiff == Math.PI)
        endAngle = endAngle + 1E-5;
    var startX = rx + Math.sin(startAngle) * rx;
    var startY = ry - Math.cos(startAngle) * ry;
    var innerStartX = rx + Math.sin(startAngle) * rx2;
    var innerStartY = ry - Math.cos(startAngle) * ry2;
    var endX = rx + Math.sin(endAngle) * rx;
    var endY = ry - Math.cos(endAngle) * ry;
    var innerEndX = rx + Math.sin(endAngle) * rx2;
    var innerEndY = ry - Math.cos(endAngle) * ry2;
    var bigArc = 0;
    if (angDiff <= Math.PI)
        bigArc = 1;
    c.begin();
    c.moveTo(rx, 0);
    c.arcTo(rx, ry, 0, 0, 1, w, ry);
    c.arcTo(rx, ry, 0, 0, 1, rx, h);
    c.arcTo(rx, ry, 0, 0, 1, 0, ry);
    c.arcTo(rx, ry, 0, 0, 1, rx, 0);
    c.close();
    c.moveTo(rx, h * .5 - ry2);
    c.arcTo(rx2, ry2, 0, 0, 0, w * .5 - rx2, ry);
    c.arcTo(rx2, ry2, 0, 0, 0, rx, h * .5 + ry2);
    c.arcTo(rx2, ry2, 0, 0, 0, w * .5 + rx2, ry);
    c.arcTo(rx2, ry2, 0, 0, 0, rx, h * .5 - ry2);
    c.close();
    c.fillAndStroke();
    c.setShadow(false);
    c.setFillAlpha("0.2");
    c.setFillColor("#ffffff");
    c.begin();
    c.moveTo(startX, startY);
    c.arcTo(rx, ry, 0, bigArc, 0, endX, endY);
    c.lineTo(innerEndX, innerEndY);
    c.arcTo(rx2, ry2, 0, bigArc, 1, innerStartX, innerStartY);
    c.close();
    c.fill();
    var rx = w * .5;
    var ry = h * .5;
    var rx2 = rx * arcWidth;
    var ry2 = ry * arcWidth;
    var rx3 = rx2 + (rx - rx2) * .25;
    var ry3 = ry2 + (ry - ry2) * .25;
    c.setFillColor("#000000");
    c.begin();
    c.moveTo(rx, h * .5 - ry2);
    c.arcTo(rx2, ry2, 0, 0, 1, w * .5 + rx2, ry);
    c.arcTo(rx2, ry2, 0, 0, 1, rx, h * .5 + ry2);
    c.arcTo(rx2, ry2, 0, 0, 1, w * .5 - rx2, ry);
    c.arcTo(rx2, ry2, 0, 0, 1, rx, h * .5 - ry2);
    c.close();
    c.moveTo(rx, h * .5 - ry3);
    c.arcTo(rx3, ry3, 0, 0, 0, w * .5 - rx3, ry);
    c.arcTo(rx3, ry3, 0, 0, 0, rx, h * .5 + ry3);
    c.arcTo(rx3, ry3, 0, 0, 0, w * .5 + rx3, ry);
    c.arcTo(rx3, ry3, 0, 0, 0, rx, h * .5 - ry3);
    c.close();
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeBasicPartConcEllipse.prototype.cst.PART_CONC_ELLIPSE, mxShapeBasicPartConcEllipse);
mxShapeBasicPartConcEllipse.prototype.constraints = null;
Graph.handleFactory[mxShapeBasicPartConcEllipse.prototype.cst.PART_CONC_ELLIPSE] = function(state) {
    var handles = [Graph.createHandle(state, ["startAngle"], function(bounds) {
        var startAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "startAngle", this.startAngle))));
        return new mxPoint(bounds.x + bounds.width * .5 + Math.sin(startAngle) * bounds.width * .5,bounds.y + bounds.height * .5 - Math.cos(startAngle) * bounds.height * .5)
    }, function(bounds, pt) {
        var handleX = Math.round(100 * Math.max(-1, Math.min(1, (pt.x - bounds.x - bounds.width * .5) / (bounds.width * .5)))) / 100;
        var handleY = -Math.round(100 * Math.max(-1, Math.min(1, (pt.y - bounds.y - bounds.height * .5) / (bounds.height * .5)))) / 100;
        var res = .5 * Math.atan2(handleX, handleY) / Math.PI;
        if (res < 0)
            res = 1 + res;
        this.state.style["startAngle"] = res
    })];
    var handle2 = Graph.createHandle(state, ["endAngle"], function(bounds) {
        var endAngle = 2 * Math.PI * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "endAngle", this.endAngle))));
        return new mxPoint(bounds.x + bounds.width * .5 + Math.sin(endAngle) * bounds.width * .5,bounds.y + bounds.height * .5 - Math.cos(endAngle) * bounds.height * .5)
    }, function(bounds, pt) {
        var handleX = Math.round(100 * Math.max(-1, Math.min(1, (pt.x - bounds.x - bounds.width * .5) / (bounds.width * .5)))) / 100;
        var handleY = -Math.round(100 * Math.max(-1, Math.min(1, (pt.y - bounds.y - bounds.height * .5) / (bounds.height * .5)))) / 100;
        var res = .5 * Math.atan2(handleX, handleY) / Math.PI;
        if (res < 0)
            res = 1 + res;
        this.state.style["endAngle"] = res
    });
    handles.push(handle2);
    var handle3 = Graph.createHandle(state, ["arcWidth"], function(bounds) {
        var arcWidth = Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.state.style, "arcWidth", this.arcWidth))));
        return new mxPoint(bounds.x + bounds.width / 2,bounds.y + arcWidth * bounds.height * .5)
    }, function(bounds, pt) {
        this.state.style["arcWidth"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, (pt.y - bounds.y) / (bounds.height * .5)))) / 100
    });
    handles.push(handle3);
    return handles
}
;
function mxShapeInfographicBannerHalfFold(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5;
    this.dx2 = .5;
    this.notch = .5
}
mxUtils.extend(mxShapeInfographicBannerHalfFold, mxActor);
mxShapeInfographicBannerHalfFold.prototype.cst = {
    BANNER_HALF_FOLD: "mxgraph.infographic.bannerHalfFold"
};
mxShapeInfographicBannerHalfFold.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    var dx2 = Math.max(0, Math.min(w - dx, parseFloat(mxUtils.getValue(this.style, "dx2", this.dx2))));
    var notch = Math.max(0, Math.min(h - dx, parseFloat(mxUtils.getValue(this.style, "notch", this.notch))));
    c.begin();
    c.moveTo(dx2, 0);
    c.lineTo(w - dx, 0);
    c.lineTo(w, dx);
    c.lineTo(w, h);
    c.lineTo(w - dx * .5, h - notch);
    c.lineTo(w - dx, h);
    c.lineTo(w - dx, dx);
    c.lineTo(dx2, dx);
    c.lineTo(0, dx * .5);
    c.close();
    c.fillAndStroke();
    c.setShadow(false);
    c.setFillAlpha("0.2");
    c.setFillColor("#000000");
    c.begin();
    c.moveTo(w - dx, dx);
    c.lineTo(w, dx);
    c.lineTo(w, h);
    c.lineTo(w - dx * .5, h - notch);
    c.lineTo(w - dx, h);
    c.lineTo(w - dx, dx);
    c.lineTo(0, dx);
    c.close();
    c.fill();
    c.begin();
    c.moveTo(dx2, 0);
    c.lineTo(w - dx, 0);
    c.lineTo(w, dx);
    c.lineTo(w, h);
    c.lineTo(w - dx * .5, h - notch);
    c.lineTo(w - dx, h);
    c.lineTo(w - dx, dx);
    c.lineTo(dx2, dx);
    c.lineTo(0, dx * .5);
    c.close();
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeInfographicBannerHalfFold.prototype.cst.BANNER_HALF_FOLD, mxShapeInfographicBannerHalfFold);
mxShapeInfographicBannerHalfFold.prototype.constraints = null;
Graph.handleFactory[mxShapeInfographicBannerHalfFold.prototype.cst.BANNER_HALF_FOLD] = function(state) {
    var handles = [Graph.createHandle(state, ["dx"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        return new mxPoint(bounds.x + bounds.width - dx,bounds.y + dx)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.width, bounds.x + bounds.width - pt.x))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["notch"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var notch = Math.max(0, Math.min(bounds.height - dx, parseFloat(mxUtils.getValue(this.state.style, "notch", this.notch))));
        return new mxPoint(bounds.x + bounds.width - dx * .5,bounds.y + bounds.height - notch)
    }, function(bounds, pt) {
        this.state.style["notch"] = Math.round(100 * Math.max(0, Math.min(bounds.height, bounds.height + bounds.y - pt.y))) / 100
    });
    handles.push(handle2);
    var handle3 = Graph.createHandle(state, ["dx2"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dx2 = Math.max(0, Math.min(bounds.width - dx, parseFloat(mxUtils.getValue(this.state.style, "dx2", this.dx2))));
        return new mxPoint(bounds.x + dx2,bounds.y + dx)
    }, function(bounds, pt) {
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        this.state.style["dx2"] = Math.round(100 * Math.max(0, Math.min(bounds.width - dx, pt.x - bounds.x))) / 100
    });
    handles.push(handle3);
    return handles
}
;
function mxShapeInfographicCircularDial(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dy = .5
}
mxUtils.extend(mxShapeInfographicCircularDial, mxActor);
mxShapeInfographicCircularDial.prototype.cst = {
    CIRCULAR_DIAL: "mxgraph.infographic.circularDial"
};
mxShapeInfographicCircularDial.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dy = Math.max(0, Math.min(h * .5 - 10, w * .5, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    var rx = Math.max(0, Math.min(w * .5, h * .5 - 10));
    var rx2 = rx - dy;
    c.begin();
    c.moveTo(w * .5 - rx, h);
    c.lineTo(w * .5 - rx, rx);
    c.arcTo(rx, rx, 0, 0, 1, w * .5, 0);
    c.arcTo(rx, rx, 0, 0, 1, w * .5 + rx, rx);
    c.lineTo(w * .5 + rx, h);
    c.close();
    c.moveTo(w * .5, dy);
    c.arcTo(rx2, rx2, 0, 0, 0, w * .5 - rx2, rx);
    c.arcTo(rx2, rx2, 0, 0, 0, w * .5, rx + rx2);
    c.arcTo(rx2, rx2, 0, 0, 0, w * .5 + rx2, rx);
    c.arcTo(rx2, rx2, 0, 0, 0, w * .5, dy);
    c.close();
    c.fillAndStroke();
    c.setShadow(false);
    c.setFillAlpha("0.2");
    c.setFillColor("#000000");
    c.begin();
    c.moveTo(w * .5 - rx, 2 * rx);
    c.lineTo(w * .5 + rx, 2 * rx);
    c.lineTo(w * .5 + rx, h);
    c.lineTo(w * .5 - rx, h);
    c.close();
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeInfographicCircularDial.prototype.cst.CIRCULAR_DIAL, mxShapeInfographicCircularDial);
mxShapeInfographicCircularDial.prototype.constraints = null;
Graph.handleFactory[mxShapeInfographicCircularDial.prototype.cst.CIRCULAR_DIAL] = function(state) {
    var handles = [Graph.createHandle(state, ["dy"], function(bounds) {
        var dy = Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + bounds.width * .5,bounds.y + dy)
    }, function(bounds, pt) {
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(bounds.height / 2, bounds.width / 2, pt.y - bounds.y))) / 100
    })];
    return handles
}
;
function mxShapeInfographicRibbonSimple(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.notch1 = .5;
    this.notch2 = .5
}
mxUtils.extend(mxShapeInfographicRibbonSimple, mxActor);
mxShapeInfographicRibbonSimple.prototype.cst = {
    RIBBON_SIMPLE: "mxgraph.infographic.ribbonSimple"
};
mxShapeInfographicRibbonSimple.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var notch1 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "notch1", this.notch2))));
    var notch2 = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "notch2", this.notch2))));
    c.begin();
    c.moveTo(0, h);
    c.lineTo(notch1, h * .5);
    c.lineTo(0, 0);
    c.lineTo(w - notch2, 0);
    c.lineTo(w, h * .5);
    c.lineTo(w - notch2, h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeInfographicRibbonSimple.prototype.cst.RIBBON_SIMPLE, mxShapeInfographicRibbonSimple);
mxShapeInfographicRibbonSimple.prototype.constraints = null;
Graph.handleFactory[mxShapeInfographicRibbonSimple.prototype.cst.RIBBON_SIMPLE] = function(state) {
    var handles = [Graph.createHandle(state, ["notch1"], function(bounds) {
        var notch1 = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "notch1", this.notch1))));
        return new mxPoint(bounds.x + notch1,bounds.y + bounds.height * .5)
    }, function(bounds, pt) {
        this.state.style["notch1"] = Math.round(100 * Math.max(0, Math.min(bounds.width, pt.x - bounds.x))) / 100
    })];
    var handle2 = Graph.createHandle(state, ["notch2"], function(bounds) {
        var notch2 = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "notch2", this.notch2))));
        return new mxPoint(bounds.x + bounds.width - notch2,bounds.y)
    }, function(bounds, pt) {
        this.state.style["notch2"] = Math.round(100 * Math.max(0, Math.min(bounds.width, bounds.width + bounds.x - pt.x))) / 100
    });
    handles.push(handle2);
    return handles
}
;
function mxShapeInfographicBarCallout(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5;
    this.dy = .5
}
mxUtils.extend(mxShapeInfographicBarCallout, mxActor);
mxShapeInfographicBarCallout.prototype.cst = {
    BAR_CALLOUT: "mxgraph.infographic.barCallout"
};
mxShapeInfographicBarCallout.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    var x1 = Math.max(dx - dy * .35, 0);
    var x2 = Math.min(dx + dy * .35, w);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h - dy);
    c.lineTo(x2, h - dy);
    c.lineTo(dx, h);
    c.lineTo(x1, h - dy);
    c.lineTo(0, h - dy);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeInfographicBarCallout.prototype.cst.BAR_CALLOUT, mxShapeInfographicBarCallout);
mxShapeInfographicBarCallout.prototype.constraints = null;
Graph.handleFactory[mxShapeInfographicBarCallout.prototype.cst.BAR_CALLOUT] = function(state) {
    var handles = [Graph.createHandle(state, ["dx", "dy"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + dx,bounds.y + bounds.height - dy)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.width, pt.x - bounds.x))) / 100;
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(bounds.height, bounds.y + bounds.height - pt.y))) / 100
    })];
    return handles
}
;
function mxShapeInfographicFlag(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1;
    this.dx = .5;
    this.dy = .5
}
mxUtils.extend(mxShapeInfographicFlag, mxActor);
mxShapeInfographicFlag.prototype.cst = {
    FLAG: "mxgraph.infographic.flag"
};
mxShapeInfographicFlag.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dx = Math.max(0, Math.min(w, parseFloat(mxUtils.getValue(this.style, "dx", this.dx))));
    var dy = Math.max(0, Math.min(h, parseFloat(mxUtils.getValue(this.style, "dy", this.dy))));
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h - dy);
    c.lineTo(dx, h - dy);
    c.lineTo(dx * .5, h);
    c.lineTo(0, h - dy);
    c.close();
    c.fillAndStroke();
    c.setShadow(false);
    c.setFillAlpha("0.2");
    c.setFillColor("#ffffff");
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(dx, 0);
    c.lineTo(dx, h - dy);
    c.lineTo(dx * .5, h);
    c.lineTo(0, h - dy);
    c.close();
    c.fill()
}
;
mxCellRenderer.registerShape(mxShapeInfographicFlag.prototype.cst.FLAG, mxShapeInfographicFlag);
mxShapeInfographicFlag.prototype.constraints = null;
Graph.handleFactory[mxShapeInfographicFlag.prototype.cst.FLAG] = function(state) {
    var handles = [Graph.createHandle(state, ["dx", "dy"], function(bounds) {
        var dx = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx", this.dx))));
        var dy = Math.max(0, Math.min(bounds.height, parseFloat(mxUtils.getValue(this.state.style, "dy", this.dy))));
        return new mxPoint(bounds.x + dx,bounds.y + bounds.height - dy)
    }, function(bounds, pt) {
        this.state.style["dx"] = Math.round(100 * Math.max(0, Math.min(bounds.width, pt.x - bounds.x))) / 100;
        this.state.style["dy"] = Math.round(100 * Math.max(0, Math.min(bounds.height, bounds.y + bounds.height - pt.y))) / 100
    })];
    return handles
}
;
function mxLeanBoatShipment(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxLeanBoatShipment, mxShape);
mxLeanBoatShipment.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.moveTo(w * .15, h * .77);
    c.lineTo(w * .5, 0);
    c.lineTo(w * .85, h * .77);
    c.close();
    c.moveTo(w * .2, h);
    c.lineTo(0, h * .8);
    c.lineTo(w, h * .8);
    c.lineTo(w * .8, h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.boat_shipment", mxLeanBoatShipment);
mxLeanBoatShipment.prototype.constraints = [new mxConnectionConstraint(new mxPoint(.5,0),false), new mxConnectionConstraint(new mxPoint(.5,1),false), new mxConnectionConstraint(new mxPoint(0,.8),false), new mxConnectionConstraint(new mxPoint(1,.8),false), new mxConnectionConstraint(new mxPoint(.2,1),false), new mxConnectionConstraint(new mxPoint(.8,1),false), new mxConnectionConstraint(new mxPoint(.26,.5),false), new mxConnectionConstraint(new mxPoint(.74,.5),false)];
function mxLeanSafetyStock(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxLeanSafetyStock, mxShape);
mxLeanSafetyStock.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxLeanSafetyStock.prototype.background = function(c, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxLeanSafetyStock.prototype.foreground = function(c, w, h) {
    c.begin();
    c.moveTo(0, h * .34);
    c.lineTo(w, h * .34);
    c.moveTo(0, h * .66);
    c.lineTo(w, h * .66);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.buffer_or_safety_stock", mxLeanSafetyStock);
mxLeanSafetyStock.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0,0),true), new mxConnectionConstraint(new mxPoint(1,0),true), new mxConnectionConstraint(new mxPoint(0,1),true), new mxConnectionConstraint(new mxPoint(1,1),true), new mxConnectionConstraint(new mxPoint(.25,0),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.75,0),true), new mxConnectionConstraint(new mxPoint(0,.25),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(0,.75),true), new mxConnectionConstraint(new mxPoint(1,.25),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(1,.75),true), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true)];
function mxLeanDataBox(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxLeanDataBox, mxShape);
mxLeanDataBox.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxLeanDataBox.prototype.background = function(c, w, h) {
    c.begin();
    c.moveTo(0, h);
    c.lineTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h);
    c.fillAndStroke()
}
;
mxLeanDataBox.prototype.foreground = function(c, w, h) {
    c.begin();
    c.moveTo(0, h * .2);
    c.lineTo(w, h * .2);
    c.moveTo(0, h * .4);
    c.lineTo(w, h * .4);
    c.moveTo(0, h * .6);
    c.lineTo(w, h * .6);
    c.moveTo(0, h * .8);
    c.lineTo(w, h * .8);
    c.stroke()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.data_box", mxLeanDataBox);
mxLeanDataBox.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0,0),true), new mxConnectionConstraint(new mxPoint(1,0),true), new mxConnectionConstraint(new mxPoint(0,1),true), new mxConnectionConstraint(new mxPoint(1,1),true), new mxConnectionConstraint(new mxPoint(.25,0),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.75,0),true), new mxConnectionConstraint(new mxPoint(0,.25),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(0,.75),true), new mxConnectionConstraint(new mxPoint(1,.25),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(1,.75),true), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true)];
function mxLeanCustomerSupplier(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxLeanCustomerSupplier, mxShape);
mxLeanCustomerSupplier.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false)
}
;
mxLeanCustomerSupplier.prototype.background = function(c, w, h) {
    c.begin();
    c.moveTo(0, h);
    c.lineTo(0, h * .3);
    c.lineTo(w * .33, h * .02);
    c.lineTo(w * .33, h * .3);
    c.lineTo(w * .67, h * .02);
    c.lineTo(w * .67, h * .3);
    c.lineTo(w, h * .02);
    c.lineTo(w, h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.outside_sources", mxLeanCustomerSupplier);
mxLeanCustomerSupplier.prototype.constraints = [new mxConnectionConstraint(new mxPoint(1,0),true), new mxConnectionConstraint(new mxPoint(0,1),true), new mxConnectionConstraint(new mxPoint(1,1),true), new mxConnectionConstraint(new mxPoint(.33,0),true), new mxConnectionConstraint(new mxPoint(.67,0),true), new mxConnectionConstraint(new mxPoint(0,.3),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(0,.75),true), new mxConnectionConstraint(new mxPoint(1,.25),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(1,.75),true), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true)];
function mxLeanDedicatedProcess(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxLeanDedicatedProcess, mxShape);
mxLeanDedicatedProcess.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var fontSize = parseFloat(mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "8"));
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h, fontSize)
}
;
mxLeanDedicatedProcess.prototype.background = function(c, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxLeanDedicatedProcess.prototype.foreground = function(c, w, h, fontSize) {
    var lineH = Math.min(fontSize * 1.5, h);
    c.begin();
    c.moveTo(0, lineH);
    c.lineTo(w, lineH);
    c.stroke()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.manufacturing_process", mxLeanDedicatedProcess);
mxLeanDedicatedProcess.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0,0),true), new mxConnectionConstraint(new mxPoint(1,0),true), new mxConnectionConstraint(new mxPoint(0,1),true), new mxConnectionConstraint(new mxPoint(1,1),true), new mxConnectionConstraint(new mxPoint(.25,0),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.75,0),true), new mxConnectionConstraint(new mxPoint(0,.25),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(0,.75),true), new mxConnectionConstraint(new mxPoint(1,.25),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(1,.75),true), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true)];
function mxLeanSharedProcess(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxLeanSharedProcess, mxShape);
mxLeanSharedProcess.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var fontSize = parseFloat(mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "8"));
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h, fontSize)
}
;
mxLeanSharedProcess.prototype.background = function(c, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxLeanSharedProcess.prototype.foreground = function(c, w, h, fontSize) {
    var lineH = Math.min(fontSize * 1.5, h);
    c.begin();
    c.moveTo(0, lineH);
    c.lineTo(w, lineH);
    c.stroke();
    var start = 0;
    var i = 0;
    var s = 10;
    var offset = 0;
    c.begin();
    var strokeWidth = parseFloat(mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, "2"));
    c.setStrokeWidth(strokeWidth * .5);
    while (start < h + w) {
        start = start + s;
        if (start > lineH) {
            var startX = Math.max(0, start - h);
            var startY = Math.min(start, h);
            var endX = Math.min(start - lineH, w);
            var endY = lineH;
            var endY = Math.max(start - w, lineH);
            if (startX < w) {
                c.moveTo(startX, startY);
                c.lineTo(endX, endY)
            }
        }
    }
    c.stroke()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.manufacturing_process_shared", mxLeanSharedProcess);
mxLeanSharedProcess.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0,0),true), new mxConnectionConstraint(new mxPoint(1,0),true), new mxConnectionConstraint(new mxPoint(0,1),true), new mxConnectionConstraint(new mxPoint(1,1),true), new mxConnectionConstraint(new mxPoint(.25,0),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.75,0),true), new mxConnectionConstraint(new mxPoint(0,.25),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(0,.75),true), new mxConnectionConstraint(new mxPoint(1,.25),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(1,.75),true), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true)];
function mxLeanWorkcell(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxLeanWorkcell, mxShape);
mxLeanWorkcell.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(w * .65, h);
    c.lineTo(w * .65, h * .4);
    c.lineTo(w * .35, h * .4);
    c.lineTo(w * .35, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.work_cell", mxLeanWorkcell);
mxLeanWorkcell.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0,0),true), new mxConnectionConstraint(new mxPoint(1,0),true), new mxConnectionConstraint(new mxPoint(0,1),true), new mxConnectionConstraint(new mxPoint(1,1),true), new mxConnectionConstraint(new mxPoint(.25,0),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.75,0),true), new mxConnectionConstraint(new mxPoint(0,.25),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(0,.75),true), new mxConnectionConstraint(new mxPoint(1,.25),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(1,.75),true), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true)];
function mxLeanInventoryBox(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxLeanInventoryBox, mxShape);
mxLeanInventoryBox.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.moveTo(0, h);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h);
    c.close();
    c.fillAndStroke();
    c.setShadow(false);
    c.begin();
    c.moveTo(w * .4, h * .45);
    c.lineTo(w * .6, h * .45);
    c.moveTo(w * .5, h * .45);
    c.lineTo(w * .5, h * .85);
    c.moveTo(w * .4, h * .85);
    c.lineTo(w * .6, h * .85);
    c.stroke()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.inventory_box", mxLeanInventoryBox);
mxLeanInventoryBox.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0,1),true), new mxConnectionConstraint(new mxPoint(1,1),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.375,.25),false), new mxConnectionConstraint(new mxPoint(.25,.5),false), new mxConnectionConstraint(new mxPoint(.125,.75),false), new mxConnectionConstraint(new mxPoint(.625,.25),false), new mxConnectionConstraint(new mxPoint(.75,.5),false), new mxConnectionConstraint(new mxPoint(.875,.75),false), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true)];
function mxLeanPushArrow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxLeanPushArrow, mxShape);
mxLeanPushArrow.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxLeanPushArrow.prototype.background = function(c, w, h) {
    c.begin();
    c.moveTo(0, h * .17);
    c.lineTo(w * .75, h * .17);
    c.lineTo(w * .75, 0);
    c.lineTo(w, h * .5);
    c.lineTo(w * .75, h);
    c.lineTo(w * .75, h * .83);
    c.lineTo(0, h * .83);
    c.close();
    c.fillAndStroke()
}
;
mxLeanPushArrow.prototype.foreground = function(c, w, h, fontSize) {
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    c.setFillColor(strokeColor);
    c.rect(0, h * .17, w * .12, h * .66);
    c.fill();
    c.rect(w * .24, h * .17, w * .12, h * .66);
    c.fill();
    c.rect(w * .48, h * .17, w * .12, h * .66);
    c.fill();
    c.begin();
    c.moveTo(w * .72, h * .17);
    c.lineTo(w * .75, h * .17);
    c.lineTo(w * .75, 0);
    c.lineTo(w, h * .5);
    c.lineTo(w * .75, h);
    c.lineTo(w * .75, h * .83);
    c.lineTo(w * .72, h * .83);
    c.close();
    c.fill()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.push_arrow", mxLeanPushArrow);
mxLeanPushArrow.prototype.constraints = [new mxConnectionConstraint(new mxPoint(.25,.17),false), new mxConnectionConstraint(new mxPoint(.5,.17),false), new mxConnectionConstraint(new mxPoint(.75,0),true), new mxConnectionConstraint(new mxPoint(0,.17),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(0,.83),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(.25,.83),false), new mxConnectionConstraint(new mxPoint(.5,.83),false), new mxConnectionConstraint(new mxPoint(.75,1),true)];
function mxLeanSupermarket(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxLeanSupermarket, mxShape);
mxLeanSupermarket.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.moveTo(0, h * .33);
    c.lineTo(w, h * .33);
    c.moveTo(0, h * .67);
    c.lineTo(w, h * .67);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.supermarket", mxLeanSupermarket);
mxLeanSupermarket.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0,0),true), new mxConnectionConstraint(new mxPoint(1,0),true), new mxConnectionConstraint(new mxPoint(0,1),true), new mxConnectionConstraint(new mxPoint(1,1),true), new mxConnectionConstraint(new mxPoint(.25,0),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.75,0),true), new mxConnectionConstraint(new mxPoint(0,.25),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(0,.75),true), new mxConnectionConstraint(new mxPoint(1,.25),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(1,.75),true), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true)];
function mxLeanMaterialPull(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxLeanMaterialPull, mxShape);
mxLeanMaterialPull.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.moveTo(w * .732, h * .0736);
    c.arcTo(w * .4827, h * .4959, 0, 1, 0, w * .9553, h * .6191);
    c.stroke();
    c.begin();
    c.moveTo(w * .9071, h * .6191);
    c.lineTo(w * .9794, h * .4951);
    c.lineTo(w, h * .6438);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.physical_pull", mxLeanMaterialPull);
mxLeanMaterialPull.prototype.constraints = [new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(.98,.5),true), new mxConnectionConstraint(new mxPoint(.144,.144),false), new mxConnectionConstraint(new mxPoint(.144,.845),false), new mxConnectionConstraint(new mxPoint(.845,.845),false)];
function mxLeanFifoLane(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxLeanFifoLane, mxShape);
mxLeanFifoLane.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var fontSize = parseFloat(mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "8"));
    this.background(c, w, h, fontSize);
    c.setShadow(false)
}
;
mxLeanFifoLane.prototype.background = function(c, w, h, fontSize) {
    var lineH = Math.min(fontSize * 1.5, h);
    c.begin();
    c.moveTo(0, lineH);
    c.lineTo(w, lineH);
    c.moveTo(0, h);
    c.lineTo(w, h);
    c.stroke();
    c.rect(w * .02, lineH + 4, w * .26, h - lineH - 8);
    c.fillAndStroke();
    c.ellipse(w * .35, lineH + 4, w * .26, h - lineH - 8);
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .69, lineH + 4);
    c.lineTo(w * .98, lineH + 4);
    c.lineTo(w * .835, h - 4);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.fifo_lane", mxLeanFifoLane);
mxLeanFifoLane.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0,1),true), new mxConnectionConstraint(new mxPoint(1,1),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(0,.25),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(0,.75),true), new mxConnectionConstraint(new mxPoint(1,.25),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(1,.75),true), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true)];
function mxLeanTruckShipment(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxLeanTruckShipment, mxShape);
mxLeanTruckShipment.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false)
}
;
mxLeanTruckShipment.prototype.background = function(c, w, h) {
    c.rect(0, 0, w * .6, h * .8);
    c.fillAndStroke();
    c.rect(w * .6, h * .35, w * .4, h * .45);
    c.fillAndStroke();
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    c.setFillColor(strokeColor);
    c.ellipse(w * .15, h * .8, w * .2, h * .2);
    c.fillAndStroke();
    c.ellipse(w * .65, h * .8, w * .2, h * .2);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.truck_shipment", mxLeanTruckShipment);
mxLeanTruckShipment.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0,0),true), new mxConnectionConstraint(new mxPoint(.25,0),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(0,.25),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(0,.75),true), new mxConnectionConstraint(new mxPoint(.6,.35),false), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(1,.75),true), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.5,.8),false), new mxConnectionConstraint(new mxPoint(.75,1),true)];
function mxLeanProductionControl(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxLeanProductionControl, mxShape);
mxLeanProductionControl.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.schedule", mxLeanProductionControl);
mxLeanProductionControl.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0,0),true), new mxConnectionConstraint(new mxPoint(1,0),true), new mxConnectionConstraint(new mxPoint(0,1),true), new mxConnectionConstraint(new mxPoint(1,1),true), new mxConnectionConstraint(new mxPoint(.25,0),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.75,0),true), new mxConnectionConstraint(new mxPoint(0,.25),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(0,.75),true), new mxConnectionConstraint(new mxPoint(1,.25),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(1,.75),true), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true)];
function mxLeanFifoSequence(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxLeanFifoSequence, mxShape);
mxLeanFifoSequence.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.moveTo(0, h);
    c.lineTo(w, h);
    c.moveTo(w * .05, h * .5);
    c.lineTo(w * .15, h * .5);
    c.moveTo(w * .75, h * .5);
    c.lineTo(w * .88, h * .5);
    c.stroke();
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .88, h * .39);
    c.lineTo(w * .98, h * .5);
    c.lineTo(w * .88, h * .61);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.fifo_sequence_flow", mxLeanFifoSequence);
mxLeanFifoSequence.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0,0),true), new mxConnectionConstraint(new mxPoint(1,0),true), new mxConnectionConstraint(new mxPoint(0,1),true), new mxConnectionConstraint(new mxPoint(1,1),true), new mxConnectionConstraint(new mxPoint(.25,0),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.75,0),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true)];
function mxLeanProductionKanban(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxLeanProductionKanban, mxShape);
mxLeanProductionKanban.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.setDashed(true);
    c.begin();
    c.moveTo(4, h - 10);
    c.lineTo(4, 25);
    c.lineTo(w, 25);
    c.stroke();
    c.setDashed(false);
    c.begin();
    c.moveTo(w - 75, 0);
    c.lineTo(w - 30, 0);
    c.lineTo(w - 15, 15);
    c.lineTo(w - 15, 50);
    c.lineTo(w - 75, 50);
    c.close();
    c.fillAndStroke();
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(0, h - 10);
    c.lineTo(4, h);
    c.lineTo(8, h - 10);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.production_kanban", mxLeanProductionKanban);
function mxLeanWithdrawalKanban(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxLeanWithdrawalKanban, mxShape);
mxLeanWithdrawalKanban.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.setDashed(true);
    c.begin();
    c.moveTo(4, h - 10);
    c.lineTo(4, 25);
    c.lineTo(w, 25);
    c.stroke();
    c.setDashed(false);
    c.begin();
    c.moveTo(w - 75, 0);
    c.lineTo(w - 30, 0);
    c.lineTo(w - 15, 15);
    c.lineTo(w - 15, 50);
    c.lineTo(w - 75, 50);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w - 75, 45);
    c.lineTo(w - 70, 50);
    c.moveTo(w - 75, 35);
    c.lineTo(w - 60, 50);
    c.moveTo(w - 75, 25);
    c.lineTo(w - 50, 50);
    c.moveTo(w - 75, 15);
    c.lineTo(w - 40, 50);
    c.moveTo(w - 75, 5);
    c.lineTo(w - 30, 50);
    c.moveTo(w - 70, 0);
    c.lineTo(w - 20, 50);
    c.moveTo(w - 60, 0);
    c.lineTo(w - 15, 45);
    c.moveTo(w - 50, 0);
    c.lineTo(w - 15, 35);
    c.moveTo(w - 40, 0);
    c.lineTo(w - 15, 25);
    c.stroke();
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(0, h - 10);
    c.lineTo(4, h);
    c.lineTo(8, h - 10);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.withdrawal_kanban", mxLeanWithdrawalKanban);
function mxLeanSignalKanban(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxLeanSignalKanban, mxShape);
mxLeanSignalKanban.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.setDashed(true);
    c.begin();
    c.moveTo(4, h - 10);
    c.lineTo(4, 15);
    c.lineTo(w, 15);
    c.stroke();
    c.setDashed(false);
    c.begin();
    c.moveTo(w - 65, 0);
    c.lineTo(w - 25, 0);
    c.lineTo(w - 45, 45);
    c.close();
    c.fillAndStroke();
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(0, h - 10);
    c.lineTo(4, h);
    c.lineTo(8, h - 10);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.signal_kanban", mxLeanSignalKanban);
function mxLeanSequencedPullBall(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxLeanSequencedPullBall, mxShape);
mxLeanSequencedPullBall.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.ellipse(0, 0, w, h);
    c.fillAndStroke();
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    c.setFillColor(strokeColor);
    c.setShadow(false);
    c.ellipse(w * .15, h * .15, w * .7, h * .7);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.sequenced_pull_ball", mxLeanSequencedPullBall);
mxLeanSequencedPullBall.prototype.constraints = [new mxConnectionConstraint(new mxPoint(.144,.144),false), new mxConnectionConstraint(new mxPoint(.856,.144),false), new mxConnectionConstraint(new mxPoint(.856,.856),false), new mxConnectionConstraint(new mxPoint(.144,.856),false), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.5,1),true)];
function mxLeanRailShipment(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxLeanRailShipment, mxShape);
mxLeanRailShipment.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.rect(w * .1, 0, w * .35, h * .8);
    c.fillAndStroke();
    c.rect(w * .55, 0, w * .35, h * .8);
    c.fillAndStroke();
    c.begin();
    c.moveTo(0, h);
    c.lineTo(w, h);
    c.moveTo(w * .45, h * .7);
    c.lineTo(w * .55, h * .7);
    c.stroke();
    c.ellipse(w * .15, h * .8, w * .06, h * .2);
    c.fillAndStroke();
    c.ellipse(w * .34, h * .8, w * .06, h * .2);
    c.fillAndStroke();
    c.ellipse(w * .6, h * .8, w * .06, h * .2);
    c.fillAndStroke();
    c.ellipse(w * .79, h * .8, w * .06, h * .2);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.rail_shipment", mxLeanRailShipment);
mxLeanRailShipment.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0,1),true), new mxConnectionConstraint(new mxPoint(1,1),true), new mxConnectionConstraint(new mxPoint(.25,0),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.75,0),true), new mxConnectionConstraint(new mxPoint(.1,.25),false), new mxConnectionConstraint(new mxPoint(.1,.5),false), new mxConnectionConstraint(new mxPoint(.1,.75),false), new mxConnectionConstraint(new mxPoint(.9,.25),false), new mxConnectionConstraint(new mxPoint(.9,.5),false), new mxConnectionConstraint(new mxPoint(.9,.75),false), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true)];
function mxLeanWarehouse(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxLeanWarehouse, mxShape);
mxLeanWarehouse.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.rect(0, 0, w, h);
    c.fillAndStroke();
    c.setShadow(false);
    c.begin();
    c.moveTo(0, h * .4);
    c.lineTo(w, h * .4);
    c.moveTo(w * .15, h);
    c.lineTo(w * .15, h * .55);
    c.lineTo(w * .3, h * .55);
    c.lineTo(w * .3, h);
    c.stroke();
    c.ellipse(w * .27, h * .75, w * .02, w * .02);
    c.stroke()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.warehouse", mxLeanWarehouse);
mxLeanWarehouse.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0,0),true), new mxConnectionConstraint(new mxPoint(1,0),true), new mxConnectionConstraint(new mxPoint(0,1),true), new mxConnectionConstraint(new mxPoint(1,1),true), new mxConnectionConstraint(new mxPoint(.25,0),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.75,0),true), new mxConnectionConstraint(new mxPoint(0,.25),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(0,.75),true), new mxConnectionConstraint(new mxPoint(1,.25),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(1,.75),true), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true)];
function mxLeanTimeline(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxLeanTimeline, mxShape);
mxLeanTimeline.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var shapeInfo = mxUtils.getValue(this.style, "mainText", "20,Time 1,50,Time 2,30,Time 3,40,Time 4,30,Time 5,50,Time 6,20,Time 7").toString().split(",");
    var fontSize = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, "12");
    var times = new Array;
    var totalTime = 0;
    for (var i = 0; i < shapeInfo.length; i = i + 2) {
        var currTime = parseFloat(shapeInfo[i]);
        times.push(currTime);
        totalTime = totalTime + currTime
    }
    var scaleX = w / totalTime;
    var names = new Array;
    for (var i = 1; i < shapeInfo.length; i = i + 2)
        names.push(shapeInfo[i]);
    c.begin();
    var currX = 0;
    c.moveTo(0, h);
    for (var i = 0; i < names.length; i++) {
        var currTime = times[i] * scaleX;
        currX = currX + currTime;
        if (i % 2 === 0) {
            c.lineTo(currX, h);
            c.lineTo(currX, fontSize * 1.5);
            c.text(currX - currTime * .5, h - fontSize * .75, 0, 0, names[i], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
        } else {
            c.lineTo(currX, fontSize * 1.5);
            c.lineTo(currX, h);
            c.text(currX - currTime * .5, fontSize * .75, 0, 0, names[i], mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
        }
    }
    c.stroke()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.timeline", mxLeanTimeline);
function mxLeanCrossDock(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxLeanCrossDock, mxShape);
mxLeanCrossDock.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.rect(0, 0, w, h);
    c.fillAndStroke();
    c.setShadow(false);
    c.begin();
    c.moveTo(0, h * .25);
    c.lineTo(w, h * .25);
    c.moveTo(w * .1, h * .4);
    c.lineTo(w * .35, h * .4);
    c.arcTo(w * .15, h * .15, 0, 0, 1, w * .5, h * .5);
    c.arcTo(w * .15, h * .15, 0, 0, 0, w * .65, h * .6);
    c.lineTo(w * .9, h * .6);
    c.stroke();
    c.moveTo(w * .1, h * .4);
    c.lineTo(w * .35, h * .4);
    c.arcTo(w * .15, h * .25, 0, 0, 1, w * .5, h * .55);
    c.arcTo(w * .15, h * .25, 0, 0, 0, w * .65, h * .7);
    c.lineTo(w * .9, h * .7);
    c.stroke();
    c.moveTo(w * .1, h * .4);
    c.lineTo(w * .35, h * .4);
    c.arcTo(w * .15, h * .3, 0, 0, 1, w * .5, h * .6);
    c.arcTo(w * .15, h * .3, 0, 0, 0, w * .65, h * .8);
    c.lineTo(w * .9, h * .8);
    c.stroke();
    c.moveTo(w * .1, h * .8);
    c.lineTo(w * .35, h * .8);
    c.arcTo(w * .15, h * .3, 0, 0, 0, w * .5, h * .6);
    c.arcTo(w * .15, h * .3, 0, 0, 1, w * .65, h * .4);
    c.lineTo(w * .9, h * .4);
    c.stroke();
    c.moveTo(w * .1, h * .8);
    c.lineTo(w * .35, h * .8);
    c.arcTo(w * .15, h * .1, 0, 0, 0, w * .5, h * .75);
    c.arcTo(w * .15, h * .1, 0, 0, 1, w * .65, h * .7);
    c.lineTo(w * .9, h * .7);
    c.stroke()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.crossDock", mxLeanCrossDock);
mxLeanCrossDock.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0,0),true), new mxConnectionConstraint(new mxPoint(1,0),true), new mxConnectionConstraint(new mxPoint(0,1),true), new mxConnectionConstraint(new mxPoint(1,1),true), new mxConnectionConstraint(new mxPoint(.25,0),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.75,0),true), new mxConnectionConstraint(new mxPoint(0,.25),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(0,.75),true), new mxConnectionConstraint(new mxPoint(1,.25),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(1,.75),true), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true)];
function mxLeanOrders(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxLeanOrders, mxShape);
mxLeanOrders.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.rect(0, h * .56, w, h * .44);
    c.fillAndStroke();
    var strokeWidth = parseFloat(mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, "2"));
    c.setStrokeWidth(strokeWidth * .5);
    c.begin();
    c.moveTo(w * .04, h * .5418);
    c.lineTo(w * .94, h * .5418);
    c.moveTo(w * .0522, h * .5088);
    c.lineTo(w * .9522, h * .5088);
    c.moveTo(w * .05, h * .4738);
    c.lineTo(w * .95, h * .4738);
    c.moveTo(w * .0456, h * .4427);
    c.lineTo(w * .9456, h * .4427);
    c.moveTo(w * .0422, h * .4135);
    c.lineTo(w * .9422, h * .4135);
    c.moveTo(w * .0533, h * .3804);
    c.lineTo(w * .9533, h * .3804);
    c.moveTo(w * .0556, h * .3454);
    c.lineTo(w * .9556, h * .3454);
    c.moveTo(w * .05, h * .3143);
    c.lineTo(w * .95, h * .3143);
    c.moveTo(w * .0489, h * .2832);
    c.lineTo(w * .0489, h * .2832);
    c.moveTo(w * .0544, h * .254);
    c.lineTo(w * .9544, h * .254);
    c.moveTo(w * .0489, h * .221);
    c.lineTo(w * .9489, h * .221);
    c.moveTo(w * .0556, h * .1918);
    c.lineTo(w * .9556, h * .1918);
    c.moveTo(w * .0522, h * .1587);
    c.lineTo(w * .9522, h * .1587);
    c.moveTo(w * .0544, h * .1276);
    c.lineTo(w * .9544, h * .1276);
    c.moveTo(w * .0544, h * .0965);
    c.lineTo(w * .9544, h * .0965);
    c.moveTo(w * .0556, h * .0654);
    c.lineTo(w * .9556, h * .0654);
    c.moveTo(w * .0533, h * .0304);
    c.lineTo(w * .9533, h * .0304);
    c.moveTo(w * .0556, 0);
    c.lineTo(w * .9556, 0);
    c.stroke()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.orders", mxLeanOrders);
mxLeanOrders.prototype.constraints = [new mxConnectionConstraint(new mxPoint(.05,0),true), new mxConnectionConstraint(new mxPoint(.95,0),true), new mxConnectionConstraint(new mxPoint(0,1),true), new mxConnectionConstraint(new mxPoint(1,1),true), new mxConnectionConstraint(new mxPoint(.25,0),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.75,0),true), new mxConnectionConstraint(new mxPoint(.05,.25),false), new mxConnectionConstraint(new mxPoint(.05,.5),false), new mxConnectionConstraint(new mxPoint(0,.75),true), new mxConnectionConstraint(new mxPoint(.95,.25),false), new mxConnectionConstraint(new mxPoint(.95,.5),false), new mxConnectionConstraint(new mxPoint(1,.75),true), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true)];
function mxLeanBatchedKanban(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxLeanBatchedKanban, mxShape);
mxLeanBatchedKanban.prototype.paintVertexShape = function(c, x, y, w, h) {
    w = Math.max(110, w);
    c.translate(x, y);
    c.begin();
    c.moveTo(4, h * .5);
    c.lineTo(w, h * .5);
    c.stroke();
    c.begin();
    c.moveTo(w * .5 - 20, h * .5 - 35);
    c.lineTo(w * .5 + 25, h * .5 - 35);
    c.lineTo(w * .5 + 40, h * .5 - 20);
    c.lineTo(w * .5 + 40, h * .5 + 15);
    c.lineTo(w * .5 - 20, h * .5 + 15);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .5 - 30, h * .5 - 25);
    c.lineTo(w * .5 + 15, h * .5 - 25);
    c.lineTo(w * .5 + 30, h * .5 - 10);
    c.lineTo(w * .5 + 30, h * .5 + 25);
    c.lineTo(w * .5 - 30, h * .5 + 25);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .5 - 40, h * .5 - 15);
    c.lineTo(w * .5 + 5, h * .5 - 15);
    c.lineTo(w * .5 + 20, h * .5);
    c.lineTo(w * .5 + 20, h * .5 + 35);
    c.lineTo(w * .5 - 40, h * .5 + 35);
    c.close();
    c.fillAndStroke();
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w - 10, h * .5 - 4);
    c.lineTo(w, h * .5);
    c.lineTo(w - 10, h * .5 + 4);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.batched_kanban", mxLeanBatchedKanban);
mxLeanBatchedKanban.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(1,.5),true)];
function mxLeanControlCenter(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxLeanControlCenter, mxShape);
mxLeanControlCenter.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.rect(w * .15, 0, w * .7, h * .8);
    c.fillAndStroke();
    c.rect(0, h * .8, w, h * .2);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.control_center", mxLeanControlCenter);
mxLeanControlCenter.prototype.constraints = [new mxConnectionConstraint(new mxPoint(.15,0),true), new mxConnectionConstraint(new mxPoint(.85,0),true), new mxConnectionConstraint(new mxPoint(0,1),true), new mxConnectionConstraint(new mxPoint(1,1),true), new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.15,.25),false), new mxConnectionConstraint(new mxPoint(.15,.5),false), new mxConnectionConstraint(new mxPoint(0,.75),true), new mxConnectionConstraint(new mxPoint(.85,.25),false), new mxConnectionConstraint(new mxPoint(.85,.5),false), new mxConnectionConstraint(new mxPoint(1,.75),true), new mxConnectionConstraint(new mxPoint(.25,1),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(.75,1),true)];
function LeanElectronicInfoShape() {
    mxArrow.call(this)
}
mxUtils.extend(LeanElectronicInfoShape, mxArrow);
LeanElectronicInfoShape.prototype.paintEdgeShape = function(c, pts) {
    var p0 = pts[0];
    var pe = pts[pts.length - 1];
    var dx = pe.x - p0.x;
    var dy = pe.y - p0.y;
    p0.x = p0.x + dx * .05;
    p0.y = p0.y + dy * .05;
    pe.x = pe.x - dx * .05;
    pe.y = pe.y - dy * .05;
    dx = pe.x - p0.x;
    dy = pe.y - p0.y;
    var dist = Math.sqrt(dx * dx + dy * dy);
    var nx = dx / dist;
    var ny = dy / dist;
    var midX = p0.x + dx * .5;
    var midY = p0.y + dy * .5;
    var p1x = midX - nx * dist * .1 - ny / 3 * dist * .1;
    var p1y = midY - ny * dist * .1 + nx / 3 * dist * .1;
    var p4x = midX + nx * dist * .1 + ny / 3 * dist * .1;
    var p4y = midY + ny * dist * .1 - nx / 3 * dist * .1;
    c.begin();
    c.moveTo(p0.x, p0.y);
    c.lineTo(p4x, p4y);
    c.lineTo(p1x, p1y);
    c.lineTo(pe.x, pe.y);
    c.stroke();
    var dx = pe.x - p1x;
    var dy = pe.y - p1y;
    var dist = Math.sqrt(dx * dx + dy * dy);
    var nx = dx / dist;
    var ny = dy / dist;
    c.setFillColor(mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000"));
    c.begin();
    c.moveTo(pe.x - nx * 10 - ny * 5, pe.y - ny * 10 + nx * 5);
    c.lineTo(pe.x, pe.y);
    c.lineTo(pe.x - nx * 10 + ny * 5, pe.y - ny * 10 - nx * 5);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.electronic_info_flow_edge", LeanElectronicInfoShape);
function LeanManualInfoShape() {
    mxArrow.call(this)
}
mxUtils.extend(LeanManualInfoShape, mxArrow);
LeanManualInfoShape.prototype.paintEdgeShape = function(c, pts) {
    var p0 = pts[0];
    var pe = pts[pts.length - 1];
    var dx = pe.x - p0.x;
    var dy = pe.y - p0.y;
    p0.x = p0.x + dx * .05;
    p0.y = p0.y + dy * .05;
    pe.x = pe.x - dx * .05;
    pe.y = pe.y - dy * .05;
    dx = pe.x - p0.x;
    dy = pe.y - p0.y;
    var dist = Math.sqrt(dx * dx + dy * dy);
    var nx = dx / dist;
    var ny = dy / dist;
    c.begin();
    c.moveTo(p0.x, p0.y);
    c.lineTo(pe.x, pe.y);
    c.stroke();
    c.setFillColor(mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000"));
    c.begin();
    c.moveTo(pe.x - nx * 10 - ny * 5, pe.y - ny * 10 + nx * 5);
    c.lineTo(pe.x, pe.y);
    c.lineTo(pe.x - nx * 10 + ny * 5, pe.y - ny * 10 - nx * 5);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape("mxgraph.lean_mapping.manual_info_flow_edge", LeanManualInfoShape);
function mxShapeLeanTimeline(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeLeanTimeline, mxShape);
mxShapeLeanTimeline.prototype.cst = {
    SHAPE_TIMELINE: "mxgraph.lean_mapping.timeline2"
};
mxShapeLeanTimeline.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var dy1 = mxUtils.getValue(this.style, "dy1", "0");
    var dx2 = mxUtils.getValue(this.style, "dx2", "0");
    var dy2 = mxUtils.getValue(this.style, "dy2", "0");
    var dx3 = mxUtils.getValue(this.style, "dx3", "0");
    var dy3 = mxUtils.getValue(this.style, "dy3", "0");
    var dx4 = mxUtils.getValue(this.style, "dx4", "0");
    var dy4 = mxUtils.getValue(this.style, "dy4", "0");
    var dx5 = mxUtils.getValue(this.style, "dx5", "0");
    var dy5 = mxUtils.getValue(this.style, "dy5", "0");
    var dy6 = mxUtils.getValue(this.style, "dy6", "0");
    var lastUp = true;
    c.begin();
    if (dy1 <= .5) {
        c.moveTo(0, 0);
        lastUp = true
    } else {
        c.moveTo(0, h);
        lastUp = false
    }
    if (dy2 <= .5 && lastUp) {
        c.lineTo(dx2, 0);
        lastUp = true
    } else if (dy2 > .5 && !lastUp) {
        c.lineTo(dx2, h);
        lastUp = false
    } else if (dy2 <= .5 && !lastUp) {
        c.lineTo(dx2, h);
        c.lineTo(dx2, 0);
        lastUp = true
    } else {
        c.lineTo(dx2, 0);
        c.lineTo(dx2, h);
        lastUp = false
    }
    if (dy3 <= .5 && lastUp) {
        c.lineTo(dx3, 0);
        lastUp = true
    } else if (dy3 > .5 && !lastUp) {
        c.lineTo(dx3, h);
        lastUp = false
    } else if (dy3 <= .5 && !lastUp) {
        c.lineTo(dx3, h);
        c.lineTo(dx3, 0);
        lastUp = true
    } else {
        c.lineTo(dx3, 0);
        c.lineTo(dx3, h);
        lastUp = false
    }
    if (dy4 <= .5 && lastUp) {
        c.lineTo(dx4, 0);
        lastUp = true
    } else if (dy4 > .5 && !lastUp) {
        c.lineTo(dx4, h);
        lastUp = false
    } else if (dy4 <= .5 && !lastUp) {
        c.lineTo(dx4, h);
        c.lineTo(dx4, 0);
        lastUp = true
    } else {
        c.lineTo(dx4, 0);
        c.lineTo(dx4, h);
        lastUp = false
    }
    if (dy5 <= .5 && lastUp) {
        c.lineTo(dx5, 0);
        lastUp = true
    } else if (dy5 > .5 && !lastUp) {
        c.lineTo(dx5, h);
        lastUp = false
    } else if (dy5 <= .5 && !lastUp) {
        c.lineTo(dx5, h);
        c.lineTo(dx5, 0);
        lastUp = true
    } else {
        c.lineTo(dx5, 0);
        c.lineTo(dx5, h);
        lastUp = false
    }
    if (dy6 <= .5 && lastUp) {
        c.lineTo(w, 0);
        lastUp = true
    } else if (dy6 > .5 && !lastUp) {
        c.lineTo(w, h);
        lastUp = false
    } else if (dy6 <= .5 && !lastUp) {
        c.lineTo(w, h);
        c.lineTo(w, 0);
        lastUp = true
    } else {
        c.lineTo(w, 0);
        c.lineTo(w, h);
        lastUp = false
    }
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeLeanTimeline.prototype.cst.SHAPE_TIMELINE, mxShapeLeanTimeline);
Graph.handleFactory[mxShapeLeanTimeline.prototype.cst.SHAPE_TIMELINE] = function(state) {
    var handles = [Graph.createHandle(state, ["dy1"], function(bounds) {
        var dy1 = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, "dy1", 0))));
        return new mxPoint(bounds.x,bounds.y + dy1 * bounds.height)
    }, function(bounds, pt) {
        this.state.style["dy1"] = Math.round(1E3 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height))) / 1E3
    })];
    var handle2 = Graph.createHandle(state, ["dx2", "dy2"], function(bounds) {
        var dx2 = Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, "dx3", 0)), parseFloat(mxUtils.getValue(this.state.style, "dx2", 0))));
        var dy2 = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, "dy2", 0))));
        return new mxPoint(bounds.x + dx2,bounds.y + dy2 * bounds.height)
    }, function(bounds, pt) {
        this.state.style["dx2"] = Math.round(1E3 * Math.max(0, Math.min(parseFloat(mxUtils.getValue(this.state.style, "dx3", 0)), pt.x - bounds.x))) / 1E3;
        this.state.style["dy2"] = Math.round(1E3 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height))) / 1E3
    });
    handles.push(handle2);
    var handle3 = Graph.createHandle(state, ["dx3", "dy3"], function(bounds) {
        var dx3 = Math.max(parseFloat(mxUtils.getValue(this.state.style, "dx2", 0)), Math.min(parseFloat(mxUtils.getValue(this.state.style, "dx4", 0)), parseFloat(mxUtils.getValue(this.state.style, "dx3", 0))));
        var dy3 = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, "dy3", 0))));
        return new mxPoint(bounds.x + dx3,bounds.y + dy3 * bounds.height)
    }, function(bounds, pt) {
        this.state.style["dx3"] = Math.round(1E3 * Math.max(parseFloat(mxUtils.getValue(this.state.style, "dx2", 0)), Math.min(parseFloat(mxUtils.getValue(this.state.style, "dx4", 0)), pt.x - bounds.x))) / 1E3;
        this.state.style["dy3"] = Math.round(1E3 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height))) / 1E3
    });
    handles.push(handle3);
    var handle4 = Graph.createHandle(state, ["dx4", "dy4"], function(bounds) {
        var dx4 = Math.max(parseFloat(mxUtils.getValue(this.state.style, "dx3", 0)), Math.min(parseFloat(mxUtils.getValue(this.state.style, "dx5", 0)), parseFloat(mxUtils.getValue(this.state.style, "dx4", 0))));
        var dy4 = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, "dy4", 0))));
        return new mxPoint(bounds.x + dx4,bounds.y + dy4 * bounds.height)
    }, function(bounds, pt) {
        this.state.style["dx4"] = Math.round(1E3 * Math.max(parseFloat(mxUtils.getValue(this.state.style, "dx3", 0)), Math.min(parseFloat(mxUtils.getValue(this.state.style, "dx5", 0)), pt.x - bounds.x))) / 1E3;
        this.state.style["dy4"] = Math.round(1E3 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height))) / 1E3
    });
    handles.push(handle4);
    var handle5 = Graph.createHandle(state, ["dx5", "dy5"], function(bounds) {
        var dx5 = Math.max(parseFloat(mxUtils.getValue(this.state.style, "dx4", 0)), Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "dx5", 0))));
        var dy5 = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, "dy5", 0))));
        return new mxPoint(bounds.x + dx5,bounds.y + dy5 * bounds.height)
    }, function(bounds, pt) {
        this.state.style["dx5"] = Math.round(1E3 * Math.max(parseFloat(mxUtils.getValue(this.state.style, "dx4", 0)), Math.min(bounds.width, pt.x - bounds.x))) / 1E3;
        this.state.style["dy5"] = Math.round(1E3 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height))) / 1E3
    });
    handles.push(handle5);
    var handle6 = Graph.createHandle(state, ["dy6"], function(bounds) {
        var dy6 = Math.max(0, Math.min(100, parseFloat(mxUtils.getValue(this.state.style, "dy6", 0))));
        return new mxPoint(bounds.x + bounds.width,bounds.y + dy6 * bounds.height)
    }, function(bounds, pt) {
        this.state.style["dy6"] = Math.round(1E3 * Math.max(0, Math.min(1, (pt.y - bounds.y) / bounds.height))) / 1E3
    });
    handles.push(handle6);
    return handles
}
;
function mxShapeNetworksBus(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeNetworksBus, mxShape);
mxShapeNetworksBus.prototype.cst = {
    SHAPE_BUS: "mxgraph.networks.bus"
};
mxShapeNetworksBus.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeNetworksBus.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(8, h * .5 + 10);
    c.arcTo(12, 12, 0, 0, 1, 8, h * .5 - 10);
    c.lineTo(w - 8, h * .5 - 10);
    c.arcTo(12, 12, 0, 0, 1, w - 8, h * .5 + 10);
    c.close();
    c.fillAndStroke()
}
;
mxShapeNetworksBus.prototype.foreground = function(c, x, y, w, h) {
    c.setFillColor("#ffffff");
    c.begin();
    c.moveTo(w - 8, h * .5 - 10);
    c.arcTo(12, 12, 0, 0, 1, w - 8, h * .5 + 10);
    c.arcTo(12, 12, 0, 0, 1, w - 8, h * .5 - 10);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeNetworksBus.prototype.cst.SHAPE_BUS, mxShapeNetworksBus);
function mxShapeNetworksCommLinkEdge() {
    mxArrow.call(this)
}
mxUtils.extend(mxShapeNetworksCommLinkEdge, mxArrow);
mxShapeNetworksCommLinkEdge.prototype.paintEdgeShape = function(c, pts) {
    var p0 = pts[0];
    var pe = pts[pts.length - 1];
    var dx = pe.x - p0.x;
    var dy = pe.y - p0.y;
    p0.x = p0.x + dx * .05;
    p0.y = p0.y + dy * .05;
    pe.x = pe.x - dx * .05;
    pe.y = pe.y - dy * .05;
    dx = pe.x - p0.x;
    dy = pe.y - p0.y;
    var dist = Math.sqrt(dx * dx + dy * dy);
    var nx = dx / dist;
    var ny = dy / dist;
    var midX = p0.x + dx * .5;
    var midY = p0.y + dy * .5;
    var p1x = midX + nx * dist / 3 * .1 - ny / 3 * dist * .1;
    var p1y = midY + ny * dist / 3 * .1 + nx / 3 * dist * .1;
    var p2x = midX + nx * dist * .1 + ny * dist * .1;
    var p2y = midY + ny * dist * .1 - nx * dist * .1;
    var p3x = midX - nx * dist / 3 * .1 + ny / 3 * dist * .1;
    var p3y = midY - ny * dist / 3 * .1 - nx / 3 * dist * .1;
    var p4x = midX - nx * dist * .1 - ny * dist * .1;
    var p4y = midY - ny * dist * .1 + nx * dist * .1;
    c.begin();
    c.moveTo(p0.x, p0.y);
    c.lineTo(p2x, p2y);
    c.lineTo(p1x, p1y);
    c.lineTo(pe.x, pe.y);
    c.lineTo(p4x, p4y);
    c.lineTo(p3x, p3y);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape("mxgraph.networks.comm_link_edge", mxShapeNetworksCommLinkEdge);
function mxShapeSysMLComposite() {
    mxCylinder.call(this)
}
mxUtils.extend(mxShapeSysMLComposite, mxShape);
mxShapeSysMLComposite.prototype.isHtmlAllowed = function() {
    return false
}
;
mxShapeSysMLComposite.prototype.paintForeground = function(c, x, y, w, h) {
    if (this.style != null) {
        var shape = mxCellRenderer.defaultShapes[this.style["symbol0"]];
        c.save();
        var tmp = new shape;
        tmp.style = this.style;
        shape.prototype.paintVertexShape.call(tmp, c, x, y, w, h);
        c.restore();
        c.setDashed(false);
        var counter = 1;
        do {
            shape = mxCellRenderer.defaultShapes[this.style["symbol" + counter]];
            if (shape != null) {
                var align = this.style["symbol" + counter + "Align"];
                var valign = this.style["symbol" + counter + "VerticalAlign"];
                var width = this.style["symbol" + counter + "Width"];
                var height = this.style["symbol" + counter + "Height"];
                var spacing = this.style["symbol" + counter + "Spacing"] || 0;
                var vspacing = this.style["symbol" + counter + "VSpacing"] || 0;
                var arcspacing = this.style["symbol" + counter + "ArcSpacing"];
                var direction = this.style["symbol" + counter + "Direction"];
                if (arcspacing != null) {
                    spacing += this.getArcSize(w + this.strokewidth, h + this.strokewidth) * arcspacing;
                    vspacing += this.getArcSize(w + this.strokewidth, h + this.strokewidth) * arcspacing
                }
                var x2 = x;
                var y2 = y;
                if (align == mxConstants.ALIGN_CENTER)
                    x2 += (w - width) / 2;
                else if (align == mxConstants.ALIGN_RIGHT)
                    x2 += w - width - spacing;
                else
                    x2 += spacing;
                if (valign == mxConstants.ALIGN_MIDDLE)
                    y2 += (h - height) / 2;
                else if (valign == mxConstants.ALIGN_BOTTOM)
                    y2 += h - height - vspacing;
                else
                    y2 += vspacing;
                c.save();
                var tmp = new shape;
                tmp.style = mxUtils.clone(this.style);
                tmp.direction = direction;
                tmp.updateTransform(c, x2, y2, width, height);
                shape.prototype.paintVertexShape.call(tmp, c, x2, y2, width, height);
                c.restore()
            }
            counter++
        } while (shape != null)
    }
}
;
mxCellRenderer.registerShape("mxgraph.sysml.composite", mxShapeSysMLComposite);
function mxShapeSysMLPackage(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLPackage, mxShape);
mxShapeSysMLPackage.prototype.cst = {
    PACKAGE: "mxgraph.sysml.package",
    LABEL_X: "labelX"
};
mxShapeSysMLPackage.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeSysMLPackage.prototype.background = function(c, x, y, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeSysMLPackage.prototype.foreground = function(c, x, y, w, h) {
    var xSize = parseInt(mxUtils.getValue(this.style, mxShapeSysMLPackage.prototype.cst.LABEL_X, "90"));
    var ySize = 20;
    xSize = Math.min(xSize, w);
    if (xSize > ySize) {
        c.begin();
        c.moveTo(0, ySize);
        c.lineTo(xSize - ySize * .5, ySize);
        c.lineTo(xSize, ySize * .5);
        c.lineTo(xSize, 0);
        c.stroke()
    }
}
;
mxCellRenderer.registerShape(mxShapeSysMLPackage.prototype.cst.PACKAGE, mxShapeSysMLPackage);
Graph.handleFactory[mxShapeSysMLPackage.prototype.cst.PACKAGE] = function(state) {
    var handles = [Graph.createHandle(state, ["labelX"], function(bounds) {
        var labelX = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "labelX", 90))));
        return new mxPoint(bounds.x + labelX,bounds.y + 10)
    }, function(bounds, pt) {
        this.state.style["labelX"] = Math.round(100 * Math.max(0, Math.min(bounds.width, pt.x - bounds.x))) / 100
    })];
    return handles
}
;
function mxShapeSysMLPackage2(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLPackage2, mxShape);
mxShapeSysMLPackage2.prototype.cst = {
    PACKAGE2: "mxgraph.sysml.package2",
    LABEL_X: "labelX"
};
mxShapeSysMLPackage2.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeSysMLPackage2.prototype.background = function(c, x, y, w, h) {
    c.rect(0, 0, w, h);
    c.stroke()
}
;
mxShapeSysMLPackage2.prototype.foreground = function(c, x, y, w, h) {
    var xSize = parseInt(mxUtils.getValue(this.style, mxShapeSysMLPackage2.prototype.cst.LABEL_X, "90"));
    var ySize = 20;
    xSize = Math.min(xSize, w);
    if (xSize > ySize) {
        c.begin();
        c.moveTo(0, ySize);
        c.lineTo(xSize - ySize * .5, ySize);
        c.lineTo(xSize, ySize * .5);
        c.lineTo(xSize, 0);
        c.lineTo(0, 0);
        c.close();
        c.fillAndStroke()
    }
}
;
mxCellRenderer.registerShape(mxShapeSysMLPackage2.prototype.cst.PACKAGE2, mxShapeSysMLPackage2);
Graph.handleFactory[mxShapeSysMLPackage2.prototype.cst.PACKAGE2] = function(state) {
    var handles = [Graph.createHandle(state, ["labelX"], function(bounds) {
        var labelX = Math.max(0, Math.min(bounds.width, parseFloat(mxUtils.getValue(this.state.style, "labelX", 90))));
        return new mxPoint(bounds.x + labelX,bounds.y + 10)
    }, function(bounds, pt) {
        this.state.style["labelX"] = Math.round(100 * Math.max(0, Math.min(bounds.width, pt.x - bounds.x))) / 100
    })];
    return handles
}
;
function mxShapeSysMLNone(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLNone, mxShape);
mxShapeSysMLNone.prototype.cst = {
    NONE: "mxgraph.sysml.none"
};
mxShapeSysMLNone.prototype.paintVertexShape = function(c, x, y, w, h) {}
;
mxCellRenderer.registerShape(mxShapeSysMLNone.prototype.cst.NONE, mxShapeSysMLNone);
function mxShapeSysMLRect(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLRect, mxShape);
mxShapeSysMLRect.prototype.cst = {
    RECT: "mxgraph.sysml.rect"
};
mxShapeSysMLRect.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.rect(x, y, w, h);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLRect.prototype.cst.RECT, mxShapeSysMLRect);
function mxShapeSysMLPortOne(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLPortOne, mxShape);
mxShapeSysMLPortOne.prototype.cst = {
    PORT1: "mxgraph.sysml.port1"
};
mxShapeSysMLPortOne.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.rect(x + w * .05, y, w - w * .1, h);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLPortOne.prototype.cst.PORT1, mxShapeSysMLPortOne);
function mxShapeSysMLPortTwo(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLPortTwo, mxShape);
mxShapeSysMLPortTwo.prototype.cst = {
    PORT2: "mxgraph.sysml.port2"
};
mxShapeSysMLPortTwo.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.rect(x + w * .05, y, w * .8, h);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLPortTwo.prototype.cst.PORT2, mxShapeSysMLPortTwo);
function mxShapeSysMLPortThree(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLPortThree, mxShape);
mxShapeSysMLPortThree.prototype.cst = {
    PORT3: "mxgraph.sysml.port3"
};
mxShapeSysMLPortThree.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.rect(x + w * .07, y, w * .86, h);
    c.fillAndStroke();
    c.rect(x, y + h * .125, w * .14, h * .25);
    c.fillAndStroke();
    c.rect(x, y + h * .625, w * .14, h * .25);
    c.fillAndStroke();
    c.rect(x + w * .86, y + h * .375, w * .14, h * .25);
    c.fillAndStroke();
    this.drawIn(c, x + w * .01, y + h * .2, w * .11, h * .1);
    this.drawOut(c, x + w * .02, y + h * .7, w * .11, h * .1);
    this.drawInOut(c, x + w * .88, y + h * .45, w * .1, h * .1)
}
;
mxShapeSysMLPortThree.prototype.drawIn = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(x, y + h * .5);
    c.lineTo(x + w, y + h * .5);
    c.moveTo(x + w * .75, y);
    c.lineTo(x + w, y + h * .5);
    c.lineTo(x + w * .75, y + h);
    c.stroke()
}
;
mxShapeSysMLPortThree.prototype.drawOut = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(x, y + h * .5);
    c.lineTo(x + w, y + h * .5);
    c.moveTo(x + w * .25, y);
    c.lineTo(x, y + h * .5);
    c.lineTo(x + w * .25, y + h);
    c.stroke()
}
;
mxShapeSysMLPortThree.prototype.drawInOut = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(x + w * .75, y);
    c.lineTo(x + w, y + h * .5);
    c.lineTo(x + w * .75, y + h);
    c.moveTo(x + w * .25, y);
    c.lineTo(x, y + h * .5);
    c.lineTo(x + w * .25, y + h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLPortThree.prototype.cst.PORT3, mxShapeSysMLPortThree);
function mxShapeSysMLPortFour(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLPortFour, mxShape);
mxShapeSysMLPortFour.prototype.cst = {
    PORT4: "mxgraph.sysml.port4"
};
mxShapeSysMLPortFour.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.rect(x + w * .05, y, w - w * .05, h);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLPortFour.prototype.cst.PORT4, mxShapeSysMLPortFour);
mxShapeSysMLPortFour.prototype.constraints = [new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(1,.5),true)];
function mxShapeSysMLItemFlow(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLItemFlow, mxShape);
mxShapeSysMLItemFlow.prototype.cst = {
    ITEM_FLOW: "mxgraph.sysml.itemFlow",
    FLOW_DIR: "flowDir",
    FLOW_TYPE: "flowType"
};
mxShapeSysMLItemFlow.prototype.paintVertexShape = function(c, x, y, w, h) {
    var flowDir = mxUtils.getValue(this.style, mxShapeSysMLItemFlow.prototype.cst.FLOW_DIR, "none").toLowerCase();
    var flowType = mxUtils.getValue(this.style, mxShapeSysMLItemFlow.prototype.cst.FLOW_TYPE, "none");
    if (flowDir === "n") {
        c.rect(x, y + 10, w, h - 10);
        c.fillAndStroke();
        c.setShadow(false);
        c.rect(x + w * .5 - 10, y, 20, 20);
        c.fillAndStroke();
        if (flowType === "in")
            this.drawDown(c, x + w * .5 - 5, y + 2, 10, 16);
        else if (flowType === "out")
            this.drawUp(c, x + w * .5 - 5, y + 2, 10, 16)
    } else if (flowDir === "s") {
        c.rect(x, y, w, h - 10);
        c.fillAndStroke();
        c.setShadow(false);
        c.rect(x + w * .5 - 10, y + h - 20, 20, 20);
        c.fillAndStroke();
        if (flowType === "in")
            this.drawUp(c, x + w * .5 - 5, y + h - 18, 10, 16);
        else if (flowType === "out")
            this.drawDown(c, x + w * .5 - 5, y + h - 18, 10, 16)
    } else if (flowDir === "w") {
        c.rect(x + 10, y, w - 10, h);
        c.fillAndStroke();
        c.setShadow(false);
        c.rect(x, y + h * .5 - 10, 20, 20);
        c.fillAndStroke();
        if (flowType === "in")
            this.drawRight(c, x + 2, y + h * .5 - 5, 16, 10);
        else if (flowType === "out")
            this.drawLeft(c, x + 2, y + h * .5 - 5, 16, 10)
    } else if (flowDir === "e") {
        c.rect(x, y, w - 10, h);
        c.fillAndStroke();
        c.setShadow(false);
        c.rect(x + w - 20, y + h * .5 - 10, 20, 20);
        c.fillAndStroke();
        if (flowType === "in")
            this.drawLeft(c, x + w - 18, y + h * .5 - 5, 16, 10);
        else if (flowType === "out")
            this.drawRight(c, x + w - 18, y + h * .5 - 5, 16, 10)
    }
}
;
mxShapeSysMLItemFlow.prototype.drawRight = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(x, y + h * .5);
    c.lineTo(x + w, y + h * .5);
    c.moveTo(x + w * .75, y);
    c.lineTo(x + w, y + h * .5);
    c.lineTo(x + w * .75, y + h);
    c.stroke()
}
;
mxShapeSysMLItemFlow.prototype.drawDown = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(x + w * .5, y);
    c.lineTo(x + w * .5, y + h);
    c.moveTo(x, y + h * .75);
    c.lineTo(x + w * .5, y + h);
    c.lineTo(x + w, y + h * .75);
    c.stroke()
}
;
mxShapeSysMLItemFlow.prototype.drawLeft = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(x, y + h * .5);
    c.lineTo(x + w, y + h * .5);
    c.moveTo(x + w * .25, y);
    c.lineTo(x, y + h * .5);
    c.lineTo(x + w * .25, y + h);
    c.stroke()
}
;
mxShapeSysMLItemFlow.prototype.drawUp = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(x + w * .5, y + h);
    c.lineTo(x + w * .5, y);
    c.moveTo(x, y + h * .25);
    c.lineTo(x + w * .5, y);
    c.lineTo(x + w, y + h * .25);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLItemFlow.prototype.cst.ITEM_FLOW, mxShapeSysMLItemFlow);
mxShapeSysMLItemFlow.prototype.constraints = [new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(0,.5),true)];
function mxShapeSysMLItemFlowLeft(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLItemFlowLeft, mxShape);
mxShapeSysMLItemFlowLeft.prototype.cst = {
    ITEM_FLOW_LEFT: "mxgraph.sysml.itemFlowLeft"
};
mxShapeSysMLItemFlowLeft.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.rect(x + 10, y, w - 10, h);
    c.fillAndStroke();
    c.rect(x, y + h * .25 - 10, 20, 20);
    c.fillAndStroke();
    c.rect(x, y + h * .5 - 10, 20, 20);
    c.fillAndStroke();
    c.rect(x, y + h * .75 - 10, 20, 20);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLItemFlowLeft.prototype.cst.ITEM_FLOW_LEFT, mxShapeSysMLItemFlowLeft);
mxShapeSysMLItemFlowLeft.prototype.constraints = [new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(0,.25),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(0,.75),true)];
function mxShapeSysMLItemFlowRight(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLItemFlowRight, mxShape);
mxShapeSysMLItemFlowRight.prototype.cst = {
    ITEM_FLOW_RIGHT: "mxgraph.sysml.itemFlowRight"
};
mxShapeSysMLItemFlowRight.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.rect(x, y, w - 10, h);
    c.fillAndStroke();
    c.rect(x + w - 20, y + h * .25 - 10, 20, 20);
    c.fillAndStroke();
    c.rect(x + w - 20, y + h * .5 - 10, 20, 20);
    c.fillAndStroke();
    c.rect(x + w - 20, y + h * .75 - 10, 20, 20);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLItemFlowRight.prototype.cst.ITEM_FLOW_RIGHT, mxShapeSysMLItemFlowRight);
mxShapeSysMLItemFlowRight.prototype.constraints = [new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(1,.25),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(1,.75),true)];
function mxShapeSysMLNestedPort(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLNestedPort, mxShape);
mxShapeSysMLNestedPort.prototype.cst = {
    NESTED_PORT: "mxgraph.sysml.nestedPort"
};
mxShapeSysMLNestedPort.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.rect(x + w * .08, y, w * .92, h);
    c.fillAndStroke();
    c.rect(x + w * .03, y + h * .1, w * .1, h * .8);
    c.fillAndStroke();
    c.rect(x, y + h * .15, w * .06, h * .16);
    c.fillAndStroke();
    c.rect(x, y + h * .42, w * .06, h * .16);
    c.fillAndStroke();
    c.rect(x, y + h * .69, w * .06, h * .16);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLNestedPort.prototype.cst.NESTED_PORT, mxShapeSysMLNestedPort);
mxMarker.addMarker("sysMLPackCont", function(c, shape, type, pe, unitX, unitY, size, source, sw, filled) {
    var nx = unitX * (size + sw + 1);
    var ny = unitY * (size + sw + 1);
    var a = size / 2;
    return function() {
        c.begin();
        c.moveTo(pe.x - nx / 2 - ny / 2, pe.y - ny / 2 + nx / 2);
        c.lineTo(pe.x - nx / 2 + ny / 2, pe.y - ny / 2 - nx / 2);
        c.stroke();
        c.ellipse(pe.x - .5 * nx - a, pe.y - .5 * ny - a, 2 * a, 2 * a);
        c.stroke()
    }
});
mxMarker.addMarker("sysMLReqInt", function(c, shape, type, pe, unitX, unitY, size, source, sw, filled) {
    var nx = unitX * (size + sw + 1);
    var ny = unitY * (size + sw + 1);
    var a = size / 2;
    return function() {
        var fillColor = mxUtils.getValue(shape.style, mxConstants.STYLE_FILLCOLOR, "none");
        c.setFillColor(fillColor);
        c.ellipse(pe.x - .5 * nx - a, pe.y - .5 * ny - a, 2 * a, 2 * a);
        c.fillAndStroke()
    }
});
mxMarker.addMarker("sysMLProvInt", function(c, shape, type, pe, unitX, unitY, size, source, sw, filled) {
    var nx = unitX * (size + sw + 1);
    var ny = unitY * (size + sw + 1);
    var a = size / 2;
    return function() {
        var fillColor = mxUtils.getValue(shape.style, mxConstants.STYLE_FILLCOLOR, "none");
        c.setFillColor(fillColor);
        c.begin();
        c.moveTo(pe.x - ny / 2, pe.y + nx / 2);
        c.arcTo(a, a, 0, 0, 1, pe.x + ny / 2, pe.y - nx / 2);
        c.fillAndStroke()
    }
});
function mxShapeSysMLParametricDiagram(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLParametricDiagram, mxShape);
mxShapeSysMLParametricDiagram.prototype.cst = {
    PARAM_DGM: "mxgraph.sysml.paramDgm"
};
mxShapeSysMLParametricDiagram.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.roundrect(x, y, w, h, 10, 10);
    c.fillAndStroke();
    c.setShadow(false);
    if (h > 60) {
        c.rect(x, y + h * .25 - 10, 20, 20);
        c.stroke();
        c.rect(x, y + h * .75 - 10, 20, 20);
        c.stroke()
    }
}
;
mxCellRenderer.registerShape(mxShapeSysMLParametricDiagram.prototype.cst.PARAM_DGM, mxShapeSysMLParametricDiagram);
function mxShapeSysMLConstraintProperty(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLConstraintProperty, mxShape);
mxShapeSysMLConstraintProperty.prototype.cst = {
    CONS_PROP: "mxgraph.sysml.consProp"
};
mxShapeSysMLConstraintProperty.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.rect(x, y, w, h);
    c.fillAndStroke();
    c.setShadow(false);
    if (h > 60) {
        c.rect(x, y + 50, 20, 20);
        c.stroke();
        c.rect(x, y + 80, 20, 20);
        c.stroke()
    }
}
;
mxCellRenderer.registerShape(mxShapeSysMLConstraintProperty.prototype.cst.CONS_PROP, mxShapeSysMLConstraintProperty);
function mxShapeSysMLCallBehaviorAction(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLCallBehaviorAction, mxShape);
mxShapeSysMLCallBehaviorAction.prototype.cst = {
    CALL_BEH_ACT: "mxgraph.sysml.callBehAct"
};
mxShapeSysMLCallBehaviorAction.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.roundrect(x, y, w, h, 10, 10);
    c.fillAndStroke();
    if (h > 30 && w > 40) {
        c.setShadow(false);
        this.drawSymb(c, x + w - 30, y + h - 30, 20, 20)
    }
}
;
mxShapeSysMLCallBehaviorAction.prototype.drawSymb = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(x + w * .5, y);
    c.lineTo(x + w * .5, y + h);
    c.moveTo(x, y + h);
    c.lineTo(x, y + h * .5);
    c.lineTo(x + w, y + h * .5);
    c.lineTo(x + w, y + h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLCallBehaviorAction.prototype.cst.CALL_BEH_ACT, mxShapeSysMLCallBehaviorAction);
function mxShapeSysMLAcceptEventAction(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLAcceptEventAction, mxShape);
mxShapeSysMLAcceptEventAction.prototype.cst = {
    ACC_EVENT: "mxgraph.sysml.accEvent"
};
mxShapeSysMLAcceptEventAction.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(x, y);
    c.lineTo(x + w, y);
    c.lineTo(x + w, y + h);
    c.lineTo(x, y + h);
    c.lineTo(x + h * .3, y + h * .5);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLAcceptEventAction.prototype.cst.ACC_EVENT, mxShapeSysMLAcceptEventAction);
function mxShapeSysMLTimeEvent(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLTimeEvent, mxShape);
mxShapeSysMLTimeEvent.prototype.cst = {
    TIME_EVENT: "mxgraph.sysml.timeEvent"
};
mxShapeSysMLTimeEvent.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(x, y);
    c.lineTo(x + w, y);
    c.lineTo(x, y + h);
    c.lineTo(x + w, y + h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLTimeEvent.prototype.cst.TIME_EVENT, mxShapeSysMLTimeEvent);
function mxShapeSysMLSendSignalAction(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLSendSignalAction, mxShape);
mxShapeSysMLSendSignalAction.prototype.cst = {
    SEND_SIG_ACT: "mxgraph.sysml.sendSigAct"
};
mxShapeSysMLSendSignalAction.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(x, y);
    c.lineTo(x + w - h * .3, y);
    c.lineTo(x + w, y + h * .5);
    c.lineTo(x + w - h * .3, y + h);
    c.lineTo(x, y + h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLSendSignalAction.prototype.cst.SEND_SIG_ACT, mxShapeSysMLSendSignalAction);
function mxShapeSysMLActivityFinal(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLActivityFinal, mxShape);
mxShapeSysMLActivityFinal.prototype.cst = {
    ACT_FINAL: "mxgraph.sysml.actFinal"
};
mxShapeSysMLActivityFinal.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.ellipse(x, y, w, h);
    c.fillAndStroke();
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    c.setFillColor(strokeColor);
    c.ellipse(x + 5, y + 5, w - 10, h - 10);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLActivityFinal.prototype.cst.ACT_FINAL, mxShapeSysMLActivityFinal);
function mxShapeSysMLActivityParameterNode(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLActivityParameterNode, mxShape);
mxShapeSysMLActivityParameterNode.prototype.cst = {
    ACT_PARAM_NODE: "mxgraph.sysml.actParamNode"
};
mxShapeSysMLActivityParameterNode.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    var minX = Math.max(w * .35, 70);
    var maxX = Math.min(w * .65, w - 10);
    c.begin();
    c.moveTo(minX, h);
    c.lineTo(10, h);
    c.lineTo(10, 0);
    c.lineTo(minX, 0);
    c.moveTo(maxX, h);
    c.lineTo(w - 10, h);
    c.lineTo(w - 10, 0);
    c.lineTo(maxX, 0);
    c.stroke();
    var xSize = 50;
    var ySize = 20;
    xSize = Math.min(xSize, w);
    if (xSize > ySize) {
        c.begin();
        c.moveTo(10, ySize);
        c.lineTo(xSize - ySize * .5, ySize);
        c.lineTo(xSize, ySize * .5);
        c.lineTo(xSize, 0);
        c.lineTo(10, 0);
        c.close();
        c.fillAndStroke()
    }
    c.rect(0, h * .35 - 10, 20, 20);
    c.fillAndStroke();
    c.rect(0, h * .65 - 10, 20, 20);
    c.fillAndStroke();
    c.rect(w - 20, h * .5 - 10, 20, 20);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLActivityParameterNode.prototype.cst.ACT_PARAM_NODE, mxShapeSysMLActivityParameterNode);
function mxShapeSysMLControlOperator(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLControlOperator, mxShape);
mxShapeSysMLControlOperator.prototype.cst = {
    CONT_OPER: "mxgraph.sysml.contOper"
};
mxShapeSysMLControlOperator.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeSysMLControlOperator.prototype.background = function(c, x, y, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeSysMLControlOperator.prototype.foreground = function(c, x, y, w, h) {
    var xSize = 130;
    var ySize = 20;
    xSize = Math.min(xSize, w);
    if (xSize > ySize) {
        c.begin();
        c.moveTo(0, ySize);
        c.lineTo(xSize - ySize * .5, ySize);
        c.lineTo(xSize, ySize * .5);
        c.lineTo(xSize, 0);
        c.stroke()
    }
}
;
mxCellRenderer.registerShape(mxShapeSysMLControlOperator.prototype.cst.CONT_OPER, mxShapeSysMLControlOperator);
function mxShapeSysMLFlowFinal(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLFlowFinal, mxShape);
mxShapeSysMLFlowFinal.prototype.cst = {
    FLOW_FINAL: "mxgraph.sysml.flowFinal"
};
mxShapeSysMLFlowFinal.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.ellipse(0, 0, w, h);
    c.fillAndStroke();
    c.setShadow(false);
    c.begin();
    c.moveTo(w * .145, h * .145);
    c.lineTo(w * .855, h * .855);
    c.moveTo(w * .855, h * .145);
    c.lineTo(w * .145, h * .855);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLFlowFinal.prototype.cst.FLOW_FINAL, mxShapeSysMLFlowFinal);
function mxShapeSysMLIsControl(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLIsControl, mxShape);
mxShapeSysMLIsControl.prototype.cst = {
    IS_CONTROL: "mxgraph.sysml.isControl"
};
mxShapeSysMLIsControl.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.rect(0, h * .5 - 10, 10, 20);
    c.fillAndStroke();
    c.roundrect(10, 0, w - 20, h, 10, 10);
    c.fillAndStroke();
    c.rect(w - 10, h * .5 - 10, 10, 20);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLIsControl.prototype.cst.IS_CONTROL, mxShapeSysMLIsControl);
function mxShapeSysMLIsStream(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLIsStream, mxShape);
mxShapeSysMLIsStream.prototype.cst = {
    IS_STREAM: "mxgraph.sysml.isStream"
};
mxShapeSysMLIsStream.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    c.setFillColor(strokeColor);
    c.rect(0, h * .5 - 10, 10, 20);
    c.fillAndStroke();
    c.setFillColor(fillColor);
    c.roundrect(10, 0, w - 20, h, 10, 10);
    c.fillAndStroke();
    c.setFillColor(strokeColor);
    c.rect(w - 10, h * .5 - 10, 10, 20);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLIsStream.prototype.cst.IS_STREAM, mxShapeSysMLIsStream);
function mxShapeSysMLIsActStream(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLIsActStream, mxShape);
mxShapeSysMLIsActStream.prototype.cst = {
    IS_ACT_STREAM: "mxgraph.sysml.isActStream"
};
mxShapeSysMLIsActStream.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.rect(0, 0, w - 10, h);
    c.fillAndStroke();
    var xSize = 40;
    var ySize = 20;
    xSize = Math.min(xSize, w);
    if (xSize > ySize) {
        c.begin();
        c.moveTo(0, ySize);
        c.lineTo(xSize - ySize * .5, ySize);
        c.lineTo(xSize, ySize * .5);
        c.lineTo(xSize, 0);
        c.lineTo(0, 0);
        c.close();
        c.fillAndStroke()
    }
    c.rect(w - 20, h * .5 - 10, 20, 20);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLIsActStream.prototype.cst.IS_ACT_STREAM, mxShapeSysMLIsActStream);
function mxShapeSysMLParameterSet(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLParameterSet, mxShape);
mxShapeSysMLParameterSet.prototype.cst = {
    PARAM_SET: "mxgraph.sysml.paramSet"
};
mxShapeSysMLParameterSet.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.rect(0, h * .5 - 28, 10, 56);
    c.fillAndStroke();
    c.roundrect(10, 0, w - 20, h, 10, 10);
    c.fillAndStroke();
    c.rect(w - 10, h * .5 - 28, 10, 56);
    c.fillAndStroke();
    c.setShadow(false);
    c.rect(4, h * .5 - 24, 6, 20);
    c.fillAndStroke();
    c.rect(4, h * .5 + 4, 6, 20);
    c.fillAndStroke();
    c.rect(w - 10, h * .5 - 24, 6, 20);
    c.fillAndStroke();
    c.rect(w - 10, h * .5 + 4, 6, 20);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLParameterSet.prototype.cst.PARAM_SET, mxShapeSysMLParameterSet);
function mxShapeSysMLParameterActivitySet(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLParameterActivitySet, mxShape);
mxShapeSysMLParameterActivitySet.prototype.cst = {
    PARAM_ACT_SET: "mxgraph.sysml.paramActSet"
};
mxShapeSysMLParameterActivitySet.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.rect(10, 0, w - 20, h);
    c.fillAndStroke();
    var xSize = 50;
    var ySize = 20;
    xSize = Math.min(xSize, w);
    if (xSize > ySize) {
        c.begin();
        c.moveTo(10, ySize);
        c.lineTo(xSize - ySize * .5, ySize);
        c.lineTo(xSize, ySize * .5);
        c.lineTo(xSize, 0);
        c.lineTo(10, 0);
        c.close();
        c.fillAndStroke()
    }
    c.setShadow(false);
    if (h > 70) {
        c.rect(0, h * .5 - 28, 15, 56);
        c.fillAndStroke();
        c.rect(4, h * .5 - 24, 15, 20);
        c.fillAndStroke();
        c.rect(4, h * .5 + 4, 15, 20);
        c.fillAndStroke();
        c.rect(w - 15, h * .5 - 28, 15, 56);
        c.fillAndStroke();
        c.rect(w - 19, h * .5 - 24, 15, 20);
        c.fillAndStroke();
        c.rect(w - 19, h * .5 + 4, 15, 20);
        c.fillAndStroke()
    }
}
;
mxCellRenderer.registerShape(mxShapeSysMLParameterActivitySet.prototype.cst.PARAM_ACT_SET, mxShapeSysMLParameterActivitySet);
function mxShapeSysMLProbability(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLProbability, mxShape);
mxShapeSysMLProbability.prototype.cst = {
    PROBABILITY: "mxgraph.sysml.probability"
};
mxShapeSysMLProbability.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.roundrect(0, 0, w - 10, h, 10, 10);
    c.fillAndStroke();
    c.rect(w - 10, h * .25 - 28, 10, 56);
    c.fillAndStroke();
    c.rect(w - 10, h * .75 - 28, 10, 56);
    c.fillAndStroke();
    c.setShadow(false);
    c.rect(w - 10, h * .25 - 24, 6, 20);
    c.fillAndStroke();
    c.rect(w - 10, h * .25 + 4, 6, 20);
    c.fillAndStroke();
    c.rect(w - 10, h * .75 - 24, 6, 20);
    c.fillAndStroke();
    c.rect(w - 10, h * .75 + 4, 6, 20);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLProbability.prototype.cst.PROBABILITY, mxShapeSysMLProbability);
function mxShapeSysMLActivityProbability(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLActivityProbability, mxShape);
mxShapeSysMLActivityProbability.prototype.cst = {
    ACT_PROB: "mxgraph.sysml.actProb"
};
mxShapeSysMLActivityProbability.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.rect(0, 0, w - 10, h);
    c.fillAndStroke();
    var xSize = 40;
    var ySize = 20;
    xSize = Math.min(xSize, w);
    if (xSize > ySize) {
        c.begin();
        c.moveTo(0, ySize);
        c.lineTo(xSize - ySize * .5, ySize);
        c.lineTo(xSize, ySize * .5);
        c.lineTo(xSize, 0);
        c.lineTo(0, 0);
        c.close();
        c.fillAndStroke()
    }
    c.setShadow(false);
    if (h > 70) {
        c.rect(w - 15, h * .25 - 28, 15, 56);
        c.fillAndStroke();
        c.rect(w - 19, h * .25 - 24, 15, 20);
        c.fillAndStroke();
        c.rect(w - 19, h * .25 + 4, 15, 20);
        c.fillAndStroke();
        c.rect(w - 15, h * .75 - 28, 15, 56);
        c.fillAndStroke();
        c.rect(w - 19, h * .75 - 24, 15, 20);
        c.fillAndStroke();
        c.rect(w - 19, h * .75 + 4, 15, 20);
        c.fillAndStroke()
    }
}
;
mxCellRenderer.registerShape(mxShapeSysMLActivityProbability.prototype.cst.ACT_PROB, mxShapeSysMLActivityProbability);
function mxShapeSysMLObjectFlowRight(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLObjectFlowRight, mxShape);
mxShapeSysMLObjectFlowRight.prototype.cst = {
    OBJ_FLOW_R: "mxgraph.sysml.objFlowR"
};
mxShapeSysMLObjectFlowRight.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.roundrect(0, 0, w - 10, h, 10, 10);
    c.fillAndStroke();
    c.rect(w - 10, h * .5 - 10, 10, 20);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLObjectFlowRight.prototype.cst.OBJ_FLOW_R, mxShapeSysMLObjectFlowRight);
function mxShapeSysMLObjectFlowLeft(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLObjectFlowLeft, mxShape);
mxShapeSysMLObjectFlowLeft.prototype.cst = {
    OBJ_FLOW_L: "mxgraph.sysml.objFlowL"
};
mxShapeSysMLObjectFlowLeft.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.rect(0, h * .5 - 10, 10, 20);
    c.fillAndStroke();
    c.roundrect(10, 0, w - 10, h, 10, 10);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLObjectFlowLeft.prototype.cst.OBJ_FLOW_L, mxShapeSysMLObjectFlowLeft);
function mxShapeSysMLActivityPartition(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLActivityPartition, mxShape);
mxShapeSysMLActivityPartition.prototype.cst = {
    ACT_PART: "mxgraph.sysml.actPart"
};
mxShapeSysMLActivityPartition.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(0, h);
    c.moveTo(w, 0);
    c.lineTo(w, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLActivityPartition.prototype.cst.ACT_PART, mxShapeSysMLActivityPartition);
function mxShapeSysMLContinuation(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLContinuation, mxShape);
mxShapeSysMLContinuation.prototype.cst = {
    CONT: "mxgraph.sysml.cont"
};
mxShapeSysMLContinuation.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    if (w > h) {
        var r = h * .5;
        c.begin();
        c.moveTo(w - r, 0);
        c.arcTo(r, r, 0, 0, 1, w - r, h);
        c.lineTo(r, h);
        c.arcTo(r, r, 0, 0, 1, r, 0);
        c.close();
        c.fillAndStroke()
    } else {
        var r = w * .5;
        c.begin();
        c.moveTo(0, h - r);
        c.arcTo(r, r, 0, 0, 0, w, h - r);
        c.lineTo(w, r);
        c.arcTo(r, r, 0, 0, 0, 0, r);
        c.close();
        c.fillAndStroke()
    }
}
;
mxCellRenderer.registerShape(mxShapeSysMLContinuation.prototype.cst.CONT, mxShapeSysMLContinuation);
function mxShapeSysMLCoregion(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLCoregion, mxShape);
mxShapeSysMLCoregion.prototype.cst = {
    COREGION: "mxgraph.sysml.coregion"
};
mxShapeSysMLCoregion.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    var brack = 10;
    brack = Math.min(brack, h);
    c.begin();
    c.moveTo(0, brack);
    c.lineTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w, brack);
    c.moveTo(0, h - brack);
    c.lineTo(0, h);
    c.lineTo(w, h);
    c.lineTo(w, h - brack);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLCoregion.prototype.cst.COREGION, mxShapeSysMLCoregion);
mxMarker.addMarker("sysMLx", function(c, shape, type, pe, unitX, unitY, size, source, sw, filled) {
    var nx = unitX * (size + sw + 1);
    var ny = unitY * (size + sw + 1);
    return function() {
        c.begin();
        c.moveTo(pe.x - nx / 2 - ny / 2, pe.y - ny / 2 + nx / 2);
        c.lineTo(pe.x + nx / 2 + ny / 2, pe.y + ny / 2 - nx / 2);
        c.moveTo(pe.x + nx / 2 - ny / 2, pe.y + ny / 2 + nx / 2);
        c.lineTo(pe.x - nx / 2 + ny / 2, pe.y - ny / 2 - nx / 2);
        c.stroke()
    }
});
function mxShapeSysMLDimension(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLDimension, mxShape);
mxShapeSysMLDimension.prototype.cst = {
    DIMENSION: "mxgraph.sysml.dimension"
};
mxShapeSysMLDimension.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h)
}
;
mxShapeSysMLDimension.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(0, 20);
    c.lineTo(w, 20);
    c.moveTo(10, 15);
    c.lineTo(0, 20);
    c.lineTo(10, 25);
    c.moveTo(w - 10, 15);
    c.lineTo(w, 20);
    c.lineTo(w - 10, 25);
    c.moveTo(0, 15);
    c.lineTo(0, h);
    c.moveTo(w, 15);
    c.lineTo(w, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLDimension.prototype.cst.DIMENSION, mxShapeSysMLDimension);
mxMarker.addMarker("sysMLLost", function(c, shape, type, pe, unitX, unitY, size, source, sw, filled) {
    var nx = unitX * (size + sw + 1);
    var ny = unitY * (size + sw + 1);
    var a = size / 2;
    return function() {
        c.begin();
        c.moveTo(pe.x - 1.5 * nx - ny / 2, pe.y - 1.5 * ny + nx / 2);
        c.lineTo(pe.x - nx / 2, pe.y - ny / 2);
        c.lineTo(pe.x - 1.5 * nx + ny / 2, pe.y - 1.5 * ny - nx / 2);
        c.stroke();
        c.ellipse(pe.x - .5 * nx - a, pe.y - .5 * ny - a, 2 * a, 2 * a);
        var strokeColor = mxUtils.getValue(shape.style, mxConstants.STYLE_STROKECOLOR, "#000000");
        c.setFillColor(strokeColor);
        c.fillAndStroke()
    }
});
mxMarker.addMarker("sysMLFound", function(c, shape, type, pe, unitX, unitY, size, source, sw, filled) {
    var nx = unitX * (size + sw + 1);
    var ny = unitY * (size + sw + 1);
    var a = size / 2;
    return function() {
        c.ellipse(pe.x - .5 * nx - a, pe.y - .5 * ny - a, 2 * a, 2 * a);
        var strokeColor = mxUtils.getValue(shape.style, mxConstants.STYLE_STROKECOLOR, "#000000");
        c.setFillColor(strokeColor);
        c.fillAndStroke()
    }
});
function mxShapeSysMLCompositeState(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLCompositeState, mxShape);
mxShapeSysMLCompositeState.prototype.cst = {
    COMP_STATE: "mxgraph.sysml.compState"
};
mxShapeSysMLCompositeState.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h)
}
;
mxShapeSysMLCompositeState.prototype.background = function(c, x, y, w, h) {
    var tabH = 20;
    var tabW = 110;
    c.roundrect(0, tabH, w, h - tabH, 10, 10);
    c.fillAndStroke();
    c.rect(15, 0, tabW, tabH);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLCompositeState.prototype.cst.COMP_STATE, mxShapeSysMLCompositeState);
function mxShapeSysMLRegion(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLRegion, mxShape);
mxShapeSysMLRegion.prototype.cst = {
    REGION: "mxgraph.sysml.region"
};
mxShapeSysMLRegion.prototype.paintVertexShape = function(c, x, y, w, h) {
    var tabH = 20;
    var tabW = 50;
    c.translate(x, y);
    this.background(c, x, y, w, h, tabH, tabW);
    c.setShadow(false);
    this.foreground(c, x, y, w, h, tabH, tabW)
}
;
mxShapeSysMLRegion.prototype.background = function(c, x, y, w, h, tabH, tabW) {
    var strokeW = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, "1"));
    c.roundrect(0, tabH, w, h - tabH, 10, 10);
    c.fillAndStroke();
    c.setStrokeWidth(strokeW * 2);
    c.rect(15, 0, tabW, tabH);
    c.fillAndStroke();
    c.setStrokeWidth(strokeW)
}
;
mxShapeSysMLRegion.prototype.foreground = function(c, x, y, w, h, tabH, tabW) {
    c.setDashed(true);
    c.begin();
    c.moveTo(w * .5, tabH);
    c.lineTo(w * .5, h);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLRegion.prototype.cst.REGION, mxShapeSysMLRegion);
function mxShapeSysMLSimpleState(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLSimpleState, mxShape);
mxShapeSysMLSimpleState.prototype.cst = {
    SIMPLE_STATE: "mxgraph.sysml.simpleState"
};
mxShapeSysMLSimpleState.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false)
}
;
mxShapeSysMLSimpleState.prototype.background = function(c, x, y, w, h) {
    var strokeW = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_STROKEWIDTH, "1"));
    c.roundrect(0, 0, w, h, 10, 10);
    c.fillAndStroke()
}
;
mxShapeSysMLSimpleState.prototype.foreground = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(0, 20);
    c.lineTo(w, 20);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLSimpleState.prototype.cst.SIMPLE_STATE, mxShapeSysMLSimpleState);
function mxShapeSysMLStateMachine(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLStateMachine, mxShape);
mxShapeSysMLStateMachine.prototype.cst = {
    STATE_MACHINE: "mxgraph.sysml.stateMachine"
};
mxShapeSysMLStateMachine.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeSysMLStateMachine.prototype.background = function(c, x, y, w, h) {
    c.roundrect(0, 0, w - 10, h, 10, 10);
    c.fillAndStroke()
}
;
mxShapeSysMLStateMachine.prototype.foreground = function(c, x, y, w, h) {
    var strokeC = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    c.setFillColor(strokeC);
    c.ellipse(w - 20, h * .5 - 10, 20, 20);
    c.stroke();
    c.ellipse(w - 17, h * .5 - 7, 14, 14);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLStateMachine.prototype.cst.STATE_MACHINE, mxShapeSysMLStateMachine);
function mxShapeSysMLX(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLX, mxShape);
mxShapeSysMLX.prototype.cst = {
    X: "mxgraph.sysml.x"
};
mxShapeSysMLX.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, h);
    c.moveTo(0, h);
    c.lineTo(w, 0);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLX.prototype.cst.X, mxShapeSysMLX);
function mxShapeSysMLSubmachineState(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLSubmachineState, mxShape);
mxShapeSysMLSubmachineState.prototype.cst = {
    SUBMACHINE_STATE: "mxgraph.sysml.submState"
};
mxShapeSysMLSubmachineState.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeSysMLSubmachineState.prototype.background = function(c, x, y, w, h) {
    c.roundrect(0, 0, w - 10, h, 10, 10);
    c.fillAndStroke()
}
;
mxShapeSysMLSubmachineState.prototype.foreground = function(c, x, y, w, h) {
    var strokeC = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    c.setFillColor(strokeC);
    c.ellipse(w - 20, h * .5 - 10, 20, 20);
    c.stroke();
    c.ellipse(w - 17, h * .5 - 7, 14, 14);
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLSubmachineState.prototype.cst.SUBMACHINE_STATE, mxShapeSysMLSubmachineState);
function mxShapeSysMLUseCaseExtensionPoints(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapeSysMLUseCaseExtensionPoints, mxShape);
mxShapeSysMLUseCaseExtensionPoints.prototype.cst = {
    USE_CASE_EXT_PT: "mxgraph.sysml.useCaseExtPt"
};
mxShapeSysMLUseCaseExtensionPoints.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapeSysMLUseCaseExtensionPoints.prototype.background = function(c, x, y, w, h) {
    c.ellipse(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapeSysMLUseCaseExtensionPoints.prototype.foreground = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(w * .02, h * .35);
    c.lineTo(w * .98, h * .35);
    c.stroke()
}
;
mxCellRenderer.registerShape(mxShapeSysMLUseCaseExtensionPoints.prototype.cst.USE_CASE_EXT_PT, mxShapeSysMLUseCaseExtensionPoints);
function mxShapePidDiscInst(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapePidDiscInst, mxShape);
mxShapePidDiscInst.prototype.cst = {
    SHAPE_DISC_INST: "mxgraph.pid2inst.discInst",
    MOUNTING: "mounting",
    FIELD: "field",
    ROOM: "room",
    INACCESSIBLE: "inaccessible",
    LOCAL: "local"
};
mxShapePidDiscInst.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapePidDiscInst.prototype.background = function(c, x, y, w, h) {
    c.ellipse(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapePidDiscInst.prototype.foreground = function(c, x, y, w, h) {
    var mounting = mxUtils.getValue(this.style, mxShapePidDiscInst.prototype.cst.MOUNTING, "field");
    if (mounting === mxShapePidDiscInst.prototype.cst.ROOM) {
        c.begin();
        c.moveTo(0, h * .5);
        c.lineTo(w, h * .5);
        c.stroke()
    } else if (mounting === mxShapePidDiscInst.prototype.cst.INACCESSIBLE) {
        c.setDashed(true);
        c.begin();
        c.moveTo(0, h * .5);
        c.lineTo(w, h * .5);
        c.stroke()
    } else if (mounting === mxShapePidDiscInst.prototype.cst.LOCAL) {
        c.begin();
        c.moveTo(w * .005, h * .48);
        c.lineTo(w * .995, h * .48);
        c.moveTo(w * .005, h * .52);
        c.lineTo(w * .995, h * .52);
        c.stroke()
    }
}
;
mxCellRenderer.registerShape(mxShapePidDiscInst.prototype.cst.SHAPE_DISC_INST, mxShapePidDiscInst);
mxShapePidDiscInst.prototype.constraints = [new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(.145,.145),false), new mxConnectionConstraint(new mxPoint(.145,.855),false), new mxConnectionConstraint(new mxPoint(.855,.145),false), new mxConnectionConstraint(new mxPoint(.855,.855),false)];
function mxShapePidSharedCont(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapePidSharedCont, mxShape);
mxShapePidSharedCont.prototype.cst = {
    SHAPE_SHARED_CONT: "mxgraph.pid2inst.sharedCont",
    MOUNTING: "mounting",
    FIELD: "field",
    ROOM: "room",
    INACCESSIBLE: "inaccessible",
    LOCAL: "local"
};
mxShapePidSharedCont.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapePidSharedCont.prototype.background = function(c, x, y, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapePidSharedCont.prototype.foreground = function(c, x, y, w, h) {
    var mounting = mxUtils.getValue(this.style, mxShapePidSharedCont.prototype.cst.MOUNTING, "field");
    c.ellipse(0, 0, w, h);
    c.fillAndStroke();
    if (mounting === mxShapePidSharedCont.prototype.cst.ROOM) {
        c.begin();
        c.moveTo(0, h * .5);
        c.lineTo(w, h * .5);
        c.stroke()
    } else if (mounting === mxShapePidSharedCont.prototype.cst.INACCESSIBLE) {
        c.setDashed(true);
        c.begin();
        c.moveTo(0, h * .5);
        c.lineTo(w, h * .5);
        c.stroke()
    } else if (mounting === mxShapePidDiscInst.prototype.cst.LOCAL) {
        c.begin();
        c.moveTo(w * .005, h * .48);
        c.lineTo(w * .995, h * .48);
        c.moveTo(w * .005, h * .52);
        c.lineTo(w * .995, h * .52);
        c.stroke()
    }
}
;
mxCellRenderer.registerShape(mxShapePidSharedCont.prototype.cst.SHAPE_SHARED_CONT, mxShapePidSharedCont);
mxShapePidSharedCont.prototype.constraints = [new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(0,0),false), new mxConnectionConstraint(new mxPoint(0,1),false), new mxConnectionConstraint(new mxPoint(1,0),false), new mxConnectionConstraint(new mxPoint(1,1),false)];
function mxShapePidCompFunc(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapePidCompFunc, mxShape);
mxShapePidCompFunc.prototype.cst = {
    SHAPE_COMP_FUNC: "mxgraph.pid2inst.compFunc",
    MOUNTING: "mounting",
    FIELD: "field",
    ROOM: "room",
    INACCESSIBLE: "inaccessible",
    LOCAL: "local"
};
mxShapePidCompFunc.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapePidCompFunc.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(w * .25, 0);
    c.lineTo(w * .75, 0);
    c.lineTo(w, h * .5);
    c.lineTo(w * .75, h);
    c.lineTo(w * .25, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapePidCompFunc.prototype.foreground = function(c, x, y, w, h) {
    var mounting = mxUtils.getValue(this.style, mxShapePidCompFunc.prototype.cst.MOUNTING, "field");
    if (mounting === mxShapePidCompFunc.prototype.cst.ROOM) {
        c.begin();
        c.moveTo(0, h * .5);
        c.lineTo(w, h * .5);
        c.stroke()
    } else if (mounting === mxShapePidCompFunc.prototype.cst.INACCESSIBLE) {
        c.setDashed(true);
        c.begin();
        c.moveTo(0, h * .5);
        c.lineTo(w, h * .5);
        c.stroke()
    } else if (mounting === mxShapePidDiscInst.prototype.cst.LOCAL) {
        c.begin();
        c.moveTo(w * .01, h * .48);
        c.lineTo(w * .99, h * .48);
        c.moveTo(w * .01, h * .52);
        c.lineTo(w * .99, h * .52);
        c.stroke()
    }
}
;
mxCellRenderer.registerShape(mxShapePidCompFunc.prototype.cst.SHAPE_COMP_FUNC, mxShapePidCompFunc);
mxShapePidCompFunc.prototype.constraints = [new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(.25,0),false), new mxConnectionConstraint(new mxPoint(.75,0),false), new mxConnectionConstraint(new mxPoint(.25,1),false), new mxConnectionConstraint(new mxPoint(.75,1),false)];
function mxShapePidProgLogCont(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapePidProgLogCont, mxShape);
mxShapePidProgLogCont.prototype.cst = {
    SHAPE_PROG_LOG_CONT: "mxgraph.pid2inst.progLogCont",
    MOUNTING: "mounting",
    FIELD: "field",
    ROOM: "room",
    INACCESSIBLE: "inaccessible",
    LOCAL: "local"
};
mxShapePidProgLogCont.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapePidProgLogCont.prototype.background = function(c, x, y, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapePidProgLogCont.prototype.foreground = function(c, x, y, w, h) {
    var mounting = mxUtils.getValue(this.style, mxShapePidProgLogCont.prototype.cst.MOUNTING, "field");
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h * .5);
    c.lineTo(w * .5, h);
    c.close();
    c.stroke();
    if (mounting === mxShapePidProgLogCont.prototype.cst.ROOM) {
        c.begin();
        c.moveTo(0, h * .5);
        c.lineTo(w, h * .5);
        c.stroke()
    } else if (mounting === mxShapePidProgLogCont.prototype.cst.INACCESSIBLE) {
        c.setDashed(true);
        c.begin();
        c.moveTo(0, h * .5);
        c.lineTo(w, h * .5);
        c.stroke()
    } else if (mounting === mxShapePidDiscInst.prototype.cst.LOCAL) {
        c.begin();
        c.moveTo(w * .02, h * .48);
        c.lineTo(w * .98, h * .48);
        c.moveTo(w * .02, h * .52);
        c.lineTo(w * .98, h * .52);
        c.stroke()
    }
}
;
mxCellRenderer.registerShape(mxShapePidProgLogCont.prototype.cst.SHAPE_PROG_LOG_CONT, mxShapePidProgLogCont);
mxShapePidProgLogCont.prototype.constraints = [new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(0,0),false), new mxConnectionConstraint(new mxPoint(0,1),false), new mxConnectionConstraint(new mxPoint(1,0),false), new mxConnectionConstraint(new mxPoint(1,1),false)];
function mxShapePidIndicator(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapePidIndicator, mxShape);
mxShapePidIndicator.prototype.cst = {
    SHAPE_INDICATOR: "mxgraph.pid2inst.indicator",
    MOUNTING: "mounting",
    FIELD: "field",
    ROOM: "room",
    INACCESSIBLE: "inaccessible",
    LOCAL: "local",
    IND_TYPE: "indType",
    INSTRUMENT: "inst",
    CONTROL: "ctrl",
    FUNCTION: "func",
    PLC: "plc"
};
mxShapePidIndicator.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapePidIndicator.prototype.background = function(c, x, y, w, h) {
    var type = mxUtils.getValue(this.style, mxShapePidIndicator.prototype.cst.IND_TYPE, "inst");
    c.begin();
    c.moveTo(w * .5, w);
    c.lineTo(w * .5, h);
    c.stroke();
    if (type === mxShapePidIndicator.prototype.cst.INSTRUMENT) {
        c.ellipse(0, 0, w, w);
        c.fillAndStroke()
    } else if (type === mxShapePidIndicator.prototype.cst.CONTROL) {
        c.rect(0, 0, w, w);
        c.fillAndStroke()
    } else if (type === mxShapePidIndicator.prototype.cst.FUNCTION) {
        c.begin();
        c.moveTo(0, w * .5);
        c.lineTo(w * .25, 0);
        c.lineTo(w * .75, 0);
        c.lineTo(w, w * .5);
        c.lineTo(w * .75, w);
        c.lineTo(w * .25, w);
        c.close();
        c.fillAndStroke()
    } else if (type === mxShapePidIndicator.prototype.cst.PLC) {
        c.rect(0, 0, w, w);
        c.fillAndStroke()
    }
}
;
mxShapePidIndicator.prototype.foreground = function(c, x, y, w, h) {
    var mounting = mxUtils.getValue(this.style, mxShapePidIndicator.prototype.cst.MOUNTING, "field");
    var type = mxUtils.getValue(this.style, mxShapePidIndicator.prototype.cst.IND_TYPE, "inst");
    if (type === mxShapePidIndicator.prototype.cst.CONTROL) {
        c.ellipse(0, 0, w, w);
        c.stroke()
    } else if (type === mxShapePidIndicator.prototype.cst.PLC) {
        c.begin();
        c.moveTo(0, w * .5);
        c.lineTo(w * .5, 0);
        c.lineTo(w, w * .5);
        c.lineTo(w * .5, w);
        c.close();
        c.stroke()
    }
    if (mounting === mxShapePidIndicator.prototype.cst.ROOM) {
        c.begin();
        c.moveTo(0, w * .5);
        c.lineTo(w, w * .5);
        c.stroke()
    } else if (mounting === mxShapePidIndicator.prototype.cst.INACCESSIBLE) {
        c.setDashed(true);
        c.begin();
        c.moveTo(0, w * .5);
        c.lineTo(w, w * .5);
        c.stroke()
    } else if (mounting === mxShapePidIndicator.prototype.cst.LOCAL) {
        c.begin();
        c.moveTo(w * .005, w * .48);
        c.lineTo(w * .995, w * .48);
        c.moveTo(w * .005, w * .52);
        c.lineTo(w * .995, w * .52);
        c.stroke()
    }
}
;
mxCellRenderer.registerShape(mxShapePidIndicator.prototype.cst.SHAPE_INDICATOR, mxShapePidIndicator);
mxShapePidIndicator.prototype.constraints = [new mxConnectionConstraint(new mxPoint(.5,1),true)];
function mxShapePidLogic(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapePidLogic, mxShape);
mxShapePidLogic.prototype.cst = {
    SHAPE_LOGIC: "mxgraph.pid2inst.logic",
    MOUNTING: "mounting",
    FIELD: "field",
    ROOM: "room",
    INACCESSIBLE: "inaccessible",
    LOCAL: "local"
};
mxShapePidLogic.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapePidLogic.prototype.background = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h * .5);
    c.lineTo(w * .5, h);
    c.close();
    c.fillAndStroke()
}
;
mxShapePidLogic.prototype.foreground = function(c, x, y, w, h) {
    var mounting = mxUtils.getValue(this.style, mxShapePidLogic.prototype.cst.MOUNTING, "field");
    if (mounting === mxShapePidLogic.prototype.cst.ROOM) {
        c.begin();
        c.moveTo(0, h * .5);
        c.lineTo(w, h * .5);
        c.stroke()
    } else if (mounting === mxShapePidLogic.prototype.cst.INACCESSIBLE) {
        c.setDashed(true);
        c.begin();
        c.moveTo(0, h * .5);
        c.lineTo(w, h * .5);
        c.stroke()
    } else if (mounting === mxShapePidLogic.prototype.cst.LOCAL) {
        c.begin();
        c.moveTo(w * .02, h * .48);
        c.lineTo(w * .98, h * .48);
        c.moveTo(w * .02, h * .52);
        c.lineTo(w * .98, h * .52);
        c.stroke()
    }
}
;
mxCellRenderer.registerShape(mxShapePidLogic.prototype.cst.SHAPE_LOGIC, mxShapePidLogic);
mxShapePidLogic.prototype.constraints = [new mxConnectionConstraint(new mxPoint(.5,0),true), new mxConnectionConstraint(new mxPoint(.5,1),true), new mxConnectionConstraint(new mxPoint(0,.5),true), new mxConnectionConstraint(new mxPoint(1,.5),true), new mxConnectionConstraint(new mxPoint(.25,.25),false), new mxConnectionConstraint(new mxPoint(.25,.75),false), new mxConnectionConstraint(new mxPoint(.75,.25),false), new mxConnectionConstraint(new mxPoint(.75,.75),false)];
function mxShapePidFan(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapePidFan, mxShape);
mxShapePidFan.prototype.cst = {
    SHAPE_FAN: "mxgraph.pid2misc.fan",
    FAN_TYPE: "fanType",
    COMMON: "common",
    AXIAL: "axial",
    RADIAL: "radial"
};
mxShapePidFan.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapePidFan.prototype.background = function(c, x, y, w, h) {
    c.ellipse(0, 0, w, h);
    c.fillAndStroke()
}
;
mxShapePidFan.prototype.foreground = function(c, x, y, w, h) {
    c.begin();
    c.moveTo(w * .3, h * .045);
    c.lineTo(w * .97, h * .33);
    c.moveTo(w * .3, h * .955);
    c.lineTo(w * .97, h * .67);
    c.moveTo(w * .4228, h * .3655);
    c.arcTo(w * .15, h * .03, 50, 0, 1, w * .5, h * .5);
    c.arcTo(w * 0, 15, h * .03, 50, 0, 1, w * .3772, h * .4045);
    c.arcTo(w * .15, h * .03, 50, 0, 1, w * .3025, h * .271);
    c.arcTo(w * .15, h * .03, 50, 0, 1, w * .4228, h * .3655);
    c.close();
    c.moveTo(w * .377, h * .5973);
    c.arcTo(w * .15, h * .03, -50, 0, 1, w * .4966, h * .5019);
    c.arcTo(w * 0, 15, h * .03, -50, 0, 1, w * .423, h * .636);
    c.arcTo(w * .15, h * .03, -50, 0, 1, w * .3034, h * .7314);
    c.arcTo(w * .15, h * .03, -50, 0, 1, w * .377, h * .5973);
    c.close();
    c.stroke();
    c.ellipse(w * .5, h * .47, w * .3, h * .06);
    c.stroke();
    var type = mxUtils.getValue(this.style, mxShapePidFan.prototype.cst.FAN_TYPE, "common");
    if (type === mxShapePidFan.prototype.cst.AXIAL) {
        c.begin();
        c.moveTo(w * .1, h * .5);
        c.lineTo(w * .3, h * .5);
        c.stroke()
    } else if (type === mxShapePidFan.prototype.cst.RADIAL) {
        c.begin();
        c.moveTo(w * .2, h * .4);
        c.lineTo(w * .2, h * .6);
        c.stroke()
    }
}
;
mxCellRenderer.registerShape(mxShapePidFan.prototype.cst.SHAPE_FAN, mxShapePidFan);
function mxShapePidColumn(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapePidColumn, mxShape);
mxShapePidColumn.prototype.cst = {
    SHAPE_COLUMN: "mxgraph.pid2misc.column",
    COLUMN_TYPE: "columnType",
    COMMON: "common",
    FIXED: "fixed",
    FLUIDIZED: "fluid",
    BAFFLE: "baffle",
    VALVE: "valve",
    BUBBLE: "bubble",
    NOZZLE: "nozzle",
    TRAY: "tray"
};
mxShapePidColumn.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false);
    this.foreground(c, x, y, w, h)
}
;
mxShapePidColumn.prototype.background = function(c, x, y, w, h) {
    h = Math.max(h, 30);
    c.begin();
    c.moveTo(0, 15);
    c.arcTo(w * .5, 15, 0, 0, 1, w, 15);
    c.lineTo(w, h - 15);
    c.arcTo(w * .5, 15, 0, 0, 1, 0, h - 15);
    c.close();
    c.fillAndStroke()
}
;
mxShapePidColumn.prototype.foreground = function(c, x, y, w, h) {
    var type = mxUtils.getValue(this.style, mxShapePidColumn.prototype.cst.COLUMN_TYPE, "common");
    if (type === mxShapePidColumn.prototype.cst.FIXED) {
        var step = w * 1.2;
        var range = h - 50;
        var rem = range % step;
        var off = rem * .5 + 25;
        c.begin();
        for (var i = 0; i <= range - step; i += step) {
            c.moveTo(0, i + off + step * .1);
            c.lineTo(w, i + off + step * .1);
            c.moveTo(0, i + off + step * .9);
            c.lineTo(w, i + off + step * .9);
            c.moveTo(0, i + off + step * .1);
            c.lineTo(w, i + off + step * .9);
            c.moveTo(0, i + off + step * .9);
            c.lineTo(w, i + off + step * .1)
        }
        c.stroke()
    } else if (type === mxShapePidColumn.prototype.cst.TRAY) {
        var step = w * .2;
        var range = h - 50;
        var rem = range % step;
        var off = rem * .5 + 25;
        c.setDashed(true);
        c.begin();
        for (var i = 0; i <= range; i += step) {
            c.moveTo(0, i + off);
            c.lineTo(w, i + off)
        }
        c.stroke()
    } else if (type === mxShapePidColumn.prototype.cst.FLUIDIZED) {
        var stepY = w * .1;
        var stepX = w * .1;
        var range = h - 50;
        var rem = range % stepY;
        var off = 25;
        var dot = Math.min(w, h) * .02;
        var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
        var dashed = mxUtils.getValue(this.style, mxConstants.STYLE_DASHED, "0");
        var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
        var odd = 0;
        c.setFillColor(strokeColor);
        c.setDashed(true);
        c.begin();
        c.moveTo(0, 25);
        c.lineTo(w, 25);
        c.moveTo(0, h - 25);
        c.lineTo(w, h - 25);
        c.stroke();
        if (dashed === "0")
            c.setDashed(false);
        else
            c.setDashed(true);
        var counter = 0;
        for (var i = off + stepY * .5; i < range + off - dot; i += stepY) {
            var startJ = stepX;
            odd = counter % 2;
            if (odd === 0)
                startJ = stepX * .5;
            for (var j = startJ; j < w; j += stepX) {
                c.ellipse(j, i, dot, dot);
                c.fillAndStroke()
            }
            counter++
        }
    } else if (type === mxShapePidColumn.prototype.cst.BAFFLE) {
        var stepY = w * .2;
        var range = h - 50 - stepY;
        var rem = range % stepY;
        var off = 25 + stepY * .5;
        var odd = 0;
        c.setDashed(true);
        c.begin();
        c.moveTo(0, 25);
        c.lineTo(w, 25);
        c.moveTo(0, h - 25);
        c.lineTo(w, h - 25);
        c.stroke();
        var counter = 0;
        c.begin();
        for (var i = off + stepY * .5; i < range + off; i += stepY) {
            odd = counter % 2;
            if (odd === 0) {
                c.moveTo(0, i);
                c.lineTo(w * .9, i);
                c.lineTo(w * .9, i - stepY * .3)
            } else {
                c.moveTo(w * .1, i - stepY * .5);
                c.lineTo(w * .1, i);
                c.lineTo(w, i)
            }
            counter++
        }
        c.stroke()
    } else if (type === mxShapePidColumn.prototype.cst.VALVE || type === mxShapePidColumn.prototype.cst.BUBBLE) {
        var stepY = w * .2;
        var range = h - 50 - stepY;
        var rem = range % stepY;
        var off = 25 + stepY * .5;
        var dashed = mxUtils.getValue(this.style, mxConstants.STYLE_DASHED, "0");
        var odd = 0;
        c.setFillColor(strokeColor);
        c.setDashed(true);
        c.begin();
        c.moveTo(0, 25);
        c.lineTo(w, 25);
        c.moveTo(0, h - 25);
        c.lineTo(w, h - 25);
        c.stroke();
        if (dashed === "0")
            c.setDashed(false);
        else
            c.setDashed(true);
        c.begin();
        for (var i = off + stepY * .5; i < range + off; i += stepY) {
            c.moveTo(0, i);
            c.lineTo(w * .4, i);
            if (type === mxShapePidColumn.prototype.cst.VALVE) {
                c.moveTo(w * .4, i - stepY * .2);
                c.lineTo(w * .6, i - stepY * .2)
            } else if (type === mxShapePidColumn.prototype.cst.BUBBLE) {
                c.moveTo(w * .25, i - stepY * .2);
                c.arcTo(stepY * 3, stepY * 3, 0, 0, 1, w * .75, i - stepY * .2)
            }
            c.moveTo(w * .6, i);
            c.lineTo(w, i)
        }
        c.stroke()
    } else if (type === mxShapePidColumn.prototype.cst.NOZZLE) {
        var step = w * 1.2;
        var range = h - 50;
        var rem = range % step;
        var off = rem * .5 + 25;
        var dashed = mxUtils.getValue(this.style, mxConstants.STYLE_DASHED, 0);
        for (var i = 0; i <= range - step; i += step) {
            c.setDashed(true);
            c.begin();
            c.moveTo(0, i + off + step * .2);
            c.lineTo(w, i + off + step * .2);
            c.moveTo(0, i + off + step * .8);
            c.lineTo(w, i + off + step * .8);
            c.stroke();
            if (dashed === 0)
                c.setDashed(false);
            else
                c.setDashed(true);
            c.begin();
            c.moveTo(0, i + off + step * .2);
            c.lineTo(w, i + off + step * .8);
            c.moveTo(0, i + off + step * .8);
            c.lineTo(w, i + off + step * .2);
            if (i !== 0) {
                c.moveTo(0, i + off);
                c.lineTo(w * .5, i + off);
                c.moveTo(w * .5 - step * .08, i + off + step * .08);
                c.lineTo(w * .5, i + off);
                c.lineTo(w * .5 + step * .08, i + off + step * .08);
                c.moveTo(w * .5, i + off);
                c.lineTo(w * .5, i + off + step * .08)
            }
            c.stroke()
        }
        c.stroke()
    }
}
;
mxCellRenderer.registerShape(mxShapePidColumn.prototype.cst.SHAPE_COLUMN, mxShapePidColumn);
function mxShapePidConveyor(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapePidConveyor, mxShape);
mxShapePidConveyor.prototype.cst = {
    SHAPE_CONVEYOR: "mxgraph.pid2misc.conveyor"
};
mxShapePidConveyor.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, x, y, w, h);
    c.setShadow(false)
}
;
mxShapePidConveyor.prototype.background = function(c, x, y, w, h) {
    var wheelSize = Math.min(h, w * .5);
    c.begin();
    c.moveTo(wheelSize * .5, 0);
    c.lineTo(w - wheelSize * .5, 0);
    c.stroke();
    c.ellipse(0, 0, wheelSize, wheelSize);
    c.fillAndStroke();
    c.ellipse(w - wheelSize, 0, wheelSize, wheelSize);
    c.fillAndStroke();
    c.begin();
    c.moveTo(wheelSize * .5, wheelSize);
    c.lineTo(w - wheelSize * .5, wheelSize);
    c.stroke();
    var dist = w - wheelSize * 1.8;
    var startX = wheelSize * .9;
    var step = wheelSize * .7;
    for (var i = 0; i < dist; i = i + step) {
        c.rect(startX + i, 0, wheelSize * .2, wheelSize * .1);
        c.fillAndStroke();
        c.rect(startX + i, wheelSize * .9, wheelSize * .2, wheelSize * .1);
        c.fillAndStroke()
    }
}
;
mxCellRenderer.registerShape(mxShapePidConveyor.prototype.cst.SHAPE_CONVEYOR, mxShapePidConveyor);
function mxShapePidValve(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapePidValve, mxShape);
mxShapePidValve.prototype.cst = {
    SHAPE_VALVE: "mxgraph.pid2valves.valve",
    DEFAULT_STATE: "defState",
    CLOSED: "closed",
    OPEN: "open",
    ACTUATOR: "actuator",
    MANUAL: "man",
    DIAPHRAGM: "diaph",
    BALANCED_DIAPHRAGM: "balDiaph",
    MOTOR: "motor",
    NONE: "none",
    SPRING: "spring",
    PILOT: "pilot",
    POWERED: "powered",
    SOLENOID: "solenoid",
    SOLENOID_MANUAL_RESET: "solenoidManRes",
    SINGLE_ACTING: "singActing",
    DOUBLE_ACTING: "dblActing",
    PILOT_CYLINDER: "pilotCyl",
    DIGITAL: "digital",
    WEIGHT: "weight",
    KEY: "key",
    ELECTRO_HYDRAULIC: "elHyd",
    VALVE_TYPE: "valveType",
    BUTTERFLY: "butterfly",
    CHECK: "check",
    GATE: "gate",
    GLOBE: "globe",
    NEEDLE: "needle",
    PLUG: "plug",
    SELF_DRAINING: "selfDrain",
    ANGLE: "angle",
    ANGLE_GLOBE: "angleGlobe",
    THREE_WAY: "threeWay",
    ANGLE_BLOWDOWN: "angBlow",
    BALL: "ball"
};
mxShapePidValve.prototype.paintVertexShape = function(c, x, y, w, h) {
    var valveType = mxUtils.getValue(this.style, mxShapePidValve.prototype.cst.VALVE_TYPE, "gate");
    var actuator = mxUtils.getValue(this.style, mxShapePidValve.prototype.cst.ACTUATOR, mxShapePidValve.prototype.cst.NONE);
    var actH = 0;
    if (actuator !== "none")
        if (this.isAngleVariant(valveType))
            actH = h * .3333;
        else
            actH = h * .4;
    c.translate(x, y);
    c.setLineJoin("round");
    this.background(c, x, y, w, h, valveType, actuator, actH);
    c.setShadow(false);
    this.foreground(c, x, y, w, h, valveType, actuator, actH)
}
;
mxShapePidValve.prototype.background = function(c, x, y, w, h, valveType, actuator, actH) {
    if (actuator !== mxShapePidValve.prototype.cst.NONE)
        if (this.isAngleVariant(valveType))
            this.drawActuatorBg(c, x, y, w, h / 1.2, actuator, actH);
        else
            this.drawActuatorBg(c, x, y, w, h, actuator, actH);
    if (this.isGateVariant(valveType))
        this.drawGateVariantBg(c, 0, 0, w, h, valveType, actuator, actH);
    else if (this.isAngleVariant(valveType))
        this.drawAngleVariantBg(c, 0, 0, w, h, valveType, actuator, actH);
    else if (valveType === mxShapePidValve.prototype.cst.BUTTERFLY)
        this.drawButterflyValve(c, 0, 0, w, h, actuator, actH);
    else if (valveType === mxShapePidValve.prototype.cst.CHECK)
        this.drawCheckValve(c, 0, 0, w, h, actuator, actH)
}
;
mxShapePidValve.prototype.foreground = function(c, x, y, w, h, valveType, actuator, actH) {
    var valveType = mxUtils.getValue(this.style, mxShapePidValve.prototype.cst.VALVE_TYPE, "gate");
    if (actuator !== mxShapePidValve.prototype.cst.NONE)
        if (this.isAngleVariant(valveType))
            this.drawActuatorFg(c, x, y, w, h / 1.2, actuator, actH);
        else
            this.drawActuatorFg(c, x, y, w, h, actuator, actH);
    if (this.isGateVariant(valveType))
        this.drawGateVariantFg(c, 0, 0, w, h, valveType, actuator, actH);
    if (this.isAngleVariant(valveType))
        this.drawAngleVariantFg(c, 0, 0, w, h, valveType, actuator, actH)
}
;
mxShapePidValve.prototype.drawActuatorBg = function(c, x, y, w, h, actuator) {
    if (this.isSquareVariant(actuator)) {
        c.translate(w * .325, 0);
        this.drawSquareAct(c, w * .35, h * .7, actuator);
        c.translate(-w * .325, 0)
    } else if (actuator === mxShapePidValve.prototype.cst.MANUAL) {
        c.translate(w * .25, h * .15);
        this.drawManAct(c, w * .5, h * .55);
        c.translate(-w * .25, -h * .15)
    } else if (actuator === mxShapePidValve.prototype.cst.DIAPHRAGM) {
        c.translate(w * .25, h * .1);
        this.drawDiaphAct(c, w * .5, h * .6);
        c.translate(-w * .25, -h * .1)
    } else if (actuator === mxShapePidValve.prototype.cst.BALANCED_DIAPHRAGM) {
        c.translate(w * .25, h * .1);
        this.drawBalDiaphActBg(c, w * .5, h * .6);
        c.translate(-w * .25, -h * .1)
    } else if (actuator === mxShapePidValve.prototype.cst.MOTOR || actuator === mxShapePidValve.prototype.cst.ELECTRO_HYDRAULIC) {
        c.translate(w * .325, 0);
        this.drawCircleAct(c, w * .35, h * .7, actuator);
        c.translate(-w * .325, 0)
    } else if (actuator === mxShapePidValve.prototype.cst.SPRING) {
        c.translate(w * .36, 0);
        this.drawSpringAct(c, w * .28, h * .7);
        c.translate(-w * .36, 0)
    } else if (actuator === mxShapePidValve.prototype.cst.SOLENOID_MANUAL_RESET) {
        c.translate(w * .325, 0);
        this.drawSolenoidManResetAct(c, w * .575, h * .7);
        c.translate(-w * .325, 0)
    } else if (actuator === mxShapePidValve.prototype.cst.SINGLE_ACTING) {
        c.translate(w * .35, 0);
        this.drawSingActingActBg(c, w * .65, h * .7);
        c.translate(-w * .35, 0)
    } else if (actuator === mxShapePidValve.prototype.cst.DOUBLE_ACTING) {
        c.translate(w * .35, 0);
        this.drawDblActingActBg(c, w * .65, h * .7);
        c.translate(-w * .35, 0)
    } else if (actuator === mxShapePidValve.prototype.cst.PILOT_CYLINDER) {
        c.translate(w * .35, 0);
        this.drawPilotCylinderActBg(c, w * .65, h * .7);
        c.translate(-w * .35, 0)
    } else if (actuator === mxShapePidValve.prototype.cst.ANGLE_BLOWDOWN) {
        c.translate(w * .5, h * .2);
        this.drawAngleBlowdownAct(c, w * .4, h * .5);
        c.translate(-w * .5, -h * .2)
    }
}
;
mxShapePidValve.prototype.drawActuatorFg = function(c, x, y, w, h, actuator) {
    if (actuator === mxShapePidValve.prototype.cst.BALANCED_DIAPHRAGM) {
        c.translate(w * .25, h * .1);
        this.drawBalDiaphActFg(c, w * .5, h * .6);
        c.translate(-w * .25, -h * .1)
    } else if (actuator === mxShapePidValve.prototype.cst.SINGLE_ACTING || actuator === mxShapePidValve.prototype.cst.DOUBLE_ACTING || actuator === mxShapePidValve.prototype.cst.PILOT_CYLINDER) {
        c.translate(w * .35, 0);
        this.drawActingActFg(c, w * .65, h * .7);
        c.translate(-w * .35, 0)
    }
}
;
mxShapePidValve.prototype.drawManAct = function(c, w, h) {
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.moveTo(w * .5, 0);
    c.lineTo(w * .5, h);
    c.stroke()
}
;
mxShapePidValve.prototype.drawDiaphAct = function(c, w, h) {
    c.begin();
    c.moveTo(w * .5, h * .2);
    c.lineTo(w * .5, h);
    c.stroke();
    c.begin();
    c.moveTo(0, h * .2);
    c.arcTo(w * .6, h * .4, 0, 0, 1, w, h * .2);
    c.close();
    c.fillAndStroke()
}
;
mxShapePidValve.prototype.drawBalDiaphActBg = function(c, w, h) {
    c.ellipse(0, 0, w, h * .3);
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .5, h * .3);
    c.lineTo(w * .5, h);
    c.stroke()
}
;
mxShapePidValve.prototype.drawBalDiaphActFg = function(c, w, h) {
    c.begin();
    c.moveTo(0, h * .15);
    c.lineTo(w, h * .15);
    c.stroke()
}
;
mxShapePidValve.prototype.drawCircleAct = function(c, w, h, actuator) {
    c.ellipse(0, 0, w, h * .5);
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .5, h * .5);
    c.lineTo(w * .5, h);
    c.stroke();
    var m = "";
    if (actuator === mxShapePidValve.prototype.cst.MOTOR)
        m = "M";
    else if (actuator === mxShapePidValve.prototype.cst.ELECTRO_HYDRAULIC)
        m = "E/H";
    c.setFontStyle(1);
    c.setFontFamily("Helvetica");
    c.setFontSize(Math.min(w, h) * .4);
    c.text(w * .5, h * .25, 0, 0, m, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxShapePidValve.prototype.drawSpringAct = function(c, w, h) {
    c.begin();
    c.moveTo(w * .5, 0);
    c.lineTo(w * .5, h);
    c.moveTo(w * .32, h * .16);
    c.lineTo(w * .68, h * .08);
    c.moveTo(w * .21, h * .32);
    c.lineTo(w * .79, h * .2);
    c.moveTo(w * .1, h * .52);
    c.lineTo(w * .9, h * .36);
    c.moveTo(0, h * .72);
    c.lineTo(w, h * .5);
    c.stroke()
}
;
mxShapePidValve.prototype.drawSolenoidManResetAct = function(c, w, h) {
    c.rect(0, 0, w * .61, h * .46);
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .56, h * .6);
    c.lineTo(w * .78, h * .5);
    c.lineTo(w, h * .6);
    c.lineTo(w * .78, h * .7);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .305, h * .46);
    c.lineTo(w * .305, h);
    c.moveTo(w * .305, h * .6);
    c.lineTo(w * .56, h * .6);
    c.stroke();
    c.setFontStyle(1);
    c.setFontFamily("Helvetica");
    c.setFontSize(Math.min(w, h) * .4);
    c.text(w * .305, h * .23, 0, 0, "S", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setFontStyle(0);
    c.setFontSize(Math.min(w, h) * .15);
    c.text(w * .78, h * .6, 0, 0, "R", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxShapePidValve.prototype.drawSingActingActBg = function(c, w, h) {
    c.rect(0, 0, w * .46, h * .46);
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .23, h * .46);
    c.lineTo(w * .23, h);
    c.moveTo(w * .46, h * .23);
    c.lineTo(w, h * .23);
    c.moveTo(w * .77, h * .15);
    c.lineTo(w * .69, h * .31);
    c.moveTo(w * .82, h * .15);
    c.lineTo(w * .74, h * .31);
    c.stroke()
}
;
mxShapePidValve.prototype.drawActingActFg = function(c, w, h) {
    c.begin();
    c.moveTo(w * .23, h * .23);
    c.lineTo(w * .23, h * .46);
    c.moveTo(0, h * .23);
    c.lineTo(w * .46, h * .23);
    c.stroke()
}
;
mxShapePidValve.prototype.drawDblActingActBg = function(c, w, h) {
    c.rect(0, 0, w * .46, h * .46);
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .23, h * .46);
    c.lineTo(w * .23, h);
    c.moveTo(w * .46, h * .115);
    c.lineTo(w, h * .115);
    c.moveTo(w * .77, h * .035);
    c.lineTo(w * .69, h * .195);
    c.moveTo(w * .82, h * .035);
    c.lineTo(w * .74, h * .195);
    c.moveTo(w * .46, h * .345);
    c.lineTo(w, h * .345);
    c.moveTo(w * .77, h * .265);
    c.lineTo(w * .69, h * .425);
    c.moveTo(w * .82, h * .265);
    c.lineTo(w * .74, h * .425);
    c.stroke()
}
;
mxShapePidValve.prototype.drawPilotCylinderActBg = function(c, w, h) {
    c.rect(0, 0, w * .46, h * .46);
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .23, h * .46);
    c.lineTo(w * .23, h);
    c.moveTo(w * .46, h * .23);
    c.lineTo(w * .77, h * .23);
    c.stroke();
    c.rect(w * .77, h * .115, w * .23, h * .23);
    c.fillAndStroke();
    c.setFontStyle(0);
    c.setFontFamily("Helvetica");
    c.setFontSize(Math.min(w, h) * .15);
    c.text(w * .885, h * .23, 0, 0, "P", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxShapePidValve.prototype.drawAngleBlowdownAct = function(c, w, h) {
    c.begin();
    c.moveTo(w * .34, 0);
    c.lineTo(w, h * .405);
    c.moveTo(0, h);
    c.lineTo(w * .665, h * .205);
    c.stroke()
}
;
mxShapePidValve.prototype.drawSquareAct = function(c, w, h, actuator) {
    c.rect(0, 0, w, h * .5);
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .5, h * .5);
    c.lineTo(w * .5, h);
    c.stroke();
    var m = "";
    if (actuator === mxShapePidValve.prototype.cst.PILOT)
        m = "P";
    else if (actuator === mxShapePidValve.prototype.cst.SOLENOID)
        m = "S";
    else if (actuator === mxShapePidValve.prototype.cst.DIGITAL)
        m = "D";
    else if (actuator === mxShapePidValve.prototype.cst.WEIGHT)
        m = "W";
    else if (actuator === mxShapePidValve.prototype.cst.KEY)
        m = "K";
    c.setFontStyle(1);
    c.setFontFamily("Helvetica");
    c.setFontSize(Math.min(w, h) * .4);
    c.text(w * .5, h * .25, 0, 0, m, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
mxShapePidValve.prototype.drawGateVariantFg = function(c, x, y, w, h, valveType, actuator, actH) {
    var defState = mxUtils.getValue(this.style, mxShapePidValve.prototype.cst.DEFAULT_STATE, "open");
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    if (valveType === mxShapePidValve.prototype.cst.BALL) {
        c.ellipse(x + w * .3, y + actH + (h - actH) * .18, w * .4, (h - actH) * .64);
        c.fillAndStroke()
    } else if (valveType === mxShapePidValve.prototype.cst.GLOBE) {
        c.ellipse(x + w * .3, y + actH + (h - actH) * .18, w * .4, (h - actH) * .64);
        c.setFillColor(strokeColor);
        c.fillAndStroke();
        c.setFillColor(fillColor)
    } else if (valveType === mxShapePidValve.prototype.cst.PLUG)
        this.drawPlug(c, x + w * .4, y + actH + (h - actH) * .25, w * .2, (h - actH) * .5);
    else if (valveType === mxShapePidValve.prototype.cst.NEEDLE)
        this.drawNeedle(c, x + w * .45, y + actH + (h - actH) * .1, w * .1, (h - actH) * .9);
    else if (valveType === mxShapePidValve.prototype.cst.SELF_DRAINING)
        this.drawDrain(c, x + w * .48, y + actH + (h - actH) * .5, w * .04, (h - actH) * .49)
}
;
mxShapePidValve.prototype.drawAngleVariantFg = function(c, x, y, w, h, valveType, actuator, actH) {
    var defState = mxUtils.getValue(this.style, mxShapePidValve.prototype.cst.DEFAULT_STATE, "open");
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    if (valveType === mxShapePidValve.prototype.cst.ANGLE_GLOBE) {
        if (actuator === "none")
            c.ellipse(w * .34, h * .175, w * .32, h * .4);
        else
            c.ellipse(w * .34, h * .45, w * .32, h * .2667);
        c.setFillColor(strokeColor);
        c.fillAndStroke();
        c.setFillColor(fillColor)
    }
}
;
mxShapePidValve.prototype.drawGateVariantBg = function(c, x, y, w, h, valveType, actuator, actH) {
    if (valveType === mxShapePidValve.prototype.cst.GATE)
        this.drawGateValve(c, x, y + actH, w, h - actH);
    else if (valveType === mxShapePidValve.prototype.cst.BALL || valveType === mxShapePidValve.prototype.cst.GLOBE) {
        c.ellipse(x + w * .3, y + actH + (h - actH) * .18, w * .4, (h - actH) * .64);
        c.fillAndStroke();
        this.drawGateValve(c, x, y + actH, w, h - actH)
    } else if (valveType === mxShapePidValve.prototype.cst.PLUG) {
        this.drawPlug(c, x + w * .4, y + actH + (h - actH) * .25, w * .2, (h - actH) * .5);
        this.drawGateValve(c, x, y + actH, w, h - actH)
    } else if (valveType === mxShapePidValve.prototype.cst.NEEDLE) {
        this.drawNeedle(c, x + w * .45, y + actH + (h - actH) * .1, w * .1, (h - actH) * .9);
        this.drawGateValve(c, x, y + actH, w, h - actH)
    } else if (valveType === mxShapePidValve.prototype.cst.SELF_DRAINING) {
        this.drawDrain(c, x + w * .48, y + actH + (h - actH) * .5, w * .04, (h - actH) * .49);
        this.drawGateValve(c, x, y + actH, w, h - actH)
    }
}
;
mxShapePidValve.prototype.drawAngleVariantBg = function(c, x, y, w, h, valveType, actuator, actH) {
    if (valveType === mxShapePidValve.prototype.cst.ANGLE)
        this.drawAngleValve(c, w * .2, y + actH, w * .8, h - actH);
    else if (valveType === mxShapePidValve.prototype.cst.ANGLE_GLOBE)
        this.drawAngleGlobeValveBg(c, w * .2, y + actH, w * .8, h - actH);
    else if (valveType === mxShapePidValve.prototype.cst.THREE_WAY)
        this.drawThreeWayValve(c, 0, y + actH, w, h - actH);
    else if (valveType === mxShapePidValve.prototype.cst.ANGLE_BLOWDOWN)
        this.drawAngleBlowdownValve(c, x, y + actH, w, h - actH)
}
;
mxShapePidValve.prototype.drawPlug = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.moveTo(0, h * .5);
    c.lineTo(w * .5, 0);
    c.lineTo(w, h * .5);
    c.lineTo(w * .5, h);
    c.close();
    c.fillAndStroke();
    c.translate(-x, -y)
}
;
mxShapePidValve.prototype.drawNeedle = function(c, x, y, w, h) {
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    c.translate(x, y);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w, 0);
    c.lineTo(w * .5, h);
    c.close();
    c.setFillColor(strokeColor);
    c.fillAndStroke();
    c.setFillColor(fillColor);
    c.translate(-x, -y)
}
;
mxShapePidValve.prototype.drawDrain = function(c, x, y, w, h) {
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    c.translate(x, y);
    c.begin();
    c.moveTo(w * .5, 0);
    c.lineTo(w * .5, h * .96);
    c.stroke();
    c.begin();
    c.moveTo(0, h * .9);
    c.lineTo(w, h * .9);
    c.lineTo(w * .5, h);
    c.close();
    c.setFillColor(strokeColor);
    c.fillAndStroke();
    c.setFillColor(fillColor);
    c.translate(-x, -y)
}
;
mxShapePidValve.prototype.drawGateValve = function(c, x, y, w, h) {
    var defState = mxUtils.getValue(this.style, mxShapePidValve.prototype.cst.DEFAULT_STATE, "open");
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    c.translate(x, y);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w * .5, h * .5);
    c.lineTo(0, h);
    c.close();
    c.moveTo(w, 0);
    c.lineTo(w * .5, h * .5);
    c.lineTo(w, h);
    c.close();
    if (defState === mxShapePidValve.prototype.cst.CLOSED) {
        c.setFillColor(strokeColor);
        c.fillAndStroke();
        c.setFillColor(fillColor)
    } else
        c.fillAndStroke();
    c.translate(-x, -y)
}
;
mxShapePidValve.prototype.drawAngleValve = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.moveTo(w * .375, h * .375);
    c.lineTo(w, 0);
    c.lineTo(w, h * .75);
    c.close();
    c.moveTo(w * .375, h * .375);
    c.lineTo(w * .75, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke();
    c.translate(-x, -y)
}
;
mxShapePidValve.prototype.drawAngleGlobeValveBg = function(c, x, y, w, h) {
    c.translate(x, y);
    c.ellipse(w * .175, h * .175, w * .4, h * .4);
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .375, h * .375);
    c.lineTo(w, 0);
    c.lineTo(w, h * .75);
    c.close();
    c.moveTo(w * .375, h * .375);
    c.lineTo(w * .75, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke();
    c.translate(-x, -y)
}
;
mxShapePidValve.prototype.drawAngleGlobeValveFg = function(c, x, y, w, h) {
    c.translate(x, y);
    c.ellipse(w * .275, h * .275, w * .2, h * .2);
    c.fillAndStroke();
    c.translate(-x, -y)
}
;
mxShapePidValve.prototype.drawThreeWayValve = function(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w * .5, h * .375);
    c.lineTo(0, h * .75);
    c.close();
    c.moveTo(w, 0);
    c.lineTo(w * .5, h * .375);
    c.lineTo(w, h * .75);
    c.close();
    c.moveTo(w * .5, h * .375);
    c.lineTo(w * .8, h);
    c.lineTo(w * .2, h);
    c.close();
    c.fillAndStroke();
    c.translate(-x, -y)
}
;
mxShapePidValve.prototype.drawAngleBlowdownValve = function(c, x, y, w, h) {}
;
mxShapePidValve.prototype.drawButterflyValve = function(c, x, y, w, h, actuator, actH) {
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    var yv = y + actH;
    var hv = h - actH;
    c.translate(x, yv);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(0, hv);
    c.moveTo(w, 0);
    c.lineTo(w, hv);
    c.moveTo(w * .05, hv * .05);
    c.lineTo(w * .95, hv * .95);
    c.fillAndStroke();
    c.ellipse(w * .4, hv * .33, w * .2, hv * .33);
    c.fillAndStroke();
    c.translate(-x, -y)
}
;
mxShapePidValve.prototype.drawCheckValve = function(c, x, y, w, h, actuator, actH) {
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    var yv = y + actH;
    var hv = h - actH;
    c.translate(x, yv);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(0, hv);
    c.moveTo(w, 0);
    c.lineTo(w, hv);
    c.moveTo(w * .05, hv * .05);
    c.lineTo(w * .95, hv * .95);
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .8925, hv * .815);
    c.lineTo(w * .957, hv * .955);
    c.lineTo(w * .85, hv * .928);
    c.close();
    c.setFillColor(strokeColor);
    c.fillAndStroke();
    c.setFillColor(fillColor);
    c.translate(-x, -y)
}
;
mxShapePidValve.prototype.isGateVariant = function(valveType) {
    if (valveType === mxShapePidValve.prototype.cst.GATE || valveType === mxShapePidValve.prototype.cst.BALL || valveType === mxShapePidValve.prototype.cst.PLUG || valveType === mxShapePidValve.prototype.cst.NEEDLE || valveType === mxShapePidValve.prototype.cst.SELF_DRAINING || valveType === mxShapePidValve.prototype.cst.GLOBE)
        return true;
    else
        return false
}
;
mxShapePidValve.prototype.isAngleVariant = function(valveType) {
    if (valveType === mxShapePidValve.prototype.cst.ANGLE || valveType === mxShapePidValve.prototype.cst.ANGLE_GLOBE || valveType === mxShapePidValve.prototype.cst.THREE_WAY || valveType === mxShapePidValve.prototype.cst.ANGLE_BLOWDOWN)
        return true;
    else
        return false
}
;
mxShapePidValve.prototype.isSquareVariant = function(actType) {
    if (actType === mxShapePidValve.prototype.cst.PILOT || actType === mxShapePidValve.prototype.cst.SOLENOID || actType === mxShapePidValve.prototype.cst.POWERED || actType === mxShapePidValve.prototype.cst.DIGITAL || actType === mxShapePidValve.prototype.cst.WEIGHT || actType === mxShapePidValve.prototype.cst.KEY)
        return true;
    else
        return false
}
;
mxCellRenderer.registerShape(mxShapePidValve.prototype.cst.SHAPE_VALVE, mxShapePidValve);
function mxShapePidIntBlockBleedValve(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapePidIntBlockBleedValve, mxShapePidValve);
mxShapePidIntBlockBleedValve.prototype.paintVertexShape = function(c, x, y, w, h) {
    var actuator = mxUtils.getValue(this.style, mxShapePidIntBlockBleedValve.prototype.cst.ACTUATOR, mxShapePidIntBlockBleedValve.prototype.cst.NONE);
    var actH = 0;
    if (actuator !== "none")
        actH = h * .2353;
    c.translate(x, y);
    c.setLineJoin("round");
    this.background(c, x, y, w, h, actuator, actH);
    c.setShadow(false);
    this.foreground(c, x, y, w, h, actuator, actH)
}
;
mxShapePidIntBlockBleedValve.prototype.background = function(c, x, y, w, h, actuator, actH) {
    if (actuator !== mxShapePidIntBlockBleedValve.prototype.cst.NONE)
        this.drawActuatorBg(c, x, y, w, h, actuator);
    this.drawValveBg(c, 0, actH, w, h - actH)
}
;
mxShapePidIntBlockBleedValve.prototype.foreground = function(c, x, y, w, h, actuator, actH) {
    if (actuator !== mxShapePidIntBlockBleedValve.prototype.cst.NONE)
        this.drawActuatorFg(c, x, y, w, h, actuator)
}
;
mxShapePidIntBlockBleedValve.prototype.drawValveBg = function(c, x, y, w, h) {
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    c.translate(x, y);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(w * .5, h * .23);
    c.lineTo(0, h * .46);
    c.close();
    c.moveTo(w * .5, h * .23);
    c.lineTo(w, 0);
    c.lineTo(w, h * .46);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .5, h * .23);
    c.lineTo(w * .5, h * .5);
    c.stroke();
    c.setFillColor(strokeColor);
    c.begin();
    c.moveTo(w * .3, h * .5);
    c.lineTo(w * .7, h * .5);
    c.lineTo(w * .5, h * .75);
    c.close();
    c.fillAndStroke();
    c.begin();
    c.moveTo(w * .3, h);
    c.lineTo(w * .5, h * .75);
    c.lineTo(w * .7, h);
    c.fillAndStroke();
    c.setFillColor(fillColor);
    c.translate(-x, -y)
}
;
mxShapePidIntBlockBleedValve.prototype.drawActuatorBg = function(c, x, y, w, h, actuator) {
    if (this.isSquareVariant(actuator)) {
        c.translate(w * .325, 0);
        this.drawSquareAct(c, w * .35, h * .4112, actuator);
        c.translate(-w * .325, 0)
    } else if (actuator === mxShapePidIntBlockBleedValve.prototype.cst.MANUAL) {
        c.translate(w * .25, h * .0882);
        this.drawManAct(c, w * .5, h * .323);
        c.translate(-w * .25, -h * .0882)
    } else if (actuator === mxShapePidIntBlockBleedValve.prototype.cst.DIAPHRAGM) {
        c.translate(w * .25, h * .0588);
        this.drawDiaphAct(c, w * .5, h * .3524);
        c.translate(-w * .25, -h * .0588)
    } else if (actuator === mxShapePidIntBlockBleedValve.prototype.cst.BALANCED_DIAPHRAGM) {
        c.translate(w * .25, h * .0588);
        this.drawBalDiaphActBg(c, w * .5, h * .3524);
        c.translate(-w * .25, -h * .0588)
    } else if (actuator === mxShapePidIntBlockBleedValve.prototype.cst.MOTOR || actuator === mxShapePidIntBlockBleedValve.prototype.cst.ELECTRO_HYDRAULIC) {
        c.translate(w * .325, 0);
        this.drawCircleAct(c, w * .35, h * .4112, actuator);
        c.translate(-w * .325, 0)
    } else if (actuator === mxShapePidIntBlockBleedValve.prototype.cst.SPRING) {
        c.translate(w * .36, 0);
        this.drawSpringAct(c, w * .28, h * .4112);
        c.translate(-w * .36, 0)
    } else if (actuator === mxShapePidIntBlockBleedValve.prototype.cst.SOLENOID_MANUAL_RESET) {
        c.translate(w * .325, 0);
        this.drawSolenoidManResetAct(c, w * .575, h * .4112);
        c.translate(-w * .325, 0)
    } else if (actuator === mxShapePidIntBlockBleedValve.prototype.cst.SINGLE_ACTING) {
        c.translate(w * .35, 0);
        this.drawSingActingActBg(c, w * .65, h * .4112);
        c.translate(-w * .35, 0)
    } else if (actuator === mxShapePidIntBlockBleedValve.prototype.cst.DOUBLE_ACTING) {
        c.translate(w * .35, 0);
        this.drawDblActingActBg(c, w * .65, h * .4112);
        c.translate(-w * .35, 0)
    } else if (actuator === mxShapePidIntBlockBleedValve.prototype.cst.PILOT_CYLINDER) {
        c.translate(w * .35, 0);
        this.drawPilotCylinderActBg(c, w * .65, h * .4112);
        c.translate(-w * .35, 0)
    }
}
;
mxShapePidIntBlockBleedValve.prototype.drawActuatorFg = function(c, x, y, w, h, actuator) {
    if (actuator === mxShapePidIntBlockBleedValve.prototype.cst.BALANCED_DIAPHRAGM) {
        c.translate(w * .25, h * .0588);
        this.drawBalDiaphActFg(c, w * .5, h * .3524);
        c.translate(-w * .25, -h * .0588)
    } else if (actuator === mxShapePidIntBlockBleedValve.prototype.cst.SINGLE_ACTING || actuator === mxShapePidIntBlockBleedValve.prototype.cst.DOUBLE_ACTING || actuator === mxShapePidIntBlockBleedValve.prototype.cst.PILOT_CYLINDER) {
        c.translate(w * .35, 0);
        this.drawActingActFg(c, w * .65, h * .4112);
        c.translate(-w * .35, 0)
    }
}
;
mxCellRenderer.registerShape("mxgraph.pid2valves.blockBleedValve", mxShapePidIntBlockBleedValve);
function mxShapePidAutoRecircValve(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxShapePidAutoRecircValve, mxShape);
mxShapePidAutoRecircValve.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.setLineJoin("round");
    c.translate(x, y);
    c.rect(0, 0, w, h);
    c.fillAndStroke();
    c.setShadow(false);
    c.begin();
    c.moveTo(w * .08, h * .08);
    c.lineTo(w * .08, h * .92);
    c.moveTo(w * .92, h * .08);
    c.lineTo(w * .92, h * .92);
    c.moveTo(w * .12, h * .122);
    c.lineTo(w * .8738, h * .8837);
    c.moveTo(w * .5, 0);
    c.lineTo(w * .55, h * .05);
    c.lineTo(w * .45, h * .15);
    c.lineTo(w * .55, h * .25);
    c.lineTo(w * .45, h * .35);
    c.lineTo(w * .55, h * .45);
    c.lineTo(w * .49, h * .5);
    c.stroke();
    var fillColor = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, "#ffffff");
    var strokeColor = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, "#000000");
    c.begin();
    c.moveTo(w * .8257, h * .7695);
    c.lineTo(w * .8797, h * .888);
    c.lineTo(w * .79, h * .8651);
    c.close();
    c.setFillColor(strokeColor);
    c.fillAndStroke();
    c.setFillColor(fillColor)
}
;
mxCellRenderer.registerShape("mxgraph.pid2valves.autoRecircValve", mxShapePidAutoRecircValve);
function mxRackContainer(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxRackContainer, mxShape);
mxRackContainer.unitSize = 20;
mxRackContainer.prototype.cst = {
    SHAPE_RACK_CONTAINER: "mxgraph.rackGeneral.container",
    TEXT_COLOR: "textColor",
    NUMBER_DISPLAY: "numDisp",
    OFF: "off",
    DIR_ASC: "ascend",
    DIR_DESC: "descend"
};
mxRackContainer.prototype.paintVertexShape = function(c, x, y, w, h) {
    var fontSize = 12;
    var displayNumbers = mxUtils.getValue(this.style, mxRackContainer.prototype.cst.NUMBER_DISPLAY, mxRackContainer.prototype.cst.DIR_ASC);
    if (displayNumbers !== mxRackContainer.prototype.cst.OFF) {
        c.translate(x + fontSize * 2, y);
        w = Math.max(w - fontSize * 2, 0)
    } else
        c.translate(x, y);
    this.background(c, w, h, fontSize);
    c.setShadow(false);
    this.foreground(c, w, h, fontSize);
    if (displayNumbers !== mxRackContainer.prototype.cst.OFF && w > 18 + fontSize * 2)
        this.sideText(c, w, h, fontSize)
}
;
mxRackContainer.prototype.background = function(c, w, h, fontSize) {
    c.setFillColor("#ffffff");
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxRackContainer.prototype.foreground = function(c, w, h, fontSize) {
    if (w > 18 + fontSize * 2 && h > 42) {
        c.setFillColor("#f4f4f4");
        c.rect(0, 0, w, 21);
        c.fillAndStroke();
        c.rect(0, h - 21, w, 21);
        c.fillAndStroke();
        c.rect(0, 21, 9, h - 42);
        c.fillAndStroke();
        c.rect(w - 9, 21, 9, h - 42);
        c.fillAndStroke();
        c.ellipse(2.5, 7.5, 6, 6);
        c.stroke();
        c.ellipse(w - 8.5, 7.5, 6, 6);
        c.stroke();
        c.ellipse(2.5, h - 13.5, 6, 6);
        c.stroke();
        c.ellipse(w - 8.5, h - 13.5, 6, 6);
        c.stroke()
    }
}
;
mxRackContainer.prototype.sideText = function(c, w, h, fontSize) {
    var fontColor = mxUtils.getValue(this.style, mxRackContainer.prototype.cst.TEXT_COLOR, "#666666");
    var displayNumbers = mxUtils.getValue(this.style, mxRackContainer.prototype.cst.NUMBER_DISPLAY, mxRackContainer.prototype.cst.DIR_ASC);
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    var units = Math.floor((Math.abs(h) - 42) / mxRackContainer.unitSize);
    for (var i = 0; i < units; i++) {
        var displayNumber = displayNumbers === mxRackContainer.prototype.cst.DIR_DESC ? (i + 1).toString() : (units - i).toString();
        c.text(-fontSize, 21 + mxRackContainer.unitSize * .5 + i * mxRackContainer.unitSize, 0, 0, displayNumber, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
    }
    c.setStrokeColor("#dddddd");
    c.begin();
    for (var i = 0; i < units + 1; i++) {
        c.moveTo(-2 * fontSize, 21 + i * mxRackContainer.unitSize);
        c.lineTo(0, 21 + i * mxRackContainer.unitSize)
    }
    c.stroke()
}
;
function mxRackPlate(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = 1
}
mxUtils.extend(mxRackPlate, mxShape);
mxRackPlate.prototype.cst = {
    SHAPE_RACK_PLATE: "mxgraph.rackGeneral.plate"
};
mxRackPlate.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxRackPlate.prototype.background = function(c, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxRackPlate.prototype.foreground = function(c, w, h) {
    var bufferSize = 9;
    if (w > bufferSize * 2) {
        c.save();
        c.setFillColor("#b4b4b4");
        c.rect(0, 0, w, h);
        c.fillAndStroke();
        c.restore();
        c.rect(bufferSize, 0, w - bufferSize * 2, h);
        c.fillAndStroke()
    }
}
;
function mxRackHorCableDuct(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxRackHorCableDuct, mxShape);
mxRackHorCableDuct.prototype.cst = {
    SHAPE_RACK_HOR_CABLE_DUCT: "mxgraph.rackGeneral.horCableDuct"
};
mxRackHorCableDuct.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxRackHorCableDuct.prototype.background = function(c, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxRackHorCableDuct.prototype.foreground = function(c, w, h) {
    var spaceBuffer = 20;
    var unitSpacing = 33;
    var unitsAcross = Math.floor((w - spaceBuffer) / unitSpacing);
    var buffer = spaceBuffer / 2 + Math.floor((w - spaceBuffer - unitsAcross * unitSpacing) / 2);
    if (unitsAcross > 0)
        for (var i = 0; i <= unitsAcross; i++) {
            c.rect(buffer, 0, 3, 7);
            c.stroke();
            c.rect(buffer, 7, 3, 7.8);
            c.stroke();
            buffer += unitSpacing
        }
}
;
function mxRackHorRoutingBank(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxRackHorRoutingBank, mxShape);
mxRackHorRoutingBank.prototype.cst = {
    SHAPE_RACK_HOR_ROUTING_BANK: "mxgraph.rackGeneral.horRoutingBank"
};
mxRackHorRoutingBank.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxRackHorRoutingBank.prototype.background = function(c, w, h) {
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxRackHorRoutingBank.prototype.foreground = function(c, w, h) {
    var spaceBuffer = 20;
    var unitSpacing = 22;
    var rectWidth = 16;
    var unitsAcross = Math.floor((w - spaceBuffer - rectWidth) / unitSpacing);
    var unitsDown = Math.floor(h / mxRackContainer.unitSize);
    if (unitsAcross > 0 && unitsDown > 0)
        for (var i = 0; i < unitsDown; i++) {
            var buffer = (spaceBuffer + rectWidth) / 2 + Math.floor((w - spaceBuffer - rectWidth - unitsAcross * unitSpacing) / 2) - rectWidth / 2;
            for (var j = 0; j <= unitsAcross; j++) {
                c.rect(buffer, 4 + i * mxRackContainer.unitSize, rectWidth, 6.8);
                c.stroke();
                buffer += unitSpacing
            }
        }
}
;
function mxRackNeatPatch(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxRackNeatPatch, mxShape);
mxRackNeatPatch.prototype.cst = {
    SHAPE_RACK_NEAT_PATCH: "mxgraph.rackGeneral.neatPatch"
};
mxRackNeatPatch.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.mainText(c, w, h)
}
;
mxRackNeatPatch.prototype.background = function(c, w, h) {
    c.setFillColor("#666666");
    c.rect(0, 0, w, h);
    c.fillAndStroke()
}
;
mxRackNeatPatch.prototype.mainText = function(c, w, h) {
    c.setFontSize("12");
    c.setFontColor("#ffffff");
    c.setFontStyle(mxConstants.FONT_BOLD);
    c.text(w / 2, h - 6, 0, 0, "NEAT-PATCH", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
function mxRackShelf(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxRackShelf, mxShape);
mxRackShelf.prototype.cst = {
    SHAPE_RACK_SHELF: "mxgraph.rackGeneral.shelf"
};
mxRackShelf.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h)
}
;
mxRackShelf.prototype.background = function(c, w, h) {
    c.setStrokeWidth(2);
    c.begin();
    c.moveTo(1, 0);
    c.lineTo(1, h - 1);
    c.lineTo(w - 1, h - 1);
    c.lineTo(w - 1, 1);
    c.fillAndStroke()
}
;
function mxRackRackNumbering(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxRackRackNumbering, mxShape);
mxRackRackNumbering.prototype.cst = {
    SHAPE_RACK_RACK_NUMBERING: "mxgraph.rackGeneral.rackNumbering",
    UNIT_NUM: "unitNum",
    UNIT_HEIGHT: "unitHeight",
    TEXT_COLOR: "textColor",
    NUM_DIR: "numDir",
    DIR_ASC: "ascend",
    DIR_DESC: "descend",
    TEXT_SIZE: "textSize"
};
mxRackRackNumbering.prototype.paintVertexShape = function(c, x, y, w, h) {
    var unitNum = parseFloat(mxUtils.getValue(this.style, mxRackRackNumbering.prototype.cst.UNIT_NUM, "42"));
    var unitH = parseFloat(mxUtils.getValue(this.style, mxRackRackNumbering.prototype.cst.UNIT_HEIGHT, "14.8"));
    var fontSize = parseFloat(mxUtils.getValue(this.style, mxRackRackNumbering.prototype.cst.TEXT_SIZE, "12"));
    c.translate(x, y);
    var h = unitNum * unitH;
    this.background(c, w, h, fontSize);
    c.setShadow(false);
    this.sideText(c, w, h, unitNum, unitH, fontSize)
}
;
mxRackRackNumbering.prototype.background = function(c, w, h, fontSize) {
    c.rect(fontSize * 3, 0, 160.9, h);
    c.fillAndStroke()
}
;
mxRackRackNumbering.prototype.sideText = function(c, w, h, unitNum, unitH, fontSize) {
    var fontColor = mxUtils.getValue(this.style, mxRackRackNumbering.prototype.cst.TEXT_COLOR, "#666666");
    var numDir = mxUtils.getValue(this.style, mxRackRackNumbering.prototype.cst.NUM_DIR, mxRackRackNumbering.prototype.cst.DIR_DESC);
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    if (numDir === mxRackRackNumbering.prototype.cst.DIR_ASC)
        for (var i = 0; i < unitNum; i++)
            c.text(fontSize, unitH * .5 + i * unitH, 0, 0, (i + 1).toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    else
        for (var i = 0; i < unitNum; i++)
            c.text(fontSize, h - unitH * .5 - i * unitH, 0, 0, (i + 1).toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setStrokeColor("#dddddd");
    c.begin();
    for (var i = 0; i < unitNum + 1; i++) {
        c.moveTo(0, i * unitH);
        c.lineTo(fontSize * 3, i * unitH)
    }
    c.stroke()
}
;
function mxRackRackCabinet(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxRackRackCabinet, mxShape);
mxRackRackCabinet.prototype.cst = {
    SHAPE_RACK_RACK_CABINET: "mxgraph.rackGeneral.rackCabinet",
    UNIT_NUM: "unitNum",
    UNIT_HEIGHT: "unitHeight",
    TEXT_COLOR: "textColor",
    NUM_DIR: "numDir",
    NUMBER_DISPLAY: "numDisp",
    ON: "on",
    OFF: "off",
    DIR_ASC: "ascend",
    DIR_DESC: "descend",
    TEXT_SIZE: "textSize"
};
mxRackRackCabinet.prototype.paintVertexShape = function(c, x, y, w, h) {
    var unitNum = parseFloat(mxUtils.getValue(this.style, mxRackRackCabinet.prototype.cst.UNIT_NUM, "12"));
    var unitH = parseFloat(mxUtils.getValue(this.style, mxRackRackCabinet.prototype.cst.UNIT_HEIGHT, "14.8"));
    var fontSize = parseFloat(mxUtils.getValue(this.style, mxRackRackCabinet.prototype.cst.TEXT_SIZE, "12"));
    var numDis = mxUtils.getValue(this.style, mxRackRackCabinet.prototype.cst.NUMBER_DISPLAY, mxRackRackCabinet.prototype.cst.ON);
    if (numDis === mxRackRackCabinet.prototype.cst.ON)
        c.translate(x + fontSize * 2, y);
    else
        c.translate(x, y);
    var h = unitNum * unitH + 42;
    this.background(c, w, h, fontSize);
    c.setShadow(false);
    this.foreground(c, w, h, fontSize);
    if (numDis === mxRackRackCabinet.prototype.cst.ON)
        this.sideText(c, w, h, unitNum, unitH, fontSize)
}
;
mxRackRackCabinet.prototype.background = function(c, w, h, fontSize) {
    c.setFillColor("#ffffff");
    c.rect(0, 0, 180, h);
    c.fillAndStroke()
}
;
mxRackRackCabinet.prototype.foreground = function(c, w, h, fontSize) {
    c.setFillColor("#f4f4f4");
    c.rect(0, 0, 180, 21);
    c.fillAndStroke();
    c.rect(0, h - 21, 180, 21);
    c.fillAndStroke();
    c.rect(0, 21, 9, h - 42);
    c.fillAndStroke();
    c.rect(171, 21, 9, h - 42);
    c.fillAndStroke();
    c.ellipse(2.5, 7.5, 6, 6);
    c.stroke();
    c.ellipse(171.5, 7.5, 6, 6);
    c.stroke();
    c.ellipse(2.5, h - 13.5, 6, 6);
    c.stroke();
    c.ellipse(171.5, h - 13.5, 6, 6);
    c.stroke()
}
;
mxRackRackCabinet.prototype.sideText = function(c, w, h, unitNum, unitH, fontSize) {
    var fontColor = mxUtils.getValue(this.style, mxRackRackCabinet.prototype.cst.TEXT_COLOR, "#666666");
    var numDir = mxUtils.getValue(this.style, mxRackRackCabinet.prototype.cst.NUM_DIR, mxRackRackCabinet.prototype.cst.DIR_DESC);
    c.setFontSize(fontSize);
    c.setFontColor(fontColor);
    if (numDir === mxRackRackCabinet.prototype.cst.DIR_ASC)
        for (var i = 0; i < unitNum; i++)
            c.text(-fontSize, 21 + unitH * .5 + i * unitH, 0, 0, (i + 1).toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    else
        for (var i = 0; i < unitNum; i++)
            c.text(-fontSize, h - 21 - unitH * .5 - i * unitH, 0, 0, (i + 1).toString(), mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0);
    c.setStrokeColor("#dddddd");
    c.begin();
    for (var i = 0; i < unitNum + 1; i++) {
        c.moveTo(-2 * fontSize, 21 + i * unitH);
        c.lineTo(0, 21 + i * unitH)
    }
    c.stroke()
}
;
function mxRackHorCableDuct1U(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxRackHorCableDuct1U, mxShape);
mxRackHorCableDuct1U.prototype.cst = {
    SHAPE_RACK_HOR_CABLE_DUCT_1U: "mxgraph.rackGeneral.horCableDuct1U"
};
mxRackHorCableDuct1U.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxRackHorCableDuct1U.prototype.background = function(c, w, h) {
    c.rect(0, 0, 160.9, 14.8);
    c.fillAndStroke()
}
;
mxRackHorCableDuct1U.prototype.foreground = function(c, w, h) {
    c.rect(12, 0, 3, 7);
    c.stroke();
    c.rect(12, 7, 3, 7.8);
    c.stroke();
    c.rect(45.5, 0, 3, 7);
    c.stroke();
    c.rect(45.5, 7, 3, 7.8);
    c.stroke();
    c.rect(79, 0, 3, 7);
    c.stroke();
    c.rect(79, 7, 3, 7.8);
    c.stroke();
    c.rect(112.5, 0, 3, 7);
    c.stroke();
    c.rect(112.5, 7, 3, 7.8);
    c.stroke();
    c.rect(146, 0, 3, 7);
    c.stroke();
    c.rect(146, 7, 3, 7.8);
    c.stroke()
}
;
function mxRackHorCableDuct2U(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxRackHorCableDuct2U, mxShape);
mxRackHorCableDuct2U.prototype.cst = {
    SHAPE_RACK_HOR_CABLE_DUCT_2U: "mxgraph.rackGeneral.horCableDuct2U"
};
mxRackHorCableDuct2U.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxRackHorCableDuct2U.prototype.background = function(c, w, h) {
    c.rect(0, 0, 160.9, 29.6);
    c.fillAndStroke()
}
;
mxRackHorCableDuct2U.prototype.foreground = function(c, w, h) {
    c.rect(12, 0, 3, 7);
    c.stroke();
    c.rect(12, 7, 3, 22.6);
    c.stroke();
    c.rect(45.5, 0, 3, 7);
    c.stroke();
    c.rect(45.5, 7, 3, 22.6);
    c.stroke();
    c.rect(79, 0, 3, 7);
    c.stroke();
    c.rect(79, 7, 3, 22.6);
    c.stroke();
    c.rect(112.5, 0, 3, 7);
    c.stroke();
    c.rect(112.5, 7, 3, 22.6);
    c.stroke();
    c.rect(146, 0, 3, 7);
    c.stroke();
    c.rect(146, 7, 3, 22.6);
    c.stroke()
}
;
function mxRackHorRoutingBank1U(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxRackHorRoutingBank1U, mxShape);
mxRackHorRoutingBank1U.prototype.cst = {
    SHAPE_RACK_HOR_ROUTING_BANK_1U: "mxgraph.rackGeneral.horRoutingBank1U"
};
mxRackHorRoutingBank1U.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxRackHorRoutingBank1U.prototype.background = function(c, w, h) {
    c.rect(0, 0, 160.9, 14.8);
    c.fillAndStroke()
}
;
mxRackHorRoutingBank1U.prototype.foreground = function(c, w, h) {
    c.rect(10, 4, 17, 6.8);
    c.stroke();
    c.rect(31, 4, 17, 6.8);
    c.stroke();
    c.rect(52, 4, 17, 6.8);
    c.stroke();
    c.rect(73, 4, 17, 6.8);
    c.stroke();
    c.rect(94, 4, 17, 6.8);
    c.stroke();
    c.rect(115, 4, 17, 6.8);
    c.stroke();
    c.rect(136, 4, 17, 6.8);
    c.stroke()
}
;
function mxRackHorRoutingBank2U(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxRackHorRoutingBank2U, mxShape);
mxRackHorRoutingBank2U.prototype.cst = {
    SHAPE_RACK_HOR_ROUTING_BANK_2U: "mxgraph.rackGeneral.horRoutingBank2U"
};
mxRackHorRoutingBank2U.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxRackHorRoutingBank2U.prototype.background = function(c, w, h) {
    c.rect(0, 0, 160.9, 29.6);
    c.fillAndStroke()
}
;
mxRackHorRoutingBank2U.prototype.foreground = function(c, w, h) {
    c.rect(10, 4, 17, 6.8);
    c.stroke();
    c.rect(31, 4, 17, 6.8);
    c.stroke();
    c.rect(52, 4, 17, 6.8);
    c.stroke();
    c.rect(73, 4, 17, 6.8);
    c.stroke();
    c.rect(94, 4, 17, 6.8);
    c.stroke();
    c.rect(115, 4, 17, 6.8);
    c.stroke();
    c.rect(136, 4, 17, 6.8);
    c.stroke();
    c.rect(10, 18.8, 17, 6.8);
    c.stroke();
    c.rect(31, 18.8, 17, 6.8);
    c.stroke();
    c.rect(52, 18.8, 17, 6.8);
    c.stroke();
    c.rect(73, 18.8, 17, 6.8);
    c.stroke();
    c.rect(94, 18.8, 17, 6.8);
    c.stroke();
    c.rect(115, 18.8, 17, 6.8);
    c.stroke();
    c.rect(136, 18.8, 17, 6.8);
    c.stroke()
}
;
function mxRackNeatPatch2U(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxRackNeatPatch2U, mxShape);
mxRackNeatPatch2U.prototype.cst = {
    SHAPE_RACK_NEAT_PATCH_2U: "mxgraph.rackGeneral.neatPatch2U"
};
mxRackNeatPatch2U.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.mainText(c, w, h)
}
;
mxRackNeatPatch2U.prototype.background = function(c, w, h) {
    c.setFillColor("#666666");
    c.rect(0, 0, 160.9, 29.6);
    c.fillAndStroke()
}
;
mxRackNeatPatch2U.prototype.mainText = function(c, w, h) {
    c.setFontSize("12");
    c.setFontColor("#ffffff");
    c.setFontStyle(mxConstants.FONT_BOLD);
    c.text(80.45, 24, 0, 0, "NEAT-PATCH", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, 0, null, 0, 0, 0)
}
;
function mxRackShelf1U(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxRackShelf1U, mxShape);
mxRackShelf1U.prototype.cst = {
    SHAPE_RACK_SHELF_1U: "mxgraph.rackGeneral.shelf1U"
};
mxRackShelf1U.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h)
}
;
mxRackShelf1U.prototype.background = function(c, w, h) {
    c.setStrokeWidth(2);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(0, 14.8);
    c.lineTo(160.9, 14.8);
    c.lineTo(160.9, 0);
    c.fillAndStroke()
}
;
function mxRackShelf2U(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxRackShelf2U, mxShape);
mxRackShelf2U.prototype.cst = {
    SHAPE_RACK_SHELF_2U: "mxgraph.rackGeneral.shelf2U"
};
mxRackShelf2U.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h)
}
;
mxRackShelf2U.prototype.background = function(c, w, h) {
    c.setStrokeWidth(2);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(0, 29.6);
    c.lineTo(160.9, 29.6);
    c.lineTo(160.9, 0);
    c.fillAndStroke()
}
;
function mxRackShelf4U(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxRackShelf4U, mxShape);
mxRackShelf4U.prototype.cst = {
    SHAPE_RACK_SHELF_4U: "mxgraph.rackGeneral.shelf4U"
};
mxRackShelf4U.prototype.paintVertexShape = function(c, x, y, w, h) {
    c.translate(x, y);
    this.background(c, w, h)
}
;
mxRackShelf4U.prototype.background = function(c, w, h) {
    c.setStrokeWidth(2);
    c.begin();
    c.moveTo(0, 0);
    c.lineTo(0, 59.2);
    c.lineTo(160.9, 59.2);
    c.lineTo(160.9, 0);
    c.fillAndStroke()
}
;
function mxRackChannelBase(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxRackChannelBase, mxShape);
mxRackChannelBase.prototype.cst = {
    SHAPE_RACK_CHANNEL_BASE: "mxgraph.rackGeneral.channelBase"
};
mxRackChannelBase.prototype.paintVertexShape = function(c, x, y, w, h) {
    w = Math.max(w, 20);
    h = Math.max(h, 20);
    c.translate(x, y);
    this.background(c, w, h);
    c.setShadow(false);
    this.foreground(c, w, h)
}
;
mxRackChannelBase.prototype.background = function(c, w, h) {
    c.rect(10, h - 15, 5, 15);
    c.fillAndStroke();
    c.rect(w - 15, h - 15, 5, 15);
    c.fillAndStroke();
    c.rect(0, 0, w, h - 5);
    c.fillAndStroke()
}
;
mxRackChannelBase.prototype.foreground = function(c, w, h) {
    c.setFillColor("#000000");
    c.rect(10, h - 15, 5, 15);
    c.fillAndStroke();
    c.rect(w - 15, h - 15, 5, 15);
    c.fillAndStroke()
}
;
function mxRackCabinetLeg(bounds, fill, stroke, strokewidth) {
    mxShape.call(this);
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokewidth = strokewidth != null ? strokewidth : 1
}
mxUtils.extend(mxRackCabinetLeg, mxShape);
mxRackCabinetLeg.prototype.cst = {
    SHAPE_RACK_CABINET_LEG: "mxgraph.rackGeneral.cabinetLeg"
};
mxRackCabinetLeg.prototype.paintVertexShape = function(c, x, y, w, h) {
    w = Math.max(w, 20);
    h = Math.max(h, 20);
    c.translate(x, y);
    this.background(c, w, h)
}
;
mxRackCabinetLeg.prototype.background = function(c, w, h) {
    c.begin();
    c.moveTo(0, h - 10);
    c.lineTo(5, h - 10);
    c.lineTo(5, h - 12);
    c.lineTo(9, h - 12);
    c.lineTo(9, h - 10);
    c.lineTo(w - 10, h - 10);
    c.lineTo(w - 10, 9);
    c.lineTo(w - 12, 9);
    c.lineTo(w - 12, 5);
    c.lineTo(w - 10, 5);
    c.lineTo(w - 10, 0);
    c.lineTo(w, 0);
    c.lineTo(w, h);
    c.lineTo(0, h);
    c.close();
    c.fillAndStroke()
}
;
mxCellRenderer.registerShape(mxRackContainer.prototype.cst.SHAPE_RACK_CONTAINER, mxRackContainer);
mxCellRenderer.registerShape(mxRackHorCableDuct.prototype.cst.SHAPE_RACK_HOR_CABLE_DUCT, mxRackHorCableDuct);
mxCellRenderer.registerShape(mxRackHorRoutingBank.prototype.cst.SHAPE_RACK_HOR_ROUTING_BANK, mxRackHorRoutingBank);
mxCellRenderer.registerShape(mxRackNeatPatch.prototype.cst.SHAPE_RACK_NEAT_PATCH, mxRackNeatPatch);
mxCellRenderer.registerShape(mxRackShelf.prototype.cst.SHAPE_RACK_SHELF, mxRackShelf);
mxCellRenderer.registerShape(mxRackPlate.prototype.cst.SHAPE_RACK_PLATE, mxRackPlate);
mxCellRenderer.registerShape(mxRackRackNumbering.prototype.cst.SHAPE_RACK_RACK_NUMBERING, mxRackRackNumbering);
mxCellRenderer.registerShape(mxRackRackCabinet.prototype.cst.SHAPE_RACK_RACK_CABINET, mxRackRackCabinet);
mxCellRenderer.registerShape(mxRackHorCableDuct1U.prototype.cst.SHAPE_RACK_HOR_CABLE_DUCT_1U, mxRackHorCableDuct1U);
mxCellRenderer.registerShape(mxRackHorCableDuct2U.prototype.cst.SHAPE_RACK_HOR_CABLE_DUCT_2U, mxRackHorCableDuct2U);
mxCellRenderer.registerShape(mxRackHorRoutingBank1U.prototype.cst.SHAPE_RACK_HOR_ROUTING_BANK_1U, mxRackHorRoutingBank1U);
mxCellRenderer.registerShape(mxRackHorRoutingBank2U.prototype.cst.SHAPE_RACK_HOR_ROUTING_BANK_2U, mxRackHorRoutingBank2U);
mxCellRenderer.registerShape(mxRackNeatPatch2U.prototype.cst.SHAPE_RACK_NEAT_PATCH_2U, mxRackNeatPatch2U);
mxCellRenderer.registerShape(mxRackShelf1U.prototype.cst.SHAPE_RACK_SHELF_1U, mxRackShelf1U);
mxCellRenderer.registerShape(mxRackShelf2U.prototype.cst.SHAPE_RACK_SHELF_2U, mxRackShelf2U);
mxCellRenderer.registerShape(mxRackShelf4U.prototype.cst.SHAPE_RACK_SHELF_4U, mxRackShelf4U);
mxCellRenderer.registerShape(mxRackChannelBase.prototype.cst.SHAPE_RACK_CHANNEL_BASE, mxRackChannelBase);
mxCellRenderer.registerShape(mxRackCabinetLeg.prototype.cst.SHAPE_RACK_CABINET_LEG, mxRackCabinetLeg);
